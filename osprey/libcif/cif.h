/*

  Copyright (C) 2000, 2001 Silicon Graphics, Inc.  All Rights Reserved.

  This program is free software; you can redistribute it and/or modify it
  under the terms of version 2.1 of the GNU Lesser General Public License 
  as published by the Free Software Foundation.

  This program is distributed in the hope that it would be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  

  Further, this software is distributed without any warranty that it is
  free of the rightful claim of any third person regarding infringement 
  or the like.  Any license provided herein, whether implied or 
  otherwise, applies only to this software file.  Patent licenses, if
  any, provided herein do not apply to combinations of this program with 
  other software, or any other product whatsoever.  

  You should have received a copy of the GNU Lesser General Public 
  License along with this program; if not, write the Free Software 
  Foundation, Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, 
  USA.

  Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
  Mountain View, CA 94043, or:

  http://www.sgi.com

  For further information regarding this notice, see:

  http://oss.sgi.com/projects/GenInfo/NoticeExplan

*/


/* USMID @(#) libcif/cif.h	30.22	08/17/98 09:32:40 */


/*
 *	Compiler Information File structure declarations, symbolic constants,
 *	and prototype definitions.
 */


/*
 * cif version 1 is released with UNICOS 7.0. It supports cif's
 * generated from cft77 5.0 and scc 3.0.
 * cif version 2 is released with the asynchronous CrayTools 1.0.
 * It supports all v1 records and also, new, version 2 records
 * generated by cft77 6.0, scc 4.0 and cft90 1.0.
 * cif version 3 is released with CrayTools 2.0, supporting F90 2.0
 * and CC 2.0
 *
 * Comments below that talk about v1 and v2 can be extended to include v3
 *
 *
 * Tools using the library my be considered v1 or v2. This is
 * identified by setting the constant CIF_VERSION before all
 * inclusions of this (cif.h) file. No definition implies a
 * version of 1. Tools that request version 2 will only ever
 * see version 2 records, the library mapping v1 records to
 * the new formats as needed. This is also true for v1 tools,
 * they will never see a v2 record.
 *
 * A number of the records have conditional parts depending on
 * the cif version. Use only the version of the records that
 * your tool will need. All new tools should adopt the latest
 * version, even if they do not need some of the new record fields.
 */

/*
 * Note. Fortran refers to both F77 and F90, unless either is
 * specifically mentioned
 */

#ifndef _CIF_H
#define _CIF_H

/* If the user hasn't specified the user version level, set it to 1 */
#ifndef CIF_VERSION
#	define CIF_VERSION 1
#endif

/* The latest version of CIF information that libcif can handle */
#define _CIF_INT_VERSION 3

/*
 * The sub version number so that a v2 cif application has to link
 * with the correct libcif.a that this cif.h matches. See cifopen
 * for details.
 *
 * This number will get increased for every significant change for
 * which library and cif.h have to be in sync.
 */
#define CIF_SUB_VERSION_2 3
#define CIF_SUB_VERSION_3 1

/* 1->2 : change of f90_object record to increase atype from 2 to 3 bits
 *	  at the expense of a previously unused bit. atype has to hold
 * 	  upto the value 4, which it couldn't do before
 */

#if defined(__STDC__) && CIF_VERSION > _CIF_INT_VERSION || CIF_VERSION < 1
#error "Please define CIF_VERSION correctly. If in doubt, use CIF_VERSION 1"
#endif



/* --- interface routine declarations --- */

#if defined(__STDC__) || defined(__cplusplus)
#	define __(_A) _A
#else
#	define __(_A) ()
#endif

#if defined(__cplusplus)
#	define CIF_BEGIN_DECLS   extern "C" {
#	define CIF_END_DECLS  };
#else
#	define CIF_BEGIN_DECLS
#	define CIF_END_DECLS
#endif

extern int Cif_Open __((char *, char *, int *, int));

/*
 * Map Cif_Open call for version 1 cif applications so that we can
 * check if a version one compiled application is trying to read
 * version 2 cif. An application can only use a cif >= the cif library
 * version that it was compiled with
 */

#if CIF_VERSION == 1
#	define Cif_Open Cif_Open_V1
#endif

/*
 * Special open for version 2 applications, allows us to check if they are
 * trying to open a cif less than the library thay they were compiled
 * with; ie app = v1, trying to open a v2 cif
 */

/*
 * V2.1 of cif_open adds an extra argument to the call which is the
 * sub-version of this cif.h, that is it allows a check that even though
 * cif.h and libcif.a have the same version number, they are actually
 * identical. CIF_SUB_VERSION will be bumped when something major
 * happens in the cif forcing a re-compile of any tools using it.
 * This is a development/install check only...userse should not see it
 * if libcif.a and the cif.h used to compile a tool are in sync
 *
 * cif_open_v2 needs to remain as some alreday compiled codes that use
 * cif_open (and are mapped to cif_open_v2 have to stay working
 */

#if CIF_VERSION == 2
#	define Cif_Open(A,B,C,D) \
    		Cif_Open_V2_1((A), (B), (C), (D), CIF_SUB_VERSION_2)
#	define Cif_Lines(A,B,C,D, E) \
    		Cif_Lines_V2_1((A), (B), (C), (D), (E), CIF_SUB_VERSION_2)
#	define Cif_Cifconv(A,B,C,D, E) \
    		Cif_Cifconv_V2_1((A), (B), (C), (D), (E), CIF_SUB_VERSION_2)
#endif

#if CIF_VERSION == 3
#	define Cif_Open(A,B,C,D) \
    		Cif_Open_V3_1((A), (B), (C), (D), CIF_SUB_VERSION_3)
#	define Cif_Lines(A,B,C,D, E) \
    		Cif_Lines_V3_1((A), (B), (C), (D), (E), CIF_SUB_VERSION_3)
#	define Cif_Cifconv(A,B,C,D, E) \
    		Cif_Cifconv_V3_1((A), (B), (C), (D), (E), CIF_SUB_VERSION_3)
#endif


#ifndef FIELD
/* The IBM RS6000 insists on unsigned ints */
#ifdef AIXV3
#define FIELD	unsigned int
#else
#define FIELD	unsigned int
#endif
#endif /* ndef FIELD */

/* --- record types -- */
#define CIF_CALLSITE		1	/* Call site */
#define CIF_CIFHDR		2	/* CIF header */
#define CIF_COMBLK		3	/* Common block info */
#define CIF_CONST		4	/* Fortran 77 constant info */

#if CIF_VERSION != 1
#define CIF_CDIR		5	/* simple CDIR$ */
#endif /* CIF_VERSION != 1 */

#define CIF_ENTRY		6	/* Fortran 77 entry info */
#define CIF_FILE		7	/* File name */
#define CIF_LOOP		8	/* Loop Information */
#define CIF_INCLUDE		9	/* Include structure */
#define CIF_LABEL		10	/* Label info */
#define CIF_MESSAGE		11	/* Fortran message */
#define CIF_NAMELIST		12	/* Namelist */
#define CIF_OBJECT		13	/* Fortran 77 object info */
#define CIF_SRCFILE		14	/* Base level source file info */
#define CIF_SUMMARY		15	/* Summary */

#if CIF_VERSION != 1
#define CIF_CDIR_DOSHARED      	16	/* CDIR$ DOSHARED */
#endif /* CIF_VERSION != 1 */

#define CIF_UNIT		17	/* Beginning of module */
#define CIF_ENDUNIT		18	/* End of module */
#define CIF_USAGE		19	/* Object usage */
#define CIF_ND_MSG		20	/* Non-default message */
#define CIF_EDOPTS		21	/* Enable/disable compiler options */
#define CIF_MACH_CHAR		22	/* Machine characteristics */
#define CIF_MISC_OPTS		23	/* Miscellaneous compiler options */
#define CIF_OPT_OPTS		24	/* Optimation compiler options */
#define CIF_STMT_TYPE		25	/* Statement type */

#if CIF_VERSION != 1
#define CIF_GEOMETRY		26	/* geometry info */
#define CIF_CONTINUATION	27	/* continuation line */
#endif /* CIF_VERSION != 1 */

#if CIF_VERSION != 1			/* Additions for F90 */
#define CIF_F90_CALLSITE	28	/* F90 Call site */
#define CIF_F90_COMBLK		29	/* F90 Common block info */
#define CIF_F90_CONST		30	/* F90 Constant info */
#define CIF_F90_ENTRY		31	/* F90 Entry info */
#define CIF_F90_LOOP		32	/* F90 Loop info */
#define CIF_F90_DERIVED_TYPE	33	/* F90 derived type */
#define CIF_F90_LABEL		34	/* F90 Label info */
#define CIF_F90_NAMELIST	35	/* F90 Namelist */
#define CIF_F90_OBJECT		36	/* F90 Object info */
#define CIF_F90_MISC_OPTS	37	/* F90 Miscellaneous compiler options */
#define CIF_F90_OPT_OPTS	38	/* F90 Optimation compiler options */
#define CIF_F90_BEGIN_SCOPE	39	/* F90 Begin scope */
#define CIF_F90_END_SCOPE	40	/* F90 End Scope */
#define CIF_F90_SCOPE_INFO	41	/* F90 Scope info */
#define CIF_F90_USE_MODULE	42	/* F90 Use module */
#define CIF_F90_RENAME		43	/* F90 Rename */
#define CIF_F90_INT_BLOCK	44	/* F90 Interface block */
#define CIF_F90_VECTORIZATION	45	/* F90 Vectorization info */

#define CIF_BE_NODE		46	/* MPP Backend node */

#if CIF_VERSION >= 2
#define CIF_BE_FID		50	/* MPP Backend fid for V2 */
#endif

#define CIF_TRANSFORM		47	/* Transformation record */

#endif /* CIF_VERSION != 1 */

#define CIF_FILEDIR		48 	/* File directory */
#define CIF_UNITDIR		49 	/* Unit directory */
#define CIF_C_TAG		51	/* C Tag information */
#define CIF_C_OPTS		52	/* C compiler options */
#define CIF_C_MESSAGE		53	/* C messages */
#define CIF_C_CONST		54	/* C constants */
#define CIF_C_ENTRY		55	/* C entry sites */
#define CIF_C_OBJECT		56	/* C objects */
#if CIF_VERSION == 1
#define CIF_MAXRECORD		57	/* record type array size */
#else
#define CIF_C_LINT_DIRECTIVE    57	/* C lint directive */
#define CIF_C_MACRO_DEF      	58	/* C MACRO info */
#define CIF_C_MACRO_UNDEF      	59	/* C MACRO UNDEF */
#define CIF_C_MACRO_USAGE      	60	/* C MACRO usage */
#define CIF_C_ENTRY_END		61	/* C entry end */

#if CIF_VERSION == 3

#define CIF_ORIG_CMD		70	/* Original command line */

#define CIF_CC_TYPE		80	/* CC type */
#define CIF_CC_ENTRY		81	/* CC entry point */
#define CIF_CC_OBJ		82	/* CC object info */
#define CIF_CC_SUBTYPE		83	/* CC subtype */
#define CIF_CC_ENUM		84	/* CC enum */
#define CIF_CC_EXPR		85	/* CC expression */

#define CIF_SRC_POS		86	/* Source position */

#define CIF_MAXRECORD		100	/* record type array size */
#define CIF_MAXRECORD_1		57	/* record type array size for version 1 */
#define CIF_MAXRECORD_2		62	/* record type array size for version 1 */

#else

#define CIF_MAXRECORD		62	/* record type array size */
#define CIF_MAXRECORD_1		57	/* record type array size for version 1 */

#endif /* CIF_VERSION == 3 */

#endif /* CIF_VERSION == 1 */

/* --- C basic type --- */
#define CIF_BTC_TYPELESS	0x00	/* typeless */
#define CIF_BTC_SBITFLD		0x01	/* signed bitfield */
#define CIF_BTC_UBITFLD		0x02	/* unsigned bitfield */
#define CIF_BTC_SCHAR		0x03	/* signed char */
#define CIF_BTC_UCHAR		0x04	/* unsigned char */
#define CIF_BTC_SSHORT		0x05	/* signed short */
#define CIF_BTC_USHORT		0x06	/* unsigned short */
#define CIF_BTC_SINT		0x07	/* signed int */
#define CIF_BTC_UINT		0x08	/* unsigned int */
#define CIF_BTC_SLONG		0x09	/* signed long */
#define CIF_BTC_ULONG		0x0a	/* unsigned long */
#define CIF_BTC_FLOAT		0x0b	/* float */
#define CIF_BTC_DOUBLE		0x0c	/* double */
#define CIF_BTC_LDOUBLE		0x0d	/* long double */
#define CIF_BTC_FCOMPLX		0x0e	/* float complex */
#define CIF_BTC_DCOMPLX		0x0f	/* double complex */
#define CIF_BTC_LDCOMPLX	0x10	/* long double complex */
#define CIF_BTC_VOID		0x11	/* void */
#define CIF_BTC_STRUCT		0x12	/* struct */
#define CIF_BTC_UNION		0x13	/* union */
#define CIF_BTC_ENUM		0x14	/* enum */
#define CIF_BTC_UNKNOWN		0xff	/* unknown */
#define CIF_BTC_MAX		32	/* basic type array size */

/* --- C++ basic types --- */
#define CIF_CCT_INT		 1	/* int */
#define CIF_CCT_FLOAT		 2	/* float */
#define CIF_CCT_COMPLEX		 3	/* complex */
#define CIF_CCT_VOID		 4	/* void */
#define CIF_CCT_CLASS		 5	/* class */
#define CIF_CCT_STRUCT		 6	/* struct */
#define CIF_CCT_UNION		 7	/* union */
#define CIF_CCT_TYPEDEF		 8	/* typedef */
#define CIF_CCT_QUALIFIED	 9	/* qualified */
#define CIF_CCT_ENUM		10	/* enum */
#define CIF_CCT_FUNCTION	11	/* function */
#define CIF_CCT_POINTER		12	/* pointer */
#define CIF_CCT_ARRAY		13	/* array */
#define CIF_CCT_PTRMEM		14	/* pointer to member */
#define CIF_CCT_TEMPAR		15	/* template parameter */


/* --- Fortran common block storage types --- */
#define CIF_CB_REG		0	/* regular memory */
#define CIF_CB_TASK		1	/* task common memory */
#define CIF_CB_LOCAL		2	/* Cray-2 local memory */
#define CIF_CB_AUX		3	/* auxiliary memory */
#define CIF_CB_THREAD_PRIVATE	4	/* cb storage type array size */
#define CIF_CB_MAX		5	/* cb storage type array size */

/* --- Fortran dimension type values --- */
#define CIF_DM_CONSTANT		0	/* constant value */
#define CIF_DM_EXPR		1	/* expression or argument */
#define CIF_DM_ASSUMED		2	/* assumed size */
#define CIF_DM_MAX		3	/* dimension value array size */

/* --- Fortran 77 data types --- */
#define CIF_DT_UNKNOWN		0	/* unknown type */
#define CIF_DT_TYPELESS		1	/* typeless */
#define CIF_DT_INT32		2	/* integer - 32 bits */
#define CIF_DT_INT46		3	/* integer - 46 bits */
#define CIF_DT_INT64		4	/* integer - 64 bits */
#define CIF_DT_REAL		5	/* normal precision floating point */
#define CIF_DT_DOUBLE		6	/* double precision floatin point */
#define CIF_DT_FCHAR		7	/* Fortran 77 character */
#define CIF_DT_COMPLEX		8	/* complex floating point */
#define CIF_DT_DBLE_CMPLX	9	/* double precision complex f.p. */
#define CIF_DT_FPTR		10	/* Fortran 77 pointer */
#define CIF_DT_LOGICAL		11	/* logical */
#define CIF_DT_FCPTR		12	/* Fortran 77 character pointer */
#define CIF_DT_DERIVED		13	/* Fortran 77 derived type */
#define CIF_DT_MAX		14	/* data type array size */


#if CIF_VERSION != 1

/* --- F90 data types --- */

/*
 * F90 data types can not easily be mapped onto F77 data types
 * as most of the basic f77 types have multiple counterparts
 * in F90. There is no direct correlation, ie it is machine
 * specific, as to whether, eg, REAL_8 or REAL_4 (or REAL_16)
 * would represent the same type as F77's REAL. Therefore with
 * the following three exceptions, f90 data types have unique
 * numbers.
 */

#define CIF_F90_DT_UNKNOWN		0	/* unknown type */
#define CIF_F90_DT_FPTR			10 	/* Cray pointer */
#define CIF_F90_DT_FCPTR		12	/* Cray character pointer */

#if CIF_VERSION == 2
#define CIF_F90_DT_SHORT_CHAR_CONST	21	/* short character constant */
#define CIF_F90_DT_SHORT_TYPELESS	22	/* short typeless */
#define CIF_F90_DT_LONG_TYPELESS	23	/* long typeless */
#endif

#define CIF_F90_DT_TYPELESS		22	/* typeless */

#define CIF_F90_DT_INTEGER_1		24	/* integer kind type parameter 1 */
#define CIF_F90_DT_INTEGER_2		25	/* integer kind type parameter 2 */
#define CIF_F90_DT_INTEGER_4		26	/* integer kind type parameter 4 */
#define CIF_F90_DT_INTEGER_6		27	/* integer kind type parameter 6 */
#define CIF_F90_DT_INTEGER_8		28	/* integer kind type parameter 8 */
#define CIF_F90_DT_REAL_4		29	/* real kind type parameter 4 */
#define CIF_F90_DT_REAL_8		30	/* real kind type parameter 8 */
#define CIF_F90_DT_REAL_16		31	/* real kind type parameter 16 */
#define CIF_F90_DT_COMPLEX_4		32	/* complex kind type parameter 4 */
#define CIF_F90_DT_COMPLEX_8		33	/* complex kind type parameter 8 */
#define CIF_F90_DT_COMPLEX_16		34	/* complex kind type parameter 16 */
#define CIF_F90_DT_LOGICAL_1		36	/* logical kind type 1 */
#define CIF_F90_DT_LOGICAL_2		37	/* logical kind type 2 */
#define CIF_F90_DT_LOGICAL_4		38	/* logical kind type 4 */
#define CIF_F90_DT_LOGICAL_8		39	/* logical kind type 8 */
#define CIF_F90_DT_CHARACTER_1		40	/* character kind type 1 */
#define CIF_F90_DT_CHARACTER_2		41	/* character kind type 2 */
#define CIF_F90_DT_CHARACTER_4		42	/* character kind type 4 */
#define CIF_F90_DT_MAX			43	/* f90 data type array size */

#endif /* CIF_VERSION != 1 */



/* --- Fortran 77 enable/disable option masks --- */
#define CIF_EDF_OPTa		0x00000001
#define CIF_EDF_OPTc		0x00000002
#define CIF_EDF_OPTd		0x00000004
#define CIF_EDF_OPTf		0x00000008
#define CIF_EDF_OPTg		0x00000010
#define CIF_EDF_OPTh		0x00000020
#define CIF_EDF_OPTi		0x00000040
#define CIF_EDF_OPTj		0x00000080
#define CIF_EDF_OPTm		0x00000100
#define CIF_EDF_OPTn		0x00000200
#define CIF_EDF_OPTo		0x00000400
#define CIF_EDF_OPTp		0x00000800
#define CIF_EDF_OPTq		0x00001000
#define CIF_EDF_OPTr		0x00002000
#define CIF_EDF_OPTs		0x00004000
#define CIF_EDF_OPTu		0x00008000
#define CIF_EDF_OPTv		0x00010000
#define CIF_EDF_OPTw		0x00020000
#define CIF_EDF_OPTx		0x00040000
#define CIF_EDF_OPTz		0x00080000
#define CIF_EDF_OPTB		0x00100000
#define CIF_EDF_OPTP		0x00200000
#define CIF_EDF_OPTS		0x00400000

#if CIF_VERSION != 1
#define CIF_EDF_OPTt		0x00800000  /* reorganize transformations */
#endif /* CIF_VERSION != 1 */


#if CIF_VERSION != 1

/* --- F90 enable/disable option masks --- */
#define CIF_F90_EDF_OPTa        	0x00000001
#define CIF_F90_EDF_OPTd		0x00000002
#define CIF_F90_EDF_OPTf		0x00000004
#define CIF_F90_EDF_OPTi		0x00000008
#define CIF_F90_EDF_OPTj		0x00000010
#define CIF_F90_EDF_OPTn		0x00000020
#define CIF_F90_EDF_OPTp		0x00000040
#define CIF_F90_EDF_OPTq		0x00000080
#define CIF_F90_EDF_OPTr		0x00000100
#define CIF_F90_EDF_OPTt		0x00020000
#define CIF_F90_EDF_OPTu		0x00000200
#define CIF_F90_EDF_OPTv		0x00000400
#define CIF_F90_EDF_OPTz		0x00000800
#define CIF_F90_EDF_OPTB		0x00001000
#define CIF_F90_EDF_OPTP		0x00002000
#define CIF_F90_EDF_OPTS		0x00004000
#define CIF_F90_EDF_OPTA		0x00008000
#define CIF_F90_EDF_OPTX		0x00010000


/* --- Distribution codes --- */
#define CIF_DN_NA		0	/* not applicable */
#define CIF_DN_PE_PRIVATE	1	/* PE_PRIVATE */
#define CIF_DN_SHARED_CAN	2	/* shared canonical */
#define CIF_DN_SHARED_DIM       3	/* shared dimensional */
#define CIF_DN_UNKNOWN		4	/* unknown */
#define CIF_DN_UNKNOWN_SHARED  	5	/* unknown shared */

/* --- cdir types --- */
#define CIF_CD_MASTER		0
#define CIF_CD_END_MASTER	1
#define CIF_CD_BARRIER		2
#define CIF_CD_NO_BARRIER	3
#define CIF_CD_CRITICAL		4
#define CIF_CD_END_CRITICAL	5
#define CIF_CD_SHARED_IO	6
#define CIF_CD_ATOMIC_UPDATE   	7
#define CIF_CD_LIST		8
#define CIF_CD_NOLIST		9
#define CIF_CD_EJECT		10

/* --- cdir_doshared types --- */
#define CIF_DO_ALIGNED		0
#define CIF_DO_UNIFORM		1
#define CIF_DO_CHUNKSIZE	2
#define CIF_DO_NUMCHUNKS	3
#define CIF_DO_GUIDED		4

#endif /* CIF_VERSION != 1 */


/* --- C symbol entity types --- */
#define CIF_ENC_OBJECT		0	/* object */
#define CIF_ENC_FORMARG		2	/* formal argument */
#define CIF_ENC_TYPEDEF		3	/* typedef */
#define CIF_ENC_ENUMMEM		4	/* enum member */

#if CIF_VERSION == 1

#define CIF_ENC_TAG		10	/* tag */
#define CIF_ENC_MEMBER		11	/* structure/union member */
#define CIF_ENC_STRLIT		12	/* string literal */
#define CIF_ENC_MAX		13	/* entity type array size */

#else

#define CIF_ENC_TAG		9	/* tag */
#define CIF_ENC_MEMBER		10	/* structure/union member */
#define CIF_ENC_STRLIT		11	/* string literal */
#define CIF_ENC_MAX		12	/* entity type array size */

#endif

/* --- Fortran 77 entry types --- */
#define CIF_ET_ALT_ENTRY	1	/* alternate entry point */
#define CIF_ET_BLOCKDATA	2	/* block data */
#define CIF_ET_FUNCTION		3	/* function */
#define CIF_ET_PROGRAM		4	/* main program */
#define CIF_ET_SUBROUTINE	5	/* subroutine */
#define CIF_ET_UNKNOWN		6	/* unknown */
#define CIF_ET_MAX		7	/* entry type array size */

#if CIF_VERSION != 1
/* --- F90 entry types --- */
#define CIF_F90_ET_ERROR	0	/* error status, should not occur */
#define CIF_F90_ET_ALT_ENTRY	1	/* alternate entry point */
#define CIF_F90_ET_BLOCKDATA	2	/* block data */
#define CIF_F90_ET_FUNCTION	3	/* function */
#define CIF_F90_ET_PROGRAM     	4	/* main program */
#define CIF_F90_ET_SUBROUTINE	5	/* subroutine */
#define CIF_F90_ET_UNKNOWN     	6	/* unknown */
#define CIF_F90_ET_MODULE     	7	/* module */
#define CIF_F90_ET_STMT     	8	/* statement function */
#define CIF_F90_ET_MAX		9	/* entry type array size */


/* --- F90 sub-entry codes --- */
#define CIF_F90_PT_UNKNOWN	0	/* unknown */
#define CIF_F90_PT_EXTERNAL	1	/* external */
#define CIF_F90_PT_INTRINSIC	2	/* intrinsic */
#define CIF_F90_PT_DUMMY	3	/* dummy */
#define CIF_F90_PT_INTERNAL	4	/* internal */
#define CIF_F90_PT_IMPORTED	5	/* imported */
#define CIF_F90_PT_MODULE	6	/* module */
#define CIF_F90_PT_MAX		7	/* f90 sub-entry type array size */


/* --- Fortran 90 array types --- */
#define CIF_AT_EXPLICIT		1	/* explicit array shape */
#define CIF_AT_ASSUMED_SIZE    	2	/* assumed size */
#define CIF_AT_DEFERRED		3	/* deferred array shape */
#define CIF_AT_ASSUMED		4	/* assumed array shape */

#endif /* CIF_VERSION != 1 */


/* --- file format indicators --- */
#define CIF_FORM_RANDOM		0	/* random record order format file */
#define CIF_FORM_SORTED		1	/* sort record order format file */

/* --- binary file format indicators --- */
#define CIF_FORM_CIFCONV	0	/* cif has been cifconv'd */
#define CIF_FORM_LINES		1	/* cif has been lines'd */
#define CIF_FORM_USER		2	/* cif has been written by user code */


/* --- contiguous id value indicators --- */
#define CIF_ID_NONCONTIG	0	/* id values aren't contiguous */
#define CIF_ID_CONTIGUOUS	1	/* id values are contiguous */

/* --- label types --- */
#define CIF_LB_FORMAT		1	/* format label */
#define CIF_LB_STMT		2	/* statement label */
#define CIF_LB_UNKNOWN		3	/* unknown */
#define CIF_LB_CONSTRUCT	4	/* F90 construct name */
#define CIF_LB_MAX		5	/* label type array size */

/* --- language types --- */
#define CIF_LG_F77		0	/* Fortran 77 */
#define CIF_LG_F90		1	/* Fortran 90 */
#define CIF_LG_C		2	/* C */

#if CIF_VERSION < 3
#define CIF_LG_MAX		3	/* label type array size */

#else

#define CIF_LG_CC		3	/* C++ */
#define CIF_LG_MAX		4	/* label type array size */
#endif

/* --- loop types --- */
#define CIF_LP_DO		0	/* do loop */
#define CIF_LP_DOWHILE		1	/* do_while loop */
#define CIF_LP_WHILE		2	/* while loop */
#define CIF_LP_FOR		3	/* for loop */
#define CIF_LP_DO_INFINITE	4	/* infinit do loop : F90 only */
#define CIF_LP_MAX		5	/* loop array size */

/* --- memory mode types --- */
#define CIF_MEM_DEFAULT		0	/* default (unselected) mode */
#define CIF_MEM_INDIV		1	/* individually malloc'd structures */
#define CIF_MEM_FIXED		2	/* fixed reused buffer */
#define CIF_MEM_MANAGED		3	/* space alloc'd from managed area */
#define CIF_MEM_MAX		4	/* managed memory array size */

#define CIF_MEM_KEEP		0	/* retain memory for cif buffers */
#define CIF_MEM_FREE		1	/* return cif buffer mem to system */


/* F90 file format types */
#define CIF_F90_FORM_FIXED	0	/* Fixed format source code */
#define CIF_F90_FORM_FREE	1	/* Free format source code */

/* --- machine characteristic values mask --- */
#define CIF_MC_VPOP		0x0001	/* CRAY X-MP/Y-MP */
#define CIF_MC_EMA		0x0002
#define CIF_MC_CIGS		0x0004
#define CIF_MC_PCF		0x0008
#define CIF_MC_READVL		0x0010
#define CIF_MC_VRECUR		0x0020
#define CIF_MC_NOVRECUR		0x0040
#define CIF_MC_AVL		0x0080
#define CIF_MC_HPF		0x0100
#define CIF_MC_BDM		0x0200
#define CIF_MC_SREG		0x0400
#define CIF_MC_CLUSTER		0x0800
#define CIF_MC_COR		0x1000
#define CIF_MC_ADDR32		0x2000
#define CIF_MC_BMM		0x4000
#define CIF_MC_XEA		0x8000

#define CIF_MC_AVPOP		0x10000
#define CIF_MC_FULLSECT		0x20000
#define CIF_MC_IEEE		0x40000
#define CIF_MC_CMRREQ		0x80000
#define CIF_MC_CACHE		0x100000

#if CIF_VERSION == 1

#define CIF_MC_TAILGT		0x0001	/* CRAY-2 */
#define CIF_MC_SHAREDREG	0x0002
#define CIF_MC_MEMQUIET		0x0004

#else

#define CIF_MC_TAILGT_1		0x0001 /* old tailgate value ie from v1 */

#define CIF_MC_FAR		0x0001	/* CRAY-2 */
#define CIF_MC_TAILGT		0x0002
#define CIF_MC_CMR		0x0004


/* Mask to remove bits not provided in v1, but are in v2 */
#define CIF_MC_MASK (~(CIF_MC_PCF & \
		       CIF_MC_NOVRECUR & \
		       CIF_MC_HPF & \
		       CIF_MC_SREG & \
		       CIF_MC_CLUSTER & \
		       CIF_MC_COR & \
		       CIF_MC_ADDR32 & \
		       CIF_MC_BMM))

#endif /* CIF_VERSION != 1 */

/* --- Fortran miscellaneous options values --- */
#define CIF_MISCF_STACK		0	/* stack allocation */
#define CIF_MISCF_STATIC	1	/* static allocation */
#define CIF_MISCF_HEAP		2	/* Heap allocation */

#define CIF_MISCF_INT64		0	/* integer length = 64 bits */
#define CIF_MISCF_INT46		1	/* integer length = 46 bits */

#define CIF_MISCF_UNKNOWN	0	/* unknown addressing mode */
#define CIF_MISCF_FAST		1	/* fast addressing mode */
#define CIF_MISCF_FULL		2	/* full addressing mode */
#define CIF_MISCF_SREG		3	/* S register addressing mode */

/* --- C message severity codes --- */
#define CIF_MS_COMMENT		 0	/* comment */
#define CIF_MS_NOTE		 1	/* note */
#define CIF_MS_CAUTION		 2	/* caution */
#define CIF_MS_WARNING		 3	/* warning */
#define CIF_MS_ERROR		 4	/* error */
#define CIF_MS_INTERNAL	 	 5	/* internal */
#define CIF_MS_VECTOR		 6	/* vector */
#define CIF_MS_SCALAR		 7	/* scalar */
#define CIF_MS_TABLE		 8	/* table */
#define CIF_MS_ANSI		 9	/* ansi */
#define CIF_MS_LOGFILE		10	/* logfile */
#define CIF_MS_INLINE		11	/* inline */
#define CIF_MS_INFO		12	/* info */
#define CIF_MS_TASKING		13	/* tasking */
#define CIF_MS_LIMIT		14	/* limit */
#define CIF_MS_LOGERROR		15	/* logfile error */
#define CIF_MS_LOGSUM		16	/* logfile summary */
#define CIF_MS_F77_ANSI		17     	/* f77 ansi */
#define CIF_MS_OPTIMIZATION     18	/* General optimization */
#define CIF_MS_STREAM       	19	/* Multi-streaming */
#define CIF_MS_UNKNOWN       	20	/* unknown */
#define CIF_MS_MAX		21	/* C message severity array size */

#if CIF_VERSION != 1
/* --- C message message codes --- */
#define CIF_MS_CODE_NORMAL      0       /* normal processing */
#define CIF_MS_CODE_ARGSUSED    1       /* suppressed via ARGSUSED directive */
#define CIF_MS_CODE_EMPTY       2       /* suppressed via EMPTY directive */
#define CIF_MS_CODE_FALLTHROUGH 3       /* suppressed via FALLTHROUGH directive */
#define CIF_MS_CODE_NOTREACHED  4       /* suppressed via NOTREACHED directive */
#endif /* CIF_VERSION != 1 */


/* --- Fortran message severity codes --- */
#define CIF_F_MS_COMMENT       	 0	/* comment */
#define CIF_F_MS_NOTE		 1	/* note */
#define CIF_F_MS_CAUTION       	 2	/* caution */
#define CIF_F_MS_WARNING       	 3	/* warning */
#define CIF_F_MS_ERROR		 4	/* error */
#define CIF_F_MS_INTERNAL      	 5	/* internal */
#define CIF_F_MS_VECTOR		 6	/* vector */
#define CIF_F_MS_SCALAR      	 7	/* scalar */
#define CIF_F_MS_OPT_INFO      	 7	/* optimisation information=old name */
#define CIF_F_MS_TABLE		 8	/* table */
#define CIF_F_MS_ANSI		 9	/* ansi */
#define CIF_F_MS_LOGFILE       	10	/* logfile */
#define CIF_F_MS_INLINE		11	/* inline */
#define CIF_F_MS_INFO		12	/* info */
#define CIF_F_MS_TASKING	13	/* tasking */
#define CIF_F_MS_LIMIT		14	/* limit */
#define CIF_F_MS_LOGERROR	15     	/* logfile error */
#define CIF_F_MS_LOGSUM		16     	/* logfile summary */
#define CIF_F_MS_F77_ANSI	17     	/* f77 ansi */
#define CIF_F_MS_OPTIMIZATION   18	/* General optimization */
#define CIF_F_MS_STREAM       	19	/* Multi-streaming */
#define CIF_F_MS_UNKNOWN       	20	/* unknown */
#define CIF_F_MS_MAX		21	/* Fortran message severity array size */

/* --- C object usage codes --- */
#define CIF_OBC_DEFINED		0x001	/* defined */
#define CIF_OBC_DECLARED	0x002	/* declared */
#define CIF_OBC_REFERENCED	0x004	/* referenced */
#define CIF_OBC_MODIFIED	0x008	/* modified */
#define CIF_OBC_ADDRESS		0x010	/* address taken */
#define CIF_OBC_ARGLIST		0x020	/* appeared in function arg list */
#define CIF_OBC_USEDDECL	0x040	/* used in declaration */
#define CIF_OBC_USEDCAST	0x080	/* used in cast */
#define CIF_OBC_USEDFUNC	0x100	/* used in function call */
#define CIF_OBC_MACROEXP	0x200	/* a product of a macro expansion */
#define CIF_OBC_MAX		9	/* object usage code array size */

/* --- Fortran 77 object usage codes --- */
#define CIF_OB_DEFINED		0	/* defined or declared */
#define CIF_OB_USED		1	/* symbol is referenced */
#define CIF_OB_MODIFIED		2	/* symbol's value is modified */
#define CIF_OB_ARGLIST		3	/* named in argument list */
#define CIF_OB_ASSIGN		4	/* label assign reference */
#define CIF_OB_BRANCH		5	/* label branch reference */
#define CIF_OB_FORMAT		6	/* label format reference */
#define CIF_OB_DO		7	/* label do reference */
#define CIF_OB_TYPEDEF		8	/* type is defined */
#define CIF_OB_TYPEUSED		9	/* type appears in a declaration */
#define CIF_OB_MAX		10	/* object usage array size */

#if CIF_VERSION != 1

/* --- F90 object usage codes --- */
#define CIF_F90_OB_DEFINED     	0	/* defined or declared */
#define CIF_F90_OB_USED		1	/* symbol is referenced */
#define CIF_F90_OB_MODIFIED    	2	/* symbol's value is modified */
#define CIF_F90_OB_ARGLIST     	3	/* named in argument list */
#define CIF_F90_OB_ASSIGN      	4	/* label assign reference */
#define CIF_F90_OB_BRANCH      	5	/* label branch reference */
#define CIF_F90_OB_FORMAT      	6	/* label format reference */
#define CIF_F90_OB_DO		7	/* label do reference */
#define CIF_F90_OB_TYPEDEF     	8	/* type is defined */
#define CIF_F90_OB_TYPEUSED    	9	/* type appears in a declaration */
#define CIF_F90_OB_NAME		10	/* construct name */
#define CIF_F90_OB_DUMMY       	11	/* dummy argument */
#define CIF_F90_OB_OPER_ARG     12	/* actual argument to an operator
					 * function or assignment subroutine */
#define CIF_F90_OB_IND_MOD	13	/* Indirect reference to module, from
					 * nested use stmts */
#define CIF_F90_OB_MODIFIED_ASN 14	/* modified as an actual argument to
					 * an assignment subroutine, only
					 * set by cif_lines */
#define CIF_F90_OB_MAX		15	/* f90 object usage array size */


/* --- Fortran run-time checking flags --- */
#define CIF_RT_C		0x0001
#define CIF_RT_E		0x0002
#define CIF_RT_a		0x0004
#define CIF_RT_b		0x0008
#define CIF_RT_c		0x0010

/* --- Cif options specified --- */
#define CIF_CO_A		0x0001	/* option a */
#define CIF_CO_C		0x0002	/* option c */
#define CIF_CO_F		0x0004	/* option f */
#define CIF_CO_I		0x0008	/* option i */
#define CIF_CO_M		0x0010	/* option m */
#define CIF_CO_O		0x0020	/* option o */
#define CIF_CO_S		0x0040	/* option s */
#define CIF_CO_X		0x0080	/* option x */

#endif /* CIF_VERSION != 1 */

/* --- Fortran optimization option masks --- */
#define CIF_OOF_AGGRESS		0x00000001
#define CIF_OOF_BLOAD		0x00000002
#define CIF_OOF_INLINE		0x00000004
#define CIF_OOF_LOOPALIGN	0x00000008
#define CIF_OOF_RECURRENCE	0x00000010
#define CIF_OOF_RECURSIVE	0x00000020
#define CIF_OOF_SCALAR		0x00000040
#define CIF_OOF_VECTOR		0x00000080
#define CIF_OOF_VSEARCH		0x00000100
#define CIF_OOF_ZEROINC		0x00000200
#define CIF_OOF_KERNSCHED	0x00000400
#if CIF_VERSION != 1
#define CIF_OOF_TASK		0x00000800
#define CIF_OOF_GENERAL		0x00001000
#define CIF_OOF_OVERINDEX	0x00002000
#define CIF_OOF_PATTERN		0x00004000
#endif /* CIF_VERSION != 1 */


/* --- Fortran 77 symbol classes --- */
#define CIF_SC_COMMON		1	/* variable in common */
#define CIF_SC_EXPR		2	/* expression */
#define CIF_SC_UNKNOWN		3	/* unknown */
#define CIF_SC_VARIABLE		4	/* local variable */
#define CIF_SC_FIELD		5	/* field of aggregate */
#define CIF_SC_EQUIV		6	/* local variable equiv'd to common */
#define CIF_SC_MAX		7	/* symbol class array size */

#if CIF_VERSION != 1

/* --- F90 symbol classes --- */

/*
 * Note, 0 through 6 are identical to the f77 CIF_SC_?? defines
 * and may be used interchangably; 7 though 9 represent F90 extensions.
 */

#define CIF_F90_SC_ERROR	0	/* error */
#define CIF_F90_SC_COMMON      	1	/* variable in common */
#define CIF_F90_SC_EXPR		2	/* expression */
#define CIF_F90_SC_UNKNOWN     	3	/* unknown */
#define CIF_F90_SC_VARIABLE    	4	/* variable */
#define CIF_F90_SC_STRUCT      	5	/* structure component */
#define CIF_F90_SC_EQUIV       	6	/* local variable equiv'd to common */
#define CIF_F90_SC_MODULE      	7	/* module variable */
#define CIF_F90_SC_NAMED_CONST 	8	/* named constant */
#define CIF_F90_SC_FUNC_RESULT 	9	/* function result */
#define CIF_F90_SC_MX 		10	/* f90 symbol class array size */

#endif /* CIF_VERSION != 1 */

/* --- C symbol classes --- */
#define CIF_SCC_EXTERN		0	/* extern */
#define CIF_SCC_STATIC		1	/* static */
#define CIF_SCC_AUTO		2	/* auto */
#define CIF_SCC_REGISTER	3	/* register */
#define CIF_SCC_FORTRAN		4	/* fortran */
#define CIF_SCC_STRMEM		6	/* structure member */
#define CIF_SCC_UNMEM		7	/* union member */
#define CIF_SCC_ENUMMEM		8	/* enum member */
#define CIF_SCC_STRBITFLD	12	/* structure bit field */
#define CIF_SCC_UNBITFLD	13	/* union bit field */
#define CIF_SCC_USRLAB		14	/* user label */
#define CIF_SCC_GLBREG		16	/* global B register */
#define CIF_SCC_GLTREG		17	/* global T register */
#define CIF_SCC_EXTLM		18	/* external local memory */
#define CIF_SCC_MAX		19	/* storage class array size */


/* --- Fortran 77 storage type --- */
#define CIF_ST_AUXILIARY	1	/* assigned to auxiliary memory */
#define CIF_ST_BASED		2	/* based */
#define CIF_ST_DUMARG		3	/* formal argument */
#define CIF_ST_POINTEE		4	/* accessed via pointer */
#define CIF_ST_STACK		5	/* assigned to the stack */
#define CIF_ST_STATIC		6	/* assigned to regular memory */
#define CIF_ST_UNKNOWN		7	/* storage class unknown */
#if CIF_VERSION == 1
#define CIF_ST_MAX		8	/* storage class array size */
#else
#define CIF_ST_BSS		6	/* assigned to static BSS */
#define CIF_ST_DATA		8	/* assigned to static DATA */
#define CIF_ST_MAX		9	/* storage class array size */
#endif

#if CIF_VERSION != 1

/* --- F90 storage types --- */
#define CIF_F90_ST_ERROR	0	/* error */
#define CIF_F90_ST_AUXILIARY	1	/* assigned to auxiliary memory */
#define CIF_F90_ST_BASED	2	/* based */
#define CIF_F90_ST_DUMMY	3	/* dummy argument */
#define CIF_F90_ST_POINTEE	4	/* Cray pointee */
#define CIF_F90_ST_STACK	5	/* stack (aka "automatic") */
#define CIF_F90_ST_STATIC	6	/* static (aka @BSS) */
#define CIF_F90_ST_BSS		6	/* @BSS */
#define CIF_F90_ST_NO_STORAGE	7	/* no storage */
#define CIF_F90_ST_DATA		8	/* DATA, not used by F90 */
#define CIF_F90_ST_COMMON	9	/* common block */
#define CIF_F90_ST_MAX		10	/* f90 storage types array size */

/* --- C++ storage types --- */
#define CIF_CC_ST_ERROR         0	/* error */
#define CIF_CC_ST_STATIC        1	/* static */
#define CIF_CC_ST_AUTO          2	/* auto */
#define CIF_CC_ST_REGISTER      3	/* register */
#define CIF_CC_ST_GLB_B_REG     4	/* global B register */
#define CIF_CC_ST_GLB_T_REG     5	/* global T register */
#define CIF_CC_ST_TSK_COMMON    6	/* taskcommon */
#define CIF_CC_ST_SOFT          7	/* soft (pragma soft) */
#define CIF_CC_ST_TSK_PRIVATE   8	/* taskprivate */

/* --- C++ symbol class --- */
#define CIF_CC_SC_ERROR         0	/* error */
#define CIF_CC_SC_VARIABLE      1	/* variable */
#define CIF_CC_SC_FORMAL_PARAM  2	/* formal parameter */
#define CIF_CC_SC_MEMBER_VAR    3	/* member variable */



#endif /* CIF_VERSION != 1 */

/* --- C type modifiers --- */
#define CIF_TMC_UNUSED		0x0	/* unused */
#define CIF_TMC_ARRAY		0x1	/* array of */
#define CIF_TMC_FUNCNOPR	0x2	/* function returning, no prototype */
#define CIF_TMC_FUNCPRO		0x3	/* function returning, prototype */
#define CIF_TMC_PTR		0x8	/* pointer to */
#define CIF_TMC_CONPTR		0x9	/* const pointer to */
#define CIF_TMC_VOLPTR		0xa	/* volatile pointer to */
#define CIF_TMC_CNVLPTR		0xb	/* const volatile pointer to */
#define CIF_TMC_RESPTR		0xc	/* restrict pointer to */
#define CIF_TMC_RSCNPTR		0xd	/* restrict const pointer to */
#define CIF_TMC_RSVLPTR		0xe	/* restrict volatile pointer to */
#define CIF_TMC_RSCNVLPTR	0xf	/* restrict const volatile ptr to */
#define CIF_TMC_MAX		16	/* type modifiers array size */


#if CIF_VERSION != 1
/* --- C undimensioned (variable length) array indicator --- */
#define CIF_TMC_UNDIMENSIONED	0
#endif /* CIF_VERSION != 1 */


/* --- Fortran 77 statement types --- */
#define CIF_TP_ALLOCATABLE	0
#define CIF_TP_ALLOCATE		1
#define CIF_TP_ASSIGN		2
#define CIF_TP_ASSIGNMENT	3
#define CIF_TP_BACKSPACE	4
#define CIF_TP_BDATA		5
#define CIF_TP_BUFFER		6
#define CIF_TP_CALL		7
#define CIF_TP_CASE		8
#define CIF_TP_CLOSE		9
#define CIF_TP_COMMON		10
#define CIF_TP_CONTAINS		11
#define CIF_TP_CONTINUE		12
#define CIF_TP_CYCLE		13
#define CIF_TP_DATA		14
#define CIF_TP_DEALLOCATE	15
#define CIF_TP_DECODE		16
#define CIF_TP_DEFAULT		17
#define CIF_TP_DERIVED_TYPE	18
#define CIF_TP_DIMENSION	19
#define CIF_TP_DIRECTIVE	20
#define CIF_TP_LABELED_DO	21
#define CIF_TP_UNLABELED_DO	22
#define CIF_TP_ELSE		23
#define CIF_TP_ELSEIF		24
#define CIF_TP_ELSEWHERE	25
#define CIF_TP_ENCODE		26
#define CIF_TP_END		27
#define CIF_TP_ENDFILE		28
#define CIF_TP_ENTRY		29
#define CIF_TP_EQUIVALENCE	30
#define CIF_TP_EXIT		31
#define CIF_TP_EXTERNAL		32
#define CIF_TP_FORMAT		33
#define CIF_TP_FUNCTION		34
#define CIF_TP_GOTO		35
#define CIF_TP_IF		36
#define CIF_TP_IFTHEN		37
#define CIF_TP_IMPLICIT		38
#define CIF_TP_IMPNONE		39
#define CIF_TP_INQUIRE		40
#define CIF_TP_INTENT		41
#define CIF_TP_INTERFACE	42
#define CIF_TP_INTRINSIC	43
#define CIF_TP_MODULE		44
#define CIF_TP_MODULE_PROC	45
#define CIF_TP_NAMELIST		46
#define CIF_TP_NULLIFY		47
#define CIF_TP_OPEN		48
#define CIF_TP_OPTIONAL		49
#define CIF_TP_PARAMETER	50
#define CIF_TP_PAUSE		51
#define CIF_TP_POINTER		52
#define CIF_TP_PRINT		53
#define CIF_TP_PRIVATE		54
#define CIF_TP_PROGRAM		55
#define CIF_TP_PUBLIC		56
#define CIF_TP_PUNCH		57
#define CIF_TP_READ		58
#define CIF_TP_RETURN		59
#define CIF_TP_REWIND		60
#define CIF_TP_SAVE		61
#define CIF_TP_SELECT		62
#define CIF_TP_SEQUENCE		63
#define CIF_TP_STMTFUNC		64
#define CIF_TP_STOP		65
#define CIF_TP_SUBROUTINE	66
#define CIF_TP_TARGET		67
#define CIF_TP_TYPE_DECL	68
#define CIF_TP_USE		69
#define CIF_TP_WHERE		70
#define CIF_TP_WHERE_CONST	71
#define CIF_TP_WRITE		72
#define CIF_TP_BUFFER_IN	73
#define CIF_TP_BUFFER_OUT	74
#define CIF_TP_DOWHILE		75
#define CIF_TP_DO		76
#define CIF_TP_ENDDO		77
#define CIF_TP_ENDIF		78
#define CIF_TP_INCLUDE		79
#if CIF_VERSION == 1
#define CIF_TP_MAX		80
#else
#define CIF_TP_CDIR		80
#define CIF_TP_MAX		81
#endif /* CIF_VERSION == 1 */

#if CIF_VERSION != 1

/* --- C statement types --- */
#define CIF_CTP_EXPRESSION	0
#define CIF_CTP_COMPOUND	1
#define CIF_CTP_IF		2
#define CIF_CTP_ELSE		3
#define CIF_CTP_WHILE		4
#define CIF_CTP_DO		5
#define CIF_CTP_FOR		6
#define CIF_CTP_SWITCH		7
#define CIF_CTP_BREAK		8
#define CIF_CTP_GOTO		9
#define CIF_CTP_RETURN		10
#define CIF_CTP_CONTINUE	11
#define CIF_CTP_NULL		12
#define CIF_CTP_PRAGMA		13
#define CIF_CTP_ASSIGNMENT	14
#define CIF_CTP_END_COMPOUND	15
#define CIF_CTP_EXPR_END	16
#define CIF_CTP_DO_WHILE_END    17
#define CIF_CTP_RETURN_WITH_EXPR 18
#define CIF_CTP_CASE 		19
#define CIF_CTP_LABEL 		20
#define CIF_CTP_TRY 		21
#define CIF_CTP_ASM 		22
#define CIF_CTP_MAX		23

/* --- F90 statement types --- */

/*
 * Statement types 0-80 are indentical to f77, where applicable;
 * ie the gaps left below indicate that f90 will never produce a
 * statement of that number which has meaning to f77.
 * f90 specific values are stored 100-126.
 */

#define CIF_F90_TP_ALLOCATABLE	0
#define CIF_F90_TP_ALLOCATE    	1
#define CIF_F90_TP_ASSIGN      	2
#define CIF_F90_TP_ASSIGNMENT	3
#define CIF_F90_TP_BACKSPACE	4
#define CIF_F90_TP_BDATA       	5

#define CIF_F90_TP_CALL		7
#define CIF_F90_TP_CASE		8
#define CIF_F90_TP_CLOSE       	9
#define CIF_F90_TP_COMMON      	10
#define CIF_F90_TP_CONTAINS    	11
#define CIF_F90_TP_CONTINUE    	12
#define CIF_F90_TP_CYCLE       	13
#define CIF_F90_TP_DATA		14
#define CIF_F90_TP_DEALLOCATE	15
#define CIF_F90_TP_DECODE	16
#define CIF_F90_TP_CASE_DEFAULT	17
#define CIF_F90_TP_TYPE		18
#define CIF_F90_TP_DIMENSION	19
#define CIF_F90_TP_DIRECTIVE	20

#define CIF_F90_TP_ELSE		23
#define CIF_F90_TP_ELSEIF      	24
#define CIF_F90_TP_ELSEWHERE	25
#define CIF_F90_TP_ENCODE	26

#define CIF_F90_TP_ENDFILE	28
#define CIF_F90_TP_ENTRY       	29
#define CIF_F90_TP_EQUIVALENCE	30
#define CIF_F90_TP_EXIT		31
#define CIF_F90_TP_EXTERNAL    	32
#define CIF_F90_TP_FORMAT      	33
#define CIF_F90_TP_FUNCTION    	34

#define CIF_F90_TP_IF  		37
#define CIF_F90_TP_IMPLICIT    	38
#define CIF_F90_TP_IMPLICIT_NONE 39
#define CIF_F90_TP_INQUIRE     	40

#define CIF_F90_TP_INTRINSIC	43
#define CIF_F90_TP_MODULE	44
#define CIF_F90_TP_MODULE_PROC	45
#define CIF_F90_TP_NAMELIST    	46
#define CIF_F90_TP_NULLIFY     	47
#define CIF_F90_TP_OPEN		48
#define CIF_F90_TP_OPTIONAL    	49
#define CIF_F90_TP_PARAMETER	50
#define CIF_F90_TP_PAUSE       	51
#define CIF_F90_TP_POINTER     	52
#define CIF_F90_TP_PRINT       	53
#define CIF_F90_TP_PRIVATE     	54
#define CIF_F90_TP_PROGRAM     	55
#define CIF_F90_TP_PUBLIC      	56

#define CIF_F90_TP_READ		58
#define CIF_F90_TP_RETURN      	59
#define CIF_F90_TP_REWIND      	60
#define CIF_F90_TP_SAVE		61
#define CIF_F90_TP_SELECT_CASE  62
#define CIF_F90_TP_SEQUENCE    	63
#define CIF_F90_TP_STMTFUNC    	64
#define CIF_F90_TP_STOP		65
#define CIF_F90_TP_SUBROUTINE	66
#define CIF_F90_TP_TARGET      	67
#define CIF_F90_TP_TYPE_DECL	68
#define CIF_F90_TP_USE		69
#define CIF_F90_TP_WHERE       	70
#define CIF_F90_TP_WHERE_CONST	71
#define CIF_F90_TP_WRITE       	72
#define CIF_F90_TP_BUFFER_IN	73
#define CIF_F90_TP_BUFFER_OUT	74

#define CIF_F90_TP_END_DO      	77
#define CIF_F90_TP_END_IF 	78
#define CIF_F90_TP_INCLUDE    	79
#define CIF_F90_TP_CDIR		80

#define CIF_F90_TP_ARRAY_ASSIGNMENT 81  
#define CIF_F90_TP_POINTER_ASGN	82

#define CIF_F90_TP_LABELED_DO_INFINITE	 100
#define CIF_F90_TP_UNLABELED_DO_INFINITE 101
#define CIF_F90_TP_LABELED_DO_ITERATIVE  102
#define CIF_F90_TP_UNLABELED_DO_ITERATIVE 103
#define CIF_F90_TP_LABELED_DO_WHILE   104
#define CIF_F90_TP_UNLABELED_DO_WHILE 105
#define CIF_F90_TP_END_BDATA	106
#define CIF_F90_TP_END_FUNCTION 107
#define CIF_F90_TP_END_INTERFACE 108
#define CIF_F90_TP_END_MODULE	109
#define CIF_F90_TP_END_PROGRAM	110
#define CIF_F90_TP_END_SELECT	111
#define CIF_F90_TP_END_SUBROUTINE 112
#define CIF_F90_TP_END_TYPE	113
#define CIF_F90_TP_END_WHERE	114
#define CIF_F90_TP_GOTO		115
#define CIF_F90_TP_GOTO_ASSIGNED  116
#define CIF_F90_TP_GOTO_COMPUTED  117
#define CIF_F90_TP_IF_LOGICAL  	118
#define CIF_F90_TP_IF_ARITHMETIC  119
#define CIF_F90_TP_IF_IND_LOG  	120
#define CIF_F90_TP_IF_TWO_BRANCH_ARITHMETIC 121
#define CIF_F90_TP_INTENT_IN   	122
#define CIF_F90_TP_INTENT_OUT  	123
#define CIF_F90_TP_INTENT_INOUT 124
#define CIF_F90_TP_INTERFACE	125
#define CIF_F90_TP_INTERFACE_GENERIC 126 
#define CIF_F90_TP_INTERFACE_OPERATOR 127
#define CIF_F90_TP_INTERFACE_ASSIGNMENT 128
#define CIF_F90_TP_TASK_COMMON  129
#define CIF_F90_TP_AUTOMATIC    130
#define CIF_F90_TP_ELEMENTAL    131
#define CIF_F90_TP_PURE         132
#define CIF_F90_TP_FORALL	133
#define CIF_F90_TP_FORALL_CONSTRUCT	134
#define CIF_F90_TP_END_FORALL	135
#define CIF_F90_TP_MAX		136




/* ---- F90 scope types ---- */
#define CIF_SCP_MAIN	 	0	/* main program */
#define CIF_SCP_EXTERNAL	1	/* external subprogram (function or subroutine) */
#define CIF_SCP_BLOCK		2	/* block data subprogram */
#define CIF_SCP_MOD_SUB		3	/* module subprogram */
#define CIF_SCP_MODULE		4	/* module procedure */
#define CIF_SCP_INTERNAL	5	/* Internal procedure */
#define CIF_SCP_INTERFACE	6	/* interface body (function or subroutine) */
#define CIF_SCP_INT_BLOCK      	7	/* interface block */
#define CIF_SCP_C_FILE		8	/* C file scope */
#define CIF_SCP_C_BLOCK		9	/* C block scope */


/* ---- F90 interface block types */
#define CIF_IB_SPECIFIC		1	/* specific (unnamed) */
#define CIF_IB_GENERIC		2	/* generic (has a generic name) */
#define CIF_IB_OPERATOR		3	/* operator */
#define CIF_IB_ASSIGNMENT	4	/* assignment */


/* ---- F90 derived type flags */
#define CIF_DRT_SEQUENCE	0x1	/* definition contains the SEQUENCE statement */
#define CIF_DRT_PRIVATE		0x2	/* type definition has private access (default is public) */
#define CIF_DRT_COMP_PRIVATE	0x4	/* components have private access */


/* --- back end node types --- */
#define CIF_BE_TIMING		 0	/* timing stats */
#define CIF_BE_LOOP		 1	/* loop stats */
#define CIF_BE_BTE		 2	/* block transfer engine stats */
#define CIF_BE_OTHER             3      /* other:  branch, etc */

/* --- back end timing subtypes --- */
#define CIF_TT_WORK		 0	/* user work */
#define CIF_TT_CALL		 1	/* function call site */
#define CIF_TT_MEM		 2	/* memory fetch, non-local */
#define CIF_TT_PFQ		 3	/* Pre Fetch Queue wait */
#define CIF_TT_BTE		 4	/* Block Transfer Engine wait */
#define CIF_TT_BARRIER		 5	/* barrier wait */
#define CIF_TT_CRIT		 6	/* critical section entry */
#define CIF_TT_ATOMIC		 7	/* atomic update */
#define CIF_TT_LOOPS		 8	/* loop start */
#define CIF_TT_LOOPD		 9	/* loop distribution */
#define CIF_TT_LOOPT		10	/* loop termination */
#define CIF_TT_ENTRY		11	/* entry point */

 /* --- back end other subtypes --- */
#define CIF_BE_BRANCH            1      /* branch */
#define CIF_BE_COND_BR           2      /* conditional branch */
#define CIF_BE_PAL               3      /* pal call */
#define CIF_BE_RET               4      /* return */
#define CIF_BE_S2PC		 5 	/* shared to private coercion */


/* --- back end instruction types --- */
#define CIF_IT_FADD              0      /* floating adds+substracts */
#define CIF_IT_FMUL              1      /* floating multiplies */
#define CIF_IT_FDIV_S            2      /* floating divides, S format */
#define CIF_IT_FDIV_T            3      /* floating divides, T format */
#define CIF_IT_IADD              4      /* integer adds+subtracts */
#define CIF_IT_IMUL              5      /* integer multiplies */
#define CIF_IT_IDIV              6      /* integer divides */
#define CIF_IT_LOAD              7      /* load  local */
#define CIF_IT_STORE             8      /* store local */
#define CIF_IT_LOAD_LS           9      /* load  local shared */
#define CIF_IT_STORE_LS         10      /* store local shared */
#define CIF_IT_LOAD_R           11      /* load  remote */
#define CIF_IT_STORE_R          12      /* store remote */
#define CIF_IT_OTHER            13      /* other instructions */
#define CIF_IT_MAX              14

/* Source position "kinds" */
#define CIF_SRC_KIND_MAIN	1	/* main file */
#define CIF_SRC_KIND_INCLUDE	2	/* included file */
#define CIF_SRC_KIND_MACRO	3	/* macro expansion */
#define CIF_SRC_KIND_INLINE	4	/* inlined routine */
#define CIF_SRC_KIND_TAIL	5	/* tail recusrion */


#endif /* CIF_VERSION != 1 */

/* --- C type qualifiers --- */
#define CIF_TQC_CONST		0x1	/* const */
#define CIF_TQC_VOL		0x2	/* volatile */
#define CIF_TQC_RESTR		0x4	/* restrict */
#define CIF_TQC_MAX		5	/* type qualifiers array size */


/* --- Error values stored in the CIF_SUMMARY records fldlen field
 *     These indicate that the CIF's should not be trusted as
 *     sufficient errors were found in the compilation to make
 *     it largely suspect
 */

#define CIF_ER_100		-1 /* Compilation aborted due to 100 errors */
#define CIF_ER_INTERNAL		-2 /* Internal or Limit error */
#define CIF_ER_OTHER		-3 /* Other error */


/* ---------------------------------------------------------------------------
 * The structure definitions for each CIF record follow.  The structure are
 * packed to minimize space.  Fields are aligned to maximize compaction on
 * both 32 and 64 bit boundaries.  After each structure is a "define" symbol
 * that specifies the number of bytes used for the "short" version of the
 * structure.  The short version is the amount of information in the structure
 * written to a binary format file.
 * ---------------------------------------------------------------------------
 */

/* --- generic record header description --- */
struct Cif_generic {
	FIELD rectype:8;	/* type of record */
};

/* --- C type modifier information --- */
struct Cif_tmod {
	FIELD val:32;		/* symbol id or dimension size */
	FIELD mod:8;		/* C type modifier */
};
#define TMOD_SSIZE 5		/* short size of tmod structure */

/* --- C constants information --- */
struct Cif_c_const {
	FIELD rectype:8;	/* type of record = CIF_C_CONST */
	FIELD symid:24;		/* symbol id assigned to constant symbol */
	FIELD vlen:24;		/* number of characters in value */
	FIELD btype:8;		/* basic type of constant */
	char *value;		/* pointer to symbol value string */
};
#define CCONST_SSIZE 8		/* short size of C const structure */

/* --- C entry information --- */

#if CIF_VERSION == 1

struct Cif_c_entry {
	FIELD rectype:8;	/* type of record = CIF_C_ENTRY */
	FIELD ptype:2;		/* =3 to indicate "function" */
	FIELD symclass:2;	/* symbol class of function entry */
	FIELD retvalue:2;	/* function returns a value */
				/* (0=no, 1=yes, 2=unknown, 3=intrinsic) */
	FIELD varargs:2;	/* 0=no, 1=yes; unknown max # arguments
				 * doesn't necessarily mean varargs, eg
				 * could be a function with no prototype
				 * int b(); for example */
	FIELD scope:8;		/* scope level */
	FIELD nlen:8;		/* number of characters in name */
	FIELD symid:24;		/* symbol id assigned to function name */
	FIELD nargs:8;		/* number of known formal arguments */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	long *argids;		/* ptr to list of format argument ids */
	char *name;		/* pointer to function name */
};

#define CENTRY_SSIZE 10		/* short size of entry structure */

#else  /* VERSION 2 */

struct Cif_c_entry {
	FIELD rectype:8;	/* type of record = CIF_C_ENTRY */
	FIELD ptype:2;		/* =3 to indicate "function" */
	FIELD symclass:6;	/* symbol class of function entry */
	FIELD retvalue:4;	/* function returns a value */
				/* (0=no, 1=yes, 2=unknown) */
	FIELD varargs:4;	/* 0=no, 1=yes.. with padding to byte*/
	FIELD scope:8;		/* scope level */
	FIELD nlen:8;		/* number of characters in name */
	FIELD symid:24;		/* symbol id assigned to function name */
	FIELD nargs:8;		/* number of known formal arguments */
	FIELD tagid:24;		/* tag id if the function returns a
				   struct, union or enum; else empty */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	FIELD un:16;		/* unused */
	FIELD link:24;		/* link to other equivalent entry records */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	long *argids;		/* ptr to list of format argument ids */
	char *name;		/* pointer to function name */
};

#define CENTRY_SSIZE_2 15	/* short size of Version 2 entry structure */
				/* in V2 CENTRY_SSIZE was incorrectly set */
				/* to 15.  This value is used to read V2 */
				/* binary CIF files */
#define CENTRY_SSIZE 19		/* short size of entry structure */

/* Verson 1 structure, allows libcif to honour a request to a version 1 application */

struct Cif_c_entry_1 {
	FIELD rectype:8;	/* type of record = CIF_C_ENTRY */
	FIELD ptype:2;		/* =3 to indicate "function" */
	FIELD symclass:2;	/* symbol class of function entry */
	FIELD retvalue:2;	/* function returns a value */
				/* (0=no, 1=yes, 2=unknown) */
	FIELD varargs:2;	/* 0=no, 1=yes */
	FIELD scope:8;		/* scope level */
	FIELD nlen:8;		/* number of characters in name */
	FIELD symid:24;		/* symbol id assigned to function name */
	FIELD nargs:8;		/* number of known formal arguments */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	long *argids;		/* ptr to list of format argument ids */
	char *name;		/* pointer to function name */
};

#define CENTRY_SSIZE_1 10		/* short size of entry structure */

#endif /* CIF_VERSION == 1 */





#if CIF_VERSION != 1
/* --- C lint directive information --- */
struct Cif_c_lint_directive {
	FIELD rectype:8;	/* type of record = CIF_C_LINT_DIRECTIVE */
	FIELD fid:24;   	/* source file id */
	FIELD nlen:8;		/* number of characters in name */
	FIELD objid:24;		/* object id of the target obj of directive */
	FIELD val:16;		/* value of "n" */
	FIELD strpos:16;	/* char pos where the directive appears */
	FIELD strline:24;    	/* source line num where directive appears */
	FIELD un1:8;		/* unused */
	FIELD endline:24;	/* source line where directive effect ends */
	FIELD un2:8;		/* unused */
	FIELD endpos:16;	/* char pos where directive effect ends */
	char *name;		/* pointer to name of directive */
};
#define CLINT_DIRECTIVE_SSIZE 22	/* short size of C lint directive structure */

/* --- C entry end information --- */
struct Cif_c_entry_end {
	FIELD rectype:8;	/* type of record = CIF_C_ENTRY_END */
	FIELD symid:24;		/* symbol id assigned to function name */
	FIELD strline:24;	/* source line number where the definition begins */
	FIELD nlen:8;		/* number of characters in name */
	FIELD endline:24;	/* source line number where the definition end */
	FIELD un1:8;		/* unused */
	FIELD fid:16;		/* id of file where function occurs */
	char *name;		/* pointer to function name */
};
#define CENTRY_END_SSIZE 14	/* short size of entry end structure */

/* --- C macro def information --- */
struct Cif_c_macro_def {
	FIELD rectype:8;	/* type of record = CIF_C_MACRO_DEF */
	FIELD symid:24;		/* symbol id assigned to macro */
	FIELD nlen:8;		/* number of characters in name */
	FIELD strline:24;	/* source line number where definition begins */
	FIELD fid:16;		/* id of file where macro occurs */
	FIELD strpos:16;	/* char pos where definition begins */
	FIELD endline:24;	/* source line number where definition ends */
	FIELD un1:8;		/* unused */
	FIELD endpos:16;	/* char pos within line where definition ends */
	char *name;		/* pointer to macro name */
};
#define CMACRO_DEF_SSIZE 18	/* short size of macro def structure */

/* --- C macro undef information --- */
struct Cif_c_macro_undef {
	FIELD rectype:8;	/* type of record = CIF_C_MACRO_UNDEF */
	FIELD symid:24;		/* symbol id assigned to macro */
	FIELD fid:16;		/* id of file where macro occurs */
	FIELD cpos:16;		/* char position where undefinition occurs */
	FIELD line:24;		/* source line where the undefinition occurs */
};
#define CMACRO_UNDEF_SSIZE 11	/* short size of undef structure */

/* --- C macro usage information --- */
struct Cif_c_macro_usage {
	FIELD rectype:8;	/* type of record = CIF_C_MACRO_USAGE */
	FIELD useid:24;		/* usage id */
	FIELD symid:24;		/* symbol id assigned to macro */
	FIELD un1:8;		/* unused */
	FIELD fid:16;		/* id of file where macro occurs */
	FIELD strpos:16;	/* char pos where usage begins */
	FIELD strline:24;	/* source line where the usage begins */
	FIELD un2:8;		/* unused */
	FIELD endline:24;	/* source line where the usage ends */
	FIELD un3:8;		/* unused */
	FIELD endpos:16;	/* char pos where usage ends */
};
#define CMACRO_USAGE_SSIZE 22	/* short size of macro usage structure */

#endif /* CIF_VERSION == 1 */



/* --- C messages --- */
#if CIF_VERSION == 1
struct Cif_c_message {
	FIELD rectype:8;	/* type of record = CIF_C_MESSAGE */
	FIELD fline:24;		/* line where message occurs */
	FIELD msgno:16;		/* message number */
	FIELD fid:16;		/* id of file where message occurs */
	FIELD flinesuf:8;	/* line number suffix ('s' or 'm') */
	FIELD severity:8;	/* message severity */
	FIELD incid:16;		/* include file id where message occurs */
	FIELD iline:24;		/* line in include file where msg occurs */
	FIELD nargs:8;		/* number of argument strings */
	char **args;		/* pointer to array of argument pointers */
};
#define CMESSAGE_SSIZE 16	/* short size of C message structure */

#else  /* Version 2 */

struct Cif_c_message {
	FIELD rectype:8;	/* type of record = CIF_C_MESSAGE */
	FIELD fline:24;		/* line where message occurs */
	FIELD msgno:16;		/* message number */
	FIELD fid:16;		/* id of file where message occurs */
	FIELD flinesuf:8;	/* line number suffix ('s' or 'm') */
	FIELD severity:8;	/* message severity */
	FIELD incid:16;		/* include file id where message occurs */
	FIELD iline:24;		/* line in include file where msg occurs */
	FIELD nargs:8;		/* number of argument strings */
	FIELD msgcode:8;	/* message code */
	char **args;		/* pointer to array of argument pointers */
};
#define CMESSAGE_SSIZE 17	/* short size of C message structure */

/* a copy of the version 1 cif, used if an application compiled with version 2
   wants to read a version 1 cif */

struct Cif_c_message_1 {
	FIELD rectype:8;	/* type of record = CIF_C_MESSAGE */
	FIELD fline:24;		/* line where message occurs */
	FIELD msgno:16;		/* message number */
	FIELD fid:16;		/* id of file where message occurs */
	FIELD flinesuf:8;	/* line number suffix ('s' or 'm') */
	FIELD severity:8;	/* message severity */
	FIELD incid:16;		/* include file id where message occurs */
	FIELD iline:24;		/* line in include file where msg occurs */
	FIELD nargs:8;		/* number of argument strings */
	char **args;		/* pointer to array of argument pointers */
};
#define CMESSAGE_SSIZE_1 16	/* short size of C message structure */

#endif  /* CIF_VERSION == 1 */


/* --- C object information --- */
#if CIF_VERSION == 1
struct Cif_c_object {
	FIELD rectype:8;	/* type of record = CIF_C_OBJECT */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD psymid:24;	/* parent symbol id if member/for. param */
	FIELD nlen:8;		/* number of characters in name */
	FIELD tagid:24;		/* tag id if struct, union, enum */
	FIELD scope:8;		/* scope level */
	FIELD size:6;		/* size of bitfield */
	FIELD symclass:6;	/* symbol class of object */
	FIELD entity:4;		/* entity of object */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	char *name;		/* pointer to name of object */
};
#define COBJECT_SSIZE 16	/* short size of C object structure */

#else  /* Version 2 */

struct Cif_c_object {
	FIELD rectype:8;	/* type of record = CIF_C_OBJECT */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD psymid:24;	/* parent symbol id if member/for. param */
	FIELD nlen:8;		/* number of characters in name */
	FIELD tagid:24;		/* tag id if struct, union, enum */
	FIELD scope:8;		/* scope level */
	FIELD size:6;		/* size of bitfield */
	FIELD symclass:6;	/* symbol class of object */
	FIELD entity:4;		/* entity of object */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	FIELD link:24;		/* link to other equivalent object records */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	char *name;		/* pointer to name of object */
};
#define COBJECT_SSIZE 19	/* short size of C object structure */

/* a copy of the version 1 cif, used if an application compiled with version 2
   wants to read a version 1 cif */

struct Cif_c_object_1 {
	FIELD rectype:8;	/* type of record = CIF_C_OBJECT */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD psymid:24;	/* parent symbol id if member/for. param */
	FIELD nlen:8;		/* number of characters in name */
	FIELD tagid:24;		/* tag id if struct, union, enum */
	FIELD scope:8;		/* scope level */
	FIELD size:6;		/* size of bitfield */
	FIELD symclass:6;	/* symbol class of object */
	FIELD entity:4;		/* entity of object */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	char *name;		/* pointer to name of object */
};
#define COBJECT_SSIZE_1 16	/* short size of C object structure */

#endif

/* --- C compiler options --- */
struct Cif_c_opts {
	FIELD rectype:8;	/* type of record = CIF_C_OPTS */
	FIELD msglev:8;		/* -h msglevel_X ASCII value */
	FIELD truncval:8;	/* -h trunc = numeric value */
	FIELD debug:8;		/* -G X ASCII value */
	FIELD atsklev:2;	/* optimization level for autotsking */
	FIELD inlnlev:2;	/* optimization level for inlining */
	FIELD sclrlev:2;	/* optimization level for scalar opt */
	FIELD vctrlev:2;	/* optimization level for vector opt */
	FIELD nincs:8;		/* number of -I options specified */
	FIELD ndefs:8;		/* number of -D options specified */
	FIELD nudefs:8;		/* number of -U options specified */
	char report[8];		/* report values "fisptv" */
	char bopts[16];		/* array of hex. digits */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* full path name of the command */
	char **incs;		/* -I argument "name[=def]" */
	char **defs;		/* -D argument "name[=def]" */
	char **udefs;		/* -U arguments "name" */
};
#define COPTS_SSIZE 33		 /* short size of c opts structure */

/* --- C tag information --- */
struct Cif_c_tag {
	FIELD rectype:8;	/* type of record = CIF_C_TAG */
	FIELD tagid:24;		/* tag id */
	FIELD size:32;		/* size of a structure/union in bits */
	FIELD nmems:16;		/* number of members */
	FIELD entity:4;		/* tag entity type */
	FIELD un1:4;		/* padding */
	FIELD nlen:8;		/* number of characters in name */
	FIELD nmods:4;		/* number of type modifiers */
	FIELD qual:4;		/* type qualifier flag */
	FIELD btype:8;		/* basic type */
	struct Cif_tmod	*mods;	/* ptr to list of type modifiers */
	long *memids;		/* member ids */
	char *name;		/* tag name */
};
#define CTAG_SSIZE 14		/* short size of tag structure */

/* --- call site --- */
struct Cif_callsite {
	FIELD rectype:8;	/* type of record = CIF_CALLSITE */
	FIELD line:24;		/* line where call occurs */
	FIELD cpos:16;		/* char position where call occurs */
	FIELD nargs:16;		/* number of actual arguments */
	FIELD entryid:24;	/* symbol id for called procedure */
	FIELD valused:1;	/* set if return value used */
	FIELD un1:7;		/* padding field */
	FIELD fid:16;		/* id of file where call occurs */
	struct Cif_callsite *link; /* pointer to other call site record */
	long *argids;		/* ptr to list of actual argument ids */
};
#define CALLSITE_SSIZE 14	/* short size of callsite structure */

/* --- cif header --- */
struct Cif_cifhdr {
	FIELD rectype:8;	/* type of record = CIF_CIFHDR */
	FIELD version:8;	/* CIF format version */
	FIELD bintype:2;	/* 0 = cifconv'd, 1 = line'd */
	FIELD lang:6;		/* source language */
	FIELD form:1;		/* cif file format, 0 = ascii, 1 = binary */
	FIELD canpos:1;		/* set if positioning operations allowed */
	FIELD posinfo:1;	/* record positioning info is available */
	FIELD cont_id:1;	/* set if contiguous id values present */
	FIELD srcfid:4;		/* source file id */
	FIELD msgfid:16;	/* id of message catalog file */
	char cvers[16];		/* compiler version */
	char date[16];		/* date of CIF creation */
	char time[16];		/* time of CIF creation */
	char group[7];		/* message group id */
	char hostcpu[9];	/* type of cpu where cif is generated */
	char machname[16];	/* name of machine where cif was generated */
};
#define CIFHDR_SSIZE sizeof(struct Cif_cifhdr)

#if CIF_VERSION == 1

/* --- Fortran 77 common block --- */
struct Cif_comblk {
	FIELD rectype:8;	/* type of record = CIF_COMBLK */
	FIELD symid:24;		/* symbol id assigned to common block */
	FIELD length:32;	/* number of bytes in common block */
	FIELD cbtype:8;		/* storage class of common block */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* pointer to common block name */
};
#define COMBLK_SSIZE 10		/* short size of comblk structure */

#else /* CIF_VERSION != 1 */

struct Cif_comblk {
	FIELD rectype:8;	/* type of record = CIF_COMBLK */
	FIELD symid:24;		/* symbol id assigned to common block */
	FIELD length:32;	/* number of bytes in common block */
	FIELD cbtype:8;		/* storage class of common block */
	FIELD nlen:8;		/* number of characters in name */
	FIELD dist:4;		/* distribution code, see CIF_DN_?? */
	FIELD un1:4;		/* unused */
	char *name;		/* pointer to common block name */
};
#define COMBLK_SSIZE 11		/* short size of comblk structure */

/* a copy of the version 1 cif, used if an application compiled with version 2
   wants to read a version 1 cif */

struct Cif_comblk_1 {
	FIELD rectype:8;	/* type of record = CIF_COMBLK */
	FIELD symid:24;		/* symbol id assigned to common block */
	FIELD length:32;	/* number of bytes in common block */
	FIELD cbtype:8;		/* storage class of common block */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* pointer to common block name */
};
#define COMBLK_SSIZE_1 10	/* short size of comblk structure */


#endif  /* CIF_VERSION == 1 */

#if CIF_VERSION == 1

/* --- constant symbol info --- */
struct Cif_const {
	FIELD rectype:8;	/* type of record = CIF_CONST */
	FIELD dtype:8;		/* data type of constant */
	FIELD nvalues:8;	/* number of values assigned */
	FIELD imptype:1;	/* implicitly defined flag */
	FIELD un1:7;		/* unused */
	FIELD nlen:8;		/* number of characters in name */
	FIELD symid:24;		/* symbol id assigned to constant symbol */
	FIELD vlen:24;		/* number of characters in value */
	char *value;		/* pointer to symbol value string */
	char *name;		/* pointer to constant symbol name */
};
#define CONST_SSIZE 11		/* short size of const structure */

#else

/* --- constant symbol info --- */
struct Cif_const {
	FIELD rectype:8;	/* type of record = CIF_CONST */
	FIELD dtype:8;		/* data type of constant */
	FIELD nvalues:8;	/* number of values assigned */
	FIELD imptype:1;	/* implicitly defined flag */
	FIELD origform:1;	/* true if original form of constant is available */
	FIELD un1:6;		/* unused */
	FIELD nlen:8;		/* number of characters in name */
	FIELD symid:24;		/* symbol id assigned to constant symbol */
	FIELD vlen:24;		/* number of characters in value */
	FIELD un2:8;		/* unused */
	FIELD olen:24;		/* original format of constant length */
	char *value;		/* pointer to symbol value string */
	char *oform;		/* original form of the constant */
	char *name;		/* pointer to constant symbol name */
};
#define CONST_SSIZE 15		/* short size of const structure */

struct Cif_const_1 {
	FIELD rectype:8;	/* type of record = CIF_CONST */
	FIELD dtype:8;		/* data type of constant */
	FIELD nvalues:8;	/* number of values assigned */
	FIELD imptype:1;	/* implicitly defined flag */
	FIELD un1:7;		/* unused */
	FIELD nlen:8;		/* number of characters in name */
	FIELD symid:24;		/* symbol id assigned to constant symbol */
	FIELD vlen:24;		/* number of characters in value */
	char *value;		/* pointer to symbol value string */
	char *name;		/* pointer to constant symbol name */
};
#define CONST_SSIZE_1 11       	/* short size of const structure */

#endif /* CIF_VERSION == 1 */


#if CIF_VERSION != 1  /* New records from cft77 */
/* --- simple cdir info */
struct Cif_cdir {
	FIELD rectype:8;	/* type of record = CIF_CDIR */
	FIELD line:24;		/* line on which cdir starts */
	FIELD fid:16;		/* file id in which cdir appears */
	FIELD cpos:16;		/* character position of cdir */
	FIELD type:8;		/* cdir type, see CIF_CD_?? */
	FIELD nids:16;		/* number of COPY variables (only for type == end_master) */
	long *ids;		/* ptr to COPY variable symbol ids */
};
#define CDIR_SSIZE 11		/* short size of cdir structure */


/* --- doshared cdir information ---*/
struct Cif_cdir_doshared {
	FIELD rectype:8;	/* type of record = CIF_CDIR_DOSHARED */
	FIELD line:24;		/* line on which cdir doshared starts */
	FIELD type:8;		/* doshared type, see CIF_DO_?? */
	FIELD random:1;		/* random layout */
	FIELD mexpr:1;		/* 1 if M is an expression */
	FIELD un1:6;		/* unused */
	FIELD fid:16;		/* file id in which cdir doshared appears */
	FIELD cpos:16;		/* character position of cdir doshared*/
	FIELD mfid:16;		/* M file id */
	FIELD mcpos:16;		/* M character position */
	FIELD nids:16;		/* number of DOSHARED control variables */
	FIELD mline:24;		/* M line number */
	FIELD un2:8;		/* unused */
	FIELD m:32;		/* M : block, chunk size, guided value or expression ( = NULL ) */
	long *ids;		/* ptr to DOSHARED control variable symbol ids */
};
#define CDIR_DOSHARED_SSIZE 24		/* short size of cdir_doshared structure */

/* --- doshared geometry information ---*/

struct Cif_geometry_dim {
	FIELD dist:8;		/* dimension distribution */
	FIELD wline:24;		/* weight line number */
	FIELD weight:16;	/* weight, wtype is 1 if this is an expression */
	FIELD wfid:16;		/* weight file id */
	FIELD wcpos:16;		/* weight character position */
	FIELD bfid:16;		/* block size file id */
	FIELD bsize:24;		/* block size */
	FIELD btype:1;		/* 1 if block size is an expression */
	FIELD wtype:1;		/* 1 if weight is an expression */
	FIELD un1:6;		/* unused */
	FIELD bline:24;		/* block size line number */
	FIELD un2:8;		/* unused */
	FIELD bcpos:16;		/* block size character position */
};
#define GEOM_SSIZE 22

struct Cif_geometry {
	FIELD rectype:8;	/* type of record = CIF_GEOMETRY */
	FIELD geomid:24;	/* geomtry id */
	FIELD ndims:8;		/* number of dimensions */
	FIELD nlen:24;		/* name length */
	struct Cif_geometry_dim *dim;  /* ptr to geometry dimension info */
	char *name;
};
#define GEOMETRY_SSIZE 8	/* short size of geometry structure */


/* --- continuation line record */
struct Cif_continuation {
	FIELD rectype:8;	/* type of record = CIF_CONTINUATION */
	FIELD line:24;		/* line on which the continuation occurs */
	FIELD fid:16;		/* file id where the continuation line appears */
	FIELD cpos:16;		/* character position at which the continuation line begins */
	FIELD type:1;		/* 0 = regular stmt; 1 = CDIR continuation */
	FIELD un1:7;		/* unused */
};
#define CONTINUATION_SSIZE  9	/* short size of geometry structure */


#endif /* CIF_VERSION != 1 */



/* --- Fortran enable/disable options --- */
struct Cif_edopts {
	FIELD rectype:8;	/* type of record = CIF_EDOPTS */
	long opts;		/* enable/disable mask value, see CIF_[F90_]EDF_OPT? */
};
#define EDOPTS_SSIZE sizeof(struct Cif_edopts)

/* --- Fortran 77 entry point/procedure information --- */
struct Cif_entry {
	FIELD rectype:8;	/* type of record = CIF_ENTRY */
	FIELD etype:8;		/* type of entry */
	FIELD dtype:8;		/* data type of returned value */
	FIELD nlen:8;		/* number of characters in name */
	FIELD valargs:1;	/* valid arguments present indicator */
	FIELD recur:1;		/* routine is recursive */
	FIELD stmtfunc:1;	/* routine is statement function */
	FIELD extrn:1;		/* routine is external */
	FIELD intrin:1;		/* routine is intrinsic */
	FIELD un2:2;		/* unused */
	FIELD imptype:1;	/* implicitly typed */
	FIELD symid:24;		/* symbol id assigned to procedure name */
	FIELD charlen:24;	/* if character type, character length */
	FIELD nargs:8;		/* number of formal arguments */
	long *argids;		/* ptr to list of formal argument ids */
	char *name;		/* pointer to procedure name */
};
#define ENTRY_SSIZE 13		/* short size of entry structure */

/* --- file declaration --- */

#if CIF_VERSION == 3

struct Cif_file {
	FIELD rectype:8;	/* type of record = CIF_FILE */
	FIELD nlen:8;		/* number of characters in name */
	FIELD fid:16;		/* id assigned to file name */
	FIELD onlen:8;		/* number of characters in oname */
	char *name;		/* pointer to the fully pathed file name */
	char *oname;		/* pointer to the original file name */
};
#define FILE_SSIZE 5		/* short size of file structure */

struct Cif_file_1 {
	FIELD rectype:8;	/* type of record = CIF_FILE */
	FIELD nlen:8;		/* number of characters in name */
	FIELD fid:16;		/* id assigned to file name */
	char *name;		/* pointer to file name */
};
#define FILE_SSIZE_1 4		/* short size of file structure */

#else /* Version < 3 */

struct Cif_file {
	FIELD rectype:8;	/* type of record = CIF_FILE */
	FIELD nlen:8;		/* number of characters in name */
	FIELD fid:16;		/* id assigned to file name */
	char *name;		/* pointer to file name */
};
#define FILE_SSIZE 4		/* short size of file structure */

#endif /* Version == 3 */

/* --- file directory --- */
struct Cif_unittbl {
	FIELD unitpos:32;	/* file position of CIF_UNIT record */
	FIELD nlen:8;		/* number of characters in unit name */
	char *name;		/* pointer to unit name */
};
#define UNITTBL_SSIZE 5		/* short size of unittbl structure */

struct Cif_filedir {
	FIELD rectype:8;	/* type of record = CIF_FILEDIR */
	FIELD maxfid:24;	/* largest file id present in file */
	FIELD nunits:16;	/* number of units in file */
	FIELD nfiles:16;	/* number of CIF_FILE records present */
	FIELD maxsid:24;	/* maximum symbol id present in file */
	FIELD un1:8;		/* unused */
	FIELD nincs:16;		/* number of CIF_INCLUDE records present */
	struct Cif_unittbl *ut;	/* pointer to unit table */
};
#define FILEDIR_SSIZE 14	/* short size of filedir */

/* --- included file use --- */
struct Cif_include {
	FIELD rectype:8;	/* type of record = CIF_INCLUDE */
	FIELD line:24;		/* line where include occurs */
	FIELD cpos:16;		/* char position where include occurs */
	FIELD srcid:16;		/* id of file where include occurs */
	FIELD incid:16;		/* id of file included */
};
#define INCLUDE_SSIZE 10	/* short size of include structure */

/* --- Fortran 77 label info --- */
struct Cif_label {
	FIELD rectype:8;	/* type of record = CIF_LABEL */
	FIELD symid:24;		/* symbol id assigned to label name */
	FIELD ltype:8;		/* type of label */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* pointer to label name */
};
#define LABEL_SSIZE 6		/* short size of label structure */

/* --- loop definition --- */
struct Cif_loop {
	FIELD rectype:8;	/* type of record = CIF_LOOP */
	FIELD strline:24;	/* starting line of loop */
	FIELD lptype:8;		/* loop type */
	FIELD endline:24;	/* ending line of loop */
	FIELD strcpos:16;	/* starting char position of loop */
	FIELD endcpos:16;	/* ending char position of loop */
	FIELD sfid:16;		/* id of file where loop ends */
	FIELD efid:16;		/* id of file where loop ends */
	FIELD symid:24;		/* id of control variable */
	FIELD un1:8;		/* unused */
	FIELD labelid:24;	/* id of label terminating loop */
};
#define LOOP_SSIZE 23		/* short size of label structure */

#if CIF_VERSION == 1

/* --- machine characteristics --- */
struct Cif_mach_char {
	FIELD rectype:8;	/* type of record = CIF_MACH_CHAR */
	int memspeed;		/* memory cycle time */
	long memsize;		/* number of words of memory */
	long valmask;		/* characteristics value mask */
	char cpuname[16];	/* name of target cpu */
};
#define MACH_CHAR_SSIZE sizeof(struct Cif_mach_char)

#else  /* CIF_VERSION != 1 */

/* --- machine characteristics --- */
struct Cif_mach_char {
	FIELD rectype:8;	/* type of record = CIF_MACH_CHAR */
	FIELD memspeed:24;     	/* memory cycle time */
	FIELD memsize:32;      	/* number of words of memory */
	FIELD valmask:32;	/* characteristics value mask */
	char cpuname[15];	/* name of target cpu */
	FIELD tbitlen:8;       	/* bit length on the target machine */
	FIELD numbanks:16;	/* number of memory banks */
	FIELD numcpus:16;	/* number of cpus */
	FIELD instbufsize:32;	/* instruction buffer size */
	FIELD clockperiod:16;	/* clock period in picoseconds */
	FIELD numclregs:16;	/* number of register clusters */
	FIELD bankbusytime:16;	/* number of clock periods that the memory bank is reserved */
};
#define MACH_CHAR_SSIZE 42	/* short size of machine char structure */

struct Cif_mach_char_1 {
	FIELD rectype:8;	/* type of record = CIF_MACH_CHAR */
	int memspeed;		/* memory cycle time */
	long memsize;		/* number of words of memory */
	long valmask;		/* characteristics value mask */
	char cpuname[16];	/* name of target cpu */
};
#define MACH_CHAR_SSIZE_1 sizeof(struct Cif_mach_char_1)



#endif /* CIF_VERSION == 1 */

#if CIF_VERSION < 3
 
/* --- Fortran message --- */
struct Cif_message {
	FIELD rectype:8;	/* type of record = CIF_MESSAGE */
	FIELD fline:24;		/* line where message occurs */
	FIELD severity:8;	/* message severity */
	FIELD uline:24;		/* base level file line number */
	FIELD msgno:16;		/* message number */
	FIELD cpos:16;		/* char position where message occurs */
	FIELD nargs:8;		/* number of argument strings */
	FIELD fid:16;		/* id of file where message occurs */
	char **args;		/* pointer to array of argument pointers */
};
#define MESSAGE_SSIZE 15	/* short size of message structure */

#else

/* --- Fortran message --- */
struct Cif_message {
	FIELD rectype:8;	/* type of record = CIF_MESSAGE */
	FIELD fline:24;		/* line where message occurs */
	FIELD severity:8;	/* message severity */
	FIELD uline:24;		/* base level file line number */
	FIELD msgno:16;		/* message number */
	FIELD cpos:16;		/* char position where message occurs */
	FIELD nargs:8;		/* number of argument strings */
	FIELD fid:16;		/* id of file where message occurs */
	FIELD nlen:8;		/* scoping unit name length */
	FIELD order:8;		/* relative order of same position messages */
	FIELD flags:8;		/* 0001 = alternative field definition */
	FIELD un1:16;		/* padding for future expandion */
	FIELD pfid:24;		/* primary fid, will only differ from fid when
				 * a message comes from an inlined */
	char **args;		/* pointer to array of argument pointers */
	char *name;		/* scoping unit name */
};
#define MESSAGE_SSIZE 23	/* short size of message structure */

/* --- Fortran message --- */
struct Cif_message_1 {
	FIELD rectype:8;	/* type of record = CIF_MESSAGE */
	FIELD fline:24;		/* line where message occurs */
	FIELD severity:8;	/* message severity */
	FIELD uline:24;		/* base level file line number */
	FIELD msgno:16;		/* message number */
	FIELD cpos:16;		/* char position where message occurs */
	FIELD nargs:8;		/* number of argument strings */
	FIELD fid:16;		/* id of file where message occurs */
	char **args;		/* pointer to array of argument pointers */
};
#define MESSAGE_SSIZE_1 15	/* short size of message structure */

#endif /* CIF_VERSION < 3 */

#if CIF_VERSION == 1

/* --- Fortran 77 miscellaneous options --- */
struct Cif_misc_opts {
	FIELD rectype:8;	/* type of record = CIF_MISC_OPTS */
	FIELD malloc:4;		/* type of memory allocation */
	FIELD intlen:4;		/* length of integers */
	FIELD msglvl:4;		/* message level */
	FIELD vopt:4;		/* compilation statistics enabled */
	FIELD amode:4;		/* addressing mode */
	FIELD trunc:4;		/* truncation enabled */
	FIELD truncval:8;	/* number of bits to truncate */
	FIELD nmsgs:8;		/* number of messages disabled */
	FIELD ncdirs:8;		/* number of cdirs disabled */
	FIELD onlen:8;		/* no. of chars in object file name */
	FIELD cnlen:8;		/* no. of chars in cal file name */
	FIELD inlen:8;		/* no. of chars in inline file name */
	long *msgno;		/* pointer to messages disabled */
	char **cdirs;		/* pointer to cdirs disabled */
	char *objname;		/* pointer to object file name */
	char *calname;		/* pointer to cal file name */
	char *inname;		/* pointer to inline file name */
};
#define MISC_OPTS_SSIZE 10	/* short size of misc_opts structure */

#else /* CIF_VERSION != 1 */

/* --- Fortran 77 miscellaneous options --- */
struct Cif_misc_opts {
	FIELD rectype:8;	/* type of record = CIF_MISC_OPTS */
	FIELD malloc:4;		/* type of memory allocation */
	FIELD intlen:4;		/* length of integers */
	FIELD msglvl:4;		/* message level */
	FIELD vopt:4;		/* compilation statistics enabled */
	FIELD amode:4;		/* addressing mode */
	FIELD trunc:4;		/* truncation enabled */
	FIELD truncval:8;	/* number of bits to truncate */
	FIELD nmsgs:8;		/* number of messages disabled */
	FIELD ncdirs:8;		/* number of cdirs disabled */
	FIELD onlen:8;		/* no. of chars in object file name */
	FIELD cnlen:8;		/* no. of chars in cal file name */
	FIELD inlen:8;		/* no. of chars in inline file name */
	FIELD llen:8;		/* no. of chars in listing file name */
#ifdef CRAY
	/*
	 * this format is fine on a Cray as we use two words and
	 * there is no overlapping of bounadries; however, on the
	 * sun cifopt spans a 32 bit word, so has to be moved.
	 * Unfortunately, a release with this format has already been
	 * released on a Cray, so it can not be changed as there
	 * might be binary CIF's created which expect the original
	 * format
	 */
	FIELD cifopt:16;	/* cif options , see CIF_CO_? */
	FIELD inputlen:8;	/* input line length, 72 or 80 */
#else
	FIELD inputlen:8;	/* input line length, 72 or 80 */
	FIELD cifopt:16;	/* cif options , see CIF_CO_? */
#endif /* CRAY */
	FIELD runtime:8;	/* run time checking, see CIF_RT_? */
	FIELD numincs:8;	/* number of include directories specified with -P potion */
	long *msgno;		/* pointer to messages disabled */
	char **cdirs;		/* pointer to cdirs disabled */
	char *objname;		/* pointer to object file name */
	char *calname;		/* pointer to cal file name */
	char *inname;		/* pointer to inline file name */
	char *lname;		/* pointer to listing file name */
	char **incdirs;		/* pointer to include directories */
};
#define MISC_OPTS_SSIZE 16	/* short size of misc_opts structure */

struct Cif_misc_opts_1 {
	FIELD rectype:8;	/* type of record = CIF_MISC_OPTS */
	FIELD malloc:4;		/* type of memory allocation */
	FIELD intlen:4;		/* length of integers */
	FIELD msglvl:4;		/* message level */
	FIELD vopt:4;		/* compilation statistics enabled */
	FIELD amode:4;		/* addressing mode */
	FIELD trunc:4;		/* truncation enabled */
	FIELD truncval:8;	/* number of bits to truncate */
	FIELD nmsgs:8;		/* number of messages disabled */
	FIELD ncdirs:8;		/* number of cdirs disabled */
	FIELD onlen:8;		/* no. of chars in object file name */
	FIELD cnlen:8;		/* no. of chars in cal file name */
	FIELD inlen:8;		/* no. of chars in inline file name */
	long *msgno;		/* pointer to messages disabled */
	char **cdirs;		/* pointer to cdirs disabled */
	char *objname;		/* pointer to object file name */
	char *calname;		/* pointer to cal file name */
	char *inname;		/* pointer to inline file name */
};
#define MISC_OPTS_SSIZE_1 10	/* short size of misc_opts structure */

#endif /* CIF_VERSION == 1 */

/* --- Fortran 77 namelist specification --- */
struct Cif_namelist {
	FIELD rectype:8;	/* type of record = CIF_NAMELIST */
	FIELD symid:24;		/* symbol id assigned to namelist */
	FIELD nids:16;		/* number of items in namelist */
	FIELD nlen:8;		/* no. of characters in namelist */
	char *name;		/* ptr to name of namelist */
	long *ids;		/* ptr to list of ids in namelist */
};
#define NAMELIST_SSIZE 7	/* short size of namelist structure */

/* --- Fortran non-default messages --- */
struct Cif_nd_msg {
	FIELD rectype:8;	/* type of record = CIF_ND_MSG */
	FIELD fline:24;		/* line where message occurs */
	FIELD severity:8;	/* message severity */
	FIELD uline:24;		/* base level file line number */
	FIELD msgno:16;		/* message number */
	FIELD cpos:16;		/* char position where message occurs */
	FIELD fid:16;		/* id of file where message occurs */
	FIELD msgfid:16;	/* id of message catalog file */
	char group[16];		/* message group id */
	FIELD nargs:8;		/* number of argument strings */
	char **args;		/* pointer to array of argument pointers */
};
#define ND_MSG_SSIZE 33		/* short size of non-default msg structure */

/* --- Fortran 77 object info --- */

struct Cif_dim {
	int lower;			/* lower bound */
	int upper;			/* upper bound */
	FIELD ltype:8;		/* lower bound dimension type */
	FIELD utype:8;		/* upper bound dimension type */
};
#define DIM_SSIZE sizeof(struct Cif_dim)

#if CIF_VERSION == 1

struct Cif_object {
	FIELD rectype:8;	/* type of record = CIF_OBJECT */
	FIELD storage:24;	/* storage type of object */
	FIELD class:8;		/* symbol class of object */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD dtype:8;		/* data type of object */
	FIELD charlen:24;	/* if character type, character length */
	FIELD offset:32;	/* storage offset of object */
	FIELD nlen:8;		/* number of characters in name */
	FIELD ndims:3;		/* number of dimensions */
	FIELD aarray:1;		/* automatic array */
	FIELD equiv:1;		/* appears in EQUIVALENCE statement */
	FIELD data:1;		/* appears in DATA statement */
	FIELD save:1;		/* appears in SAVE statement */
	FIELD imptype:1;	/* implicitly defined flag */
	FIELD valoffset:1;	/* valid offset present indicator */
	FIELD cltype:1;		/* character length is assumed */
	FIELD un1:6;		/* unused */
	char *name;		/* pointer to name of object */
	struct Cif_dim *dim;	/* pointer to array of dimension items */
};
#define OBJECT_SSIZE 19		/* short size of object structure */

#else /* CIF_VERSION != 1 */

struct Cif_object {
	FIELD rectype:8;	/* type of record = CIF_OBJECT */
	FIELD storage:24;	/* storage type of object */
	FIELD symclass:8;	/* symbol class of object */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD dtype:8;		/* data type of object */
	FIELD charlen:24;	/* if character type, character length */
	FIELD offset:32;	/* storage offset of object */
	FIELD nlen:8;		/* number of characters in name */
	FIELD ndims:3;		/* number of dimensions */
	FIELD aarray:1;		/* automatic array */
	FIELD equiv:1;		/* appears in EQUIVALENCE statement */
	FIELD data:1;		/* appears in DATA statement */
	FIELD save:1;		/* appears in SAVE statement */
	FIELD imptype:1;	/* implicitly defined flag */
	FIELD valoffset:1;	/* valid offset present indicator */
	FIELD cltype:1;		/* character length is assumed */
	FIELD peresident:1;	/* object is PE resident */
	FIELD pointee:1;	/* object is a pointee */
	FIELD arraydec:1;	/* object used in an array declaration */
	FIELD geomdec:1;	/* object used in a geometry declaration */
	FIELD un1:6;		/* unused */
	FIELD dist:4;		/* distribution code, see CIF_DN_?? */
	FIELD geomid:24;	/* geometry id */
	FIELD un2:8;		/* unused */
	FIELD pointer:24;	/* pointer id if this is a pointee */
	char *name;		/* pointer to name of object */
	struct Cif_dim *dim;	/* pointer to array of dimension items */
};
#define OBJECT_SSIZE 	27	/* short size of object structure */

/* a copy of the version 1 cif, used if an application compiled with version 2
   wants to read a version 1 cif */

struct Cif_object_1 {
	FIELD rectype:8;	/* type of record = CIF_OBJECT */
	FIELD storage:24;	/* storage type of object */
	FIELD symclass:8;      	/* symbol class of object */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD dtype:8;		/* data type of object */
	FIELD charlen:24;	/* if character type, character length */
	FIELD offset:32;	/* storage offset of object */
	FIELD nlen:8;		/* number of characters in name */
	FIELD ndims:3;		/* number of dimensions */
	FIELD aarray:1;		/* automatic array */
	FIELD equiv:1;		/* appears in EQUIVALENCE statement */
	FIELD data:1;		/* appears in DATA statement */
	FIELD save:1;		/* appears in SAVE statement */
	FIELD imptype:1;	/* implicitly defined flag */
	FIELD valoffset:1;	/* valid offset present indicator */
	FIELD cltype:1;		/* character length is assumed */
	FIELD un1:6;		/* unused */
	char *name;		/* pointer to name of object */
	struct Cif_dim *dim;	/* pointer to array of dimension items */
};
#define OBJECT_SSIZE_1 19      	/* short size of object structure */

#endif /* CIF_VERSION == 1 */


#if CIF_VERSION == 1

/* --- Fortran 77 optimization options --- */
struct Cif_opt_opts {
	FIELD rectype:8;	/* type of record = CIF_OPT_OPTS */
	long values;		/* optimization values mask */
};
#define OPT_OPTS_SSIZE sizeof(struct Cif_opt_opts)

#else

/* --- Fortran 77 optimization options --- */
struct Cif_opt_opts {
	FIELD rectype:8;	/* type of record = CIF_OPT_OPTS */
	FIELD inlevel:2;	/* automatic inlining level */
	FIELD un1:22;
	FIELD values:32;	/* optimization values mask */
};
#define OPT_OPTS_SSIZE 8      	/* short size of optimization options structure */


/* --- Fortran 77 optimization options --- */
struct Cif_opt_opts_1 {
	FIELD rectype:8;	/* type of record = CIF_OPT_OPTS */
	long values;		/* optimization values mask */
};
#define OPT_OPTS_SSIZE_1 sizeof(struct Cif_opt_opts_1)

#endif /* CIF_VERSION == 1 */


/* --- source file id --- */
struct Cif_srcfile {
	FIELD rectype:8;	/* type of record = CIF_SRCFILE */
	FIELD form:8;		/* source file format */
	FIELD fid:16;		/* file id assigned to source file */
};
#define SRCFILE_SSIZE 4		/* short size of srcfile structure */

/* --- summary --- */
struct Cif_summary {
	FIELD rectype:8;	/* type of record = CIF_SUMMARY */
	char level[16];		/* compiler release level string */
	char gdate[16];		/* compiler generation date */
	char gtime[16];		/* compiler generation time */
	char ctime[16];		/* compilation time */
	long fldlen;		/* maximum target field length */
	long nlines;		/* number of source lines compiled */
	long csize;		/* length of generated code */
	long dsize;		/* length of generated data */
};
#define SUMMARY_SSIZE sizeof(struct Cif_summary)

/* --- statement type --- */
struct Cif_stmt_type {
	FIELD rectype:8;	/* type of record = CIF_STMT_TYPE */
	FIELD line:24;		/* line number of statement */
	FIELD cpos:16;		/* char position of statement */
	FIELD fid:16;		/* id of file where statement occurs */
	FIELD type:8;		/* statement type */
	FIELD eline:24;		/* end line */
	FIELD efid:16;		/* end file id */
	FIELD ecpos:16;		/* end char position */
};
#define STMT_TYPE_SSIZE 16	/* short size of stmt_type structure */
	
/* --- begin unit marker --- */
struct Cif_unit {
	FIELD rectype:8;	/* type of record = CIF_UNIT */
	FIELD line:24;		/* line where unit begins */
	FIELD cpos:16;		/* char position where unit begins */
	FIELD fid:16;		/* id of file where unit begins */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* pointer to name of unit */
};
#define UNIT_SSIZE 9		/* short size of unit record */

/* --- end unit marker --- */
struct Cif_endunit {
	FIELD rectype:8;	/* type of record = CIF_ENDUNIT */
	FIELD line:24;		/* line where unit ends */
	FIELD cpos:16;		/* char position where unit ends */
	FIELD fid:16;		/* id of file where unit ends */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* pointer to name of unit */
};
#define ENDUNIT_SSIZE 9		/* short size of endunit record */

#if CIF_VERSION == 1

/* --- usage --- */
struct Cif_use {
	FIELD line:24;		/* line where usage occurs */
	FIELD utype:10;		/* type of usage, see CIF_OB_?? or CIF_F90_OB_?? */
	FIELD cpos:14;		/* char position where usage occurs */
	FIELD fid:16;		/* id of file where usage occurs */
};

struct Cif_usage {
	FIELD rectype:8;	/* type of record = CIF_USAGE */
	FIELD nuses:24;		/* number of symbol usages */
	FIELD symid:24;		/* symbol id used */
	struct Cif_use *use;	/* ptr to array of usages */
};
#define USAGE_SSIZE 7		/* short size of usage structure */

#else /* VERSION != 1 */

/* --- usage --- */
struct Cif_use {
	FIELD line:24;		/* line where usage occurs */
	FIELD utype:10;		/* type of usage, see CIF_OB_?? or CIF_F90_OB_?? */
	FIELD data:1;		/* used in a data statement */
	FIELD init:1;		/* initialized in a declaration */
	FIELD cpos:12;		/* char position where usage occurs */
	FIELD fid:16;		/* id of file where usage occurs */
};

/* --- usage --- */
struct Cif_use_1 {
	FIELD line:24;		/* line where usage occurs */
	FIELD utype:10;		/* type of usage, see CIF_OB_?? or CIF_F90_OB_?? */
	FIELD cpos:14;		/* char position where usage occurs */
	FIELD fid:16;		/* id of file where usage occurs */
};

struct Cif_usage {
	FIELD rectype:8;	/* type of record = CIF_USAGE */
	FIELD nuses:24;		/* number of symbol usages */
	FIELD symid:24;		/* symbol id used */
	FIELD nmembs:8;       	/* number of structure member id's,
				 *  eg for a%b%c, this would be 2 */
	long *membs;		/* b and c symbol id's for a%b%c, a is in symid */
	struct Cif_use *use;	/* ptr to array of usages */
};
#define USAGE_SSIZE 8		/* short size of usage structure */

struct Cif_usage_1 {
	FIELD rectype:8;	/* type of record = CIF_USAGE */
	FIELD nuses:24;		/* number of symbol usages */
	FIELD symid:24;		/* symbol id used */
	struct Cif_use *use;	/* ptr to array of usages */
};
#define USAGE_SSIZE_1 7		/* short size of usage structure */

#endif /* CIF_VERSION == 1 */


/* --- unit directory --- */
struct Cif_urectbl {
	FIELD rectype:8;	/* record type of records in section */
	FIELD nrecords:24;	/* number of records present in section */
	FIELD recpos:32;	/* file position of first record in section */
};
#define URECTBL_SSIZE sizeof(struct Cif_urectbl)

struct Cif_unitdir {
	FIELD rectype:8;	/* type of record = CIF_UNITDIR */
	FIELD maxsid:24;	/* max symbol id present in unit */
	FIELD nsections:16;	/* number of record sections in unit */
	struct Cif_urectbl *ur;	/* pointer to unit record table */
};
#define UNITDIR_SSIZE 6		 /* short size of unitdir */




#if CIF_VERSION != 1

/* --- Code transformation record --- */
struct Cif_transform {
	FIELD rectype:8;	/* type of record = CIF_TRANSFORM */
	FIELD line:23;		/* line number of the transform */
	FIELD type:1;		/* 0 = begin, 1 = end transform */
	FIELD fid:16;		/* file id of the transform */
};
#define TRANSFORM_SSIZE 6


/* F90 Records */

#if CIF_VERSION == 2

/* --- F90 derived type --- */
struct Cif_f90_derived_type {
	FIELD rectype:8;	/* type of record = CIF_F90_DERIVED_TYPE */
	FIELD symid:24;		/* symbol id assigned to derived type name */
	FIELD scopeid:24;	/* scope id for derived type definition */
	FIELD nlen:8;		/* name length */
	FIELD dervtype:24;	/* derived type id associated with this derived type */
	FIELD sequence:1;	/* definition contains the sequence statement */
	FIELD defprivate:1;	/* type definition has private access */
	FIELD comprivate:1;	/* type components have private access */
	FIELD un1:5;		/* unused */
	FIELD flag:16;		/* format and characteristics of the derived type, see CIF_DRT_?? */
	FIELD nmembs:16;	/* number of members of the derived type */
	char *name;		/* derived type name */
        long *memids;		/* ptr to list of component member symbol ids */
};
#define F90_DERIVED_TYPE_SSIZE 16  /* short size of derived_type */

#else /* Version 3 CIF */

/* --- F90 derived type --- */
struct Cif_f90_derived_type {
	FIELD rectype:8;	/* type of record = CIF_F90_DERIVED_TYPE */
	FIELD symid:24;		/* symbol id assigned to derived type name */
	FIELD scopeid:24;	/* scope id for derived type definition */
	FIELD nlen:8;		/* name length */
	FIELD dervtype:24;	/* derived type id associated with this derived type */
	FIELD sequence:1;	/* definition contains the sequence statement */
	FIELD defprivate:1;	/* type definition has private access */
	FIELD comprivate:1;	/* type components have private access */
	FIELD un1:5;		/* unused */
	FIELD flag:16;		/* format and characteristics of the derived type, see CIF_DRT_?? */
	FIELD nmembs:16;	/* number of members of the derived type */
	FIELD moduleid:24;	/* module reference if this derived type came
				 * from a module */
	FIELD un2:8;		/* padding, for future expansion */
	FIELD un3:32;
	FIELD un4:32;

	char *name;		/* derived type name */
        long *memids;		/* ptr to list of component member symbol ids */
};
#define F90_DERIVED_TYPE_SSIZE 28  /* short size of derived_type */

/* --- F90 derived type --- */
struct Cif_f90_derived_type_2 {
	FIELD rectype:8;	/* type of record = CIF_F90_DERIVED_TYPE */
	FIELD symid:24;		/* symbol id assigned to derived type name */
	FIELD scopeid:24;	/* scope id for derived type definition */
	FIELD nlen:8;		/* name length */
	FIELD dervtype:24;	/* derived type id associated with this derived type */
	FIELD sequence:1;	/* definition contains the sequence statement */
	FIELD defprivate:1;	/* type definition has private access */
	FIELD comprivate:1;	/* type components have private access */
	FIELD un1:5;		/* unused */
	FIELD flag:16;		/* format and characteristics of the derived type, see CIF_DRT_?? */
	FIELD nmembs:16;	/* number of members of the derived type */
	char *name;		/* derived type name */
        long *memids;		/* ptr to list of component member symbol ids */
};
#define F90_DERIVED_TYPE_SSIZE_2 16  /* short size of derived_type */

#endif /* CIF_VERSION == 2 */

/* --- F90 call site --- */
struct Cif_f90_callsite {
	FIELD rectype:8;	/* type of record = CIF_F90_CALLSITE */
	FIELD line:24;		/* line where call occurs */
	FIELD cpos:16;		/* char position where call occurs */
	FIELD nargs:16;		/* number of actual arguments */
	FIELD entryid:24;	/* symbol id for called procedure */
	FIELD valused:1;	/* unused */
	FIELD rank:1;		/* true if argid ranks are specied */
	FIELD un1:6;		/* padding field */
	FIELD procid:24;	/* specific procedure symbol id if a generic name */
	FIELD un2:8;		/* unused */
	FIELD fid:16;		/* id of file where call occurs */
	FIELD un3:16;		/* unused */
	FIELD scopeid:24;	/* scopeid where this call occus */
	struct Cif_f90_callsite *link; /* pointer to other call site record */
	long *argids;		/* ptr to list of actual argument ids */
	int *nmembs;		/* ptr to a list of the number of member symbol id's for each argid */
	long **membs;		/* ptr to member symold id's for each argid, eg the b of a%b */
	int *ranks;		/* ptr to rank of each argument; 0 for scalar
				 * 1 for 1-D array etc */
};
#define F90_CALLSITE_SSIZE 23	/* short size of callsite structure */

/* --- F90 common block --- */
struct Cif_f90_comblk {
	FIELD rectype:8;	/* type of record = CIF_F90_COMBLK */
	FIELD symid:24;		/* symbol id assigned to common block */
	FIELD length:32;	/* number of bytes in common block */
	FIELD cbtype:8;		/* storage class of common block, see CIF_CB_?? */
	FIELD scopeid:24;	/* scope id of scope containing this common block */
	FIELD nlen:8;		/* number of characters in name */
	FIELD moduleid:24;     	/* module where this common block was defined, NULL if not defined in a module */
	FIELD dist:8;		/* common block distribution, see CIF_DN_?? */
	char *name;		/* pointer to common block name */
};
#define F90_COMBLK_SSIZE 16		/* short size of comblk structure */

/* --- F90 constant symbol info --- */
struct Cif_f90_const {
	FIELD rectype:8;	/* type of record = CIF_F90_CONST */
	FIELD aggregate:1;	/* 0 = scalar; 1 = aggregate constructor */
	FIELD strline:23;	/* starting line of value */
	FIELD endline:24;	/* ending line of value */
	FIELD un1:8;		/* unused */
	FIELD vlen:16;		/* number of characters in value */
	FIELD fid:16;		/* id of file where named constant declaration occurs */
	FIELD strpos:16;	/* starting character position of value */
	FIELD endpos:16;	/* ending character position of value */
	FIELD symid:24;		/* symbol id assigned to constant name */
	FIELD un2:8;		/* unused */
	FIELD scopeid:24;	/* scopeid where this constant is declared */
	char *value;		/* pointer to symbol value string */
};
#define F90_CONST_SSIZE 23		/* short size of f90 const structure */

/* --- F90 entry point/procedure information --- */
struct Cif_f90_entry {
	FIELD rectype:8;	/* type of record = CIF_F90_ENTRY */
	FIELD symid:24;		/* symbol id assigned to procedure name */
	FIELD etype:8;		/* type of entry, see CIF_F90_ET_?? */
	FIELD resultid:24;	/* symbol id for the result name, if appropriate */
	FIELD ptype:8;		/* sub-type entry, see CIF_F90_PT_?? */
	FIELD useassoc:1;	/* entry point was brought in by use association */
	FIELD direct:1;		/* appears in use stmt in this source, otherwise the module is used indirectly through another module */
				/* Note. only used by cflist, via cif_lines
				 * function. Not set otherwise; see use_module
				 * record */
	FIELD scopeid:22;	/* scope id for the scope containing this entry point, definition or reference */
	FIELD moduleid:24;	/* module id if entry from a module */
	FIELD nlen:8;		/* number of characters in name */
	FIELD valargs:1;	/* valid arguments present indicator */
	FIELD defined:1;	/* entry point is being defined */
	FIELD intblock:1;	/* defined in an interface block */
	FIELD stmtfunc:1;	/* routine is a statement function */
	FIELD referenced:1;	/* entry point is being referenced */
	FIELD optional:1;	/* OPTIONAL */
	FIELD priv:1;		/* PRIVATE */
	FIELD recur:1;		/* RECURSIVE */
	FIELD nargs:8;		/* number of formal arguments, -1 if unknown */
	long *argids;		/* ptr to list of formal argument ids */
	char *name;		/* pointer to procedure name */
};
#define F90_ENTRY_SSIZE 18	/* short size of f90 entry structure */

/* --- F90 loop definition --- */
struct Cif_f90_loop {
	FIELD rectype:8;	/* type of record = CIF_F90_LOOP */
	FIELD strline:24;	/* starting line of loop */
	FIELD lptype:8;		/* loop type, see CIF_LP_?? */
	FIELD endline:24;	/* ending line of loop */
	FIELD strcpos:16;	/* starting char position of loop */
	FIELD endcpos:16;	/* ending char position of loop */
	FIELD sfid:16;		/* id of file where loop ends */
	FIELD efid:16;		/* id of file where loop ends */
	FIELD scopeid:24;	/* scope id for this loop */
	FIELD stmtid1:8;       	/* top most bits of the statement id */
	FIELD symid:24;		/* id of control variable */
	FIELD stmtid2:8;        /* middle bits of the statement id */
	FIELD labelid:24;	/* id of label terminating loop */
	FIELD stmtid3:8;       	/* bottom bits of the statement id */
	FIELD nameid:24;	/* construct name symbol id */
};
/* contstruct the full stmt id from its individual
 * components. This field was added after the record
 * definition, resulting in this non-optimal solution
 */ 
#define TOPBITS 255 << 16
#define MIDDLEBITS 255 << 8
#define BOTTOMBITS 255
#define stmtid(A) ((A)->stmtid1<<16 | (A)->stmtid2<<8 | (A)->stmtid3)
#define setStmtid(A, B) (A)->stmtid1 = (((B) & TOPBITS) >> 16); (A)->stmtid2 = (((B) & MIDDLEBITS) >> 8); (A)->stmtid3 = (B) & BOTTOMBITS
#define F90_LOOP_SSIZE 31		/* short size of f90 loop structure */


/* --- F90 label info --- */
struct Cif_f90_label {
	FIELD rectype:8;	/* type of record = CIF_F90_LABEL */
	FIELD symid:24;		/* symbol id assigned to label name */
	FIELD ltype:8;		/* type of label, see CIF_LB_?? */
	FIELD scopeid:24;	/* scope id for this label */
	FIELD nlen:8;		/* number of characters in name */
	char *name;		/* pointer to label name */
};
#define F90_LABEL_SSIZE 9		/* short size of f90 label structure */


/* --- F90 namelist specification --- */
struct Cif_f90_namelist {
	FIELD rectype:8;	/* type of record = CIF_F90_NAMELIST */
	FIELD symid:24;		/* symbol id assigned to namelist */
	FIELD nlen:8;		/* no. of characters in namelist */
	FIELD scopeid:24;	/* scope id for this namelist */
	FIELD nids:16;		/* number of items in namelist */
	FIELD un:16;		/* unused word boundary padding */
	FIELD moduleid:24;     	/* module where this namelist was defined, NULL if not declared in a module */
	char *name;		/* ptr to name of namelist */
	long *ids;		/* ptr to list of ids in namelist */
};
#define F90_NAMELIST_SSIZE 15	/* short size of f90 namelist structure */


/* --- F90 object info --- */

struct Cif_f90_object {
	FIELD rectype:8;	/* type of record = CIF_F90_OBJECT */
	FIELD symid:24;		/* symbol id assigned to object */
	FIELD storage:8;	/* storage type of object, see CIF_F90_ST_?? */
	FIELD storageid:24;    	/* symbol id for a named storage area (common or module) */
	FIELD symclass:8;	/* symbol class of object, see CIF_F90_SC_?? */
	FIELD charlen:24;	/* if character type, character length */
	FIELD offset:32;	/* storage offset of object */
	FIELD nlen:8;		/* number of characters in name */
	FIELD ndims:4;		/* number of dimensions */
	FIELD equiv:1;		/* appears in EQUIVALENCE statement */
	FIELD data:1;		/* appears in a DATA statement */
	FIELD save:1;		/* appears in a SAVE statement */
	FIELD imptype:1;	/* implicitly typed */
	FIELD valoffset:1;	/* valid offset present indicator */
	FIELD deftype:1;	/* default type */
	FIELD allocatable:1;	/* ALLOCATABLE */
	FIELD startype:1;	/* star typed */
	FIELD kindtype:1;	/* kind typed */
	FIELD intentin:1;	/* INTENT(IN) */
	FIELD intentout:1;	/* INTENT(OUT) */
	FIELD intentinout:1;	/* INTENT(INOUT) */
	FIELD optional:1;	/* OPTIONAL */
	FIELD pointer:1;	/* POINTER */
	FIELD priv:1;		/* PRIVATE */
	FIELD target:1;		/* TARGET */
	FIELD chartype:4;	/* type of character string: constant, expression or assumed */
	FIELD scopeid:24;	/* scope id for this object */
	FIELD atype:3;		/* array type, see CIF_AT_?? */
	FIELD peresident:1;	/* object is PE resident */
	FIELD pointee:1;	/* object is a pointee */
	FIELD arraydec:1;	/* object used in an array declaration */
	FIELD geomdec:1;	/* object used in a geometry declaration */
	FIELD init:1;		/* object initialised at declaration */
	FIELD dervid:24;	/* derived type id */
	FIELD dist:4;		/* distribution code, see CIF_DN_?? */
	FIELD localname:1;	/* local name of entry in a module */
        FIELD un1:3;
	FIELD dtype:32;		/* data type of object, see CIF_F90_DT_?? */
	FIELD geomid:24;	/* geometry id */
        FIELD un2:8;
	FIELD pointerid:24;	/* pointer id if this is a pointee */
	char *name;		/* pointer to name of object */
	struct Cif_dim *dim;	/* pointer to array of dimension items */
};
#define F90_OBJECT_SSIZE 39	/* short size of F90 object structure */



/* --- F90 miscellaneous options --- */
struct Cif_f90_misc_opts {
	FIELD rectype:8;	/* type of record = CIF_F90_MISC_OPTS */
	FIELD intlen:4;		/* length of integers */
	FIELD msglvl:4;		/* message level */
	FIELD vopt:4;		/* compilation statistics enabled */
	FIELD trunc:4;		/* truncation enabled */
	FIELD truncval:8;	/* number of bits to truncate */
	FIELD swidth:8;		/* source line width in fixed source form; 72 or 80 */
	FIELD nmsgs:8;		/* number of messages disabled */
	FIELD ncdirs:8;		/* number of cdirs disabled */
	FIELD nPdirs:8;		/* number of times the -P (include path) option was specified */
	FIELD npdirs:8;		/* number of times the -p (module path) option was specified */
	FIELD onlen:8;		/* no. of chars in object file name */
	FIELD cnlen:8;		/* no. of chars in cal file name */
	FIELD inlen:8;		/* no. of chars in inline file name */
	FIELD ciflen:8;		/* no. of chars in cif name */
	FIELD cifopts:8;	/* cif options specified, see CIF_CO_?? */
	FIELD srcform:1;	/* 0 if -f fixed (default), 1 if -f free */
	FIELD runtime:7;	/* run time checking, see CIF_RT_? */
	long *msgno;		/* pointer to messages disabled */
	char **cdirs;		/* pointer to cdirs disabled */
	char **Pdirs;		/* pointer to -P dirs specified */
	char **pdirs;		/* pointer to -p dirs specified */
	char *objname;		/* pointer to object file name */
	char *calname;		/* pointer to cal file name */
	char *inname;		/* pointer to inline file name */
	char *cifname;		/* pointer to cif name */
};
#define F90_MISC_OPTS_SSIZE 15	/* short size of f90 misc_opts structure */



struct Cif_f90_level_opts {
  FIELD optinlevel:16;		/* level qualified compiler optimization options, see CIF_OOF_?? */
  FIELD level:16;			/* level specifed for options */
};

#define OPTS_SSIZE sizeof(struct Cif_f90_level_opts)

/* --- F90 optimization options --- */
struct Cif_f90_opt_opts {
	FIELD rectype:8;	/* type of record = CIF_F90_OPT_OPTS */
	FIELD newdef:1;	/* a bug in a version of libcif didn't write the correct
			   * values in a binary cif. This is now fixed, but for
			   * upwards compatability, libcif needs to recognise
			   * the old structure. This field is for internal
			   * use only. It is set for all new binary
			   * cif's */
	FIELD noptlevels:7;  /* number of optimisation levels */
	FIELD values:16;	/* optimization values mask, see CIF_OOF_?? */
	struct Cif_f90_level_opts *lopts;  /* ptr to options that are qualified by a level */
};
#define F90_OPT_OPTS_SSIZE 4  /* short size of f90 opt_opts */


/* --- F90 begin scope --- */
struct Cif_f90_begin_scope {
	FIELD rectype:8;	/* type of record = CIF_F90_BEGIN_SCOPE */
	FIELD scopeid:24;	/* scope id that is starting */
	FIELD fid:16;		/* id of file where this scope starts */
	FIELD cpos:16;		/* char position of start of this scope */
	FIELD line:24;		/* line number of scope start */
	FIELD stype:8;		/* scope type; see CIF_SCP_?? constants */
	FIELD symid:24;		/* symid of a named scope, NULL otherwise */
	FIELD level:8;		/* nesting level for this scope, 1...  */
	FIELD parentid:24;	/* scope id of the parent, NULL if no parent for level == 1 */
};
#define F90_BEGIN_SCOPE_SSIZE 19	/* short size of begin_scope */


/* --- F90 end scope --- */
struct Cif_f90_end_scope {
	FIELD rectype:8;	/* type of record = CIF_F90_END_SCOPE */
	FIELD scopeid:24;	/* scope id of scope that is ending */
	FIELD fid:16;		/* id of file where this scope ends */
	FIELD cpos:15;		/* char position of end of this scope */
	FIELD error:1;		/* error in this scope */
	FIELD line:24;		/* line number of scope end */
};
#define F90_END_SCOPE_SSIZE 11	/* short size of end_scope */


/* --- F90 scope information --- */
struct Cif_f90_scope_info {
	FIELD rectype:8;	/* type of record = CIF_F90_SCOPE_INFO */
	FIELD scopeid:24;	/* scope id to provide information on */
	FIELD impnone:1;	/* contains 1 if this scope has an IMPLICIT NONE statement */
	FIELD doesio:1;		/* contains 1 if this scope contains any I/O statements */
	FIELD hascalls:1;	/* contains 1 if this scope contains any procedure calls */
	FIELD hascmics:1;	/* contains 1 if this scope contains any CMIC$ directives */
	FIELD numalts:12;	/* number of alternate entry points for this scope */
	long *entryids;		/* ptr to list of alternate entry ids */
};
#define F90_SCOPE_INFO_SSIZE 6	/* short size of scope_info */


/* --- F90 use module --- */
struct Cif_f90_use_module {
	FIELD rectype:8;	/* type of record = CIF_F90_USE_MODULE */
	FIELD modid:24;		/* symbol id for the module name */
	FIELD modfid:16;	/* file id where the module source appears */
	FIELD direct:1;		/* 1 if module appears in use stmt, 0 if included via use of another module */
	FIELD un1:15;		/* unused */
};
#define F90_USE_MODULE_SSIZE 8	/* short size of use_module */

	
/* --- F90 rename --- */
struct Cif_f90_rename {
	FIELD rectype:8;	/* type of record = CIF_F90_RENAME */
	FIELD modid:24;		/* symbol id for the module name */
	FIELD orignlen:8;       /* length of original name in the module */
	FIELD origmodid:24;	/* symbol id for the original module */
	FIELD nlen:8;		/* length of name in the module */
	FIELD scopeid:24;	/* scope id containing the rename clause */
	FIELD nlocalids:8;	/* number of local object id's */
	FIELD nameid:24;       	/* symbol id for the entities name in the module */
	long *localid;		/* array of local object id's */
	char *name;		/* name of the object within the module */
	char *origname;		/* origibal name when defined */
};
#define F90_RENAME_SSIZE 16	/* short size of rename */


/* --- F90 interface block--- */

#if CIF_VERSION <= 2
struct Cif_f90_int_block {
	FIELD rectype:8;	/* type of record = CIF_F90_INT_BLOCK */
	FIELD intid:24;		/* symbol id of generic name or operator, otherwise NULL */
	FIELD type:7;		/* interface block type; see CIF_IB_?? */
	FIELD priv:1;		/* private interface block */
	FIELD nlen:8;		/* name length */
	FIELD numints:16;	/* number of interfaces described in this interface block */
	FIELD scopeid:24;	/* scope id for interface block */
	long *procids;		/* ptr to list of specific procedure symbol ids */
	char *name;		/* interface block name */
};
#define F90_INT_BLOCK_SSIZE 11	/* short size of interface block */

#else  /* CIF_VERSION == 3 */

struct Cif_f90_int_block {
	FIELD rectype:8;	/* type of record = CIF_F90_INT_BLOCK */
	FIELD intid:24;		/* symbol id of generic name or operator, otherwise NULL */
	FIELD type:7;		/* interface block type; see CIF_IB_?? */
	FIELD priv:1;		/* private interface block */
	FIELD nlen:8;		/* name length */
	FIELD numints:16;	/* number of interfaces described in this interface block */
	FIELD scopeid:24;	/* scope id for interface block */
	FIELD un1:8;		/* padding to word boundary */
	FIELD moduleid:24;	/* module id where interface block occurs */
	FIELD un2:32;		/* extra padding; just in case */
	FIELD un3:32;		/*  " */
	long *procids;		/* ptr to list of specific procedure symbol ids */
	char *name;		/* interface block name */
};
#define F90_INT_BLOCK_SSIZE 23	/* short size of interface block */

struct Cif_f90_int_block_2 {
	FIELD rectype:8;	/* type of record = CIF_F90_INT_BLOCK */
	FIELD intid:24;		/* symbol id of generic name or operator, otherwise NULL */
	FIELD type:7;		/* interface block type; see CIF_IB_?? */
	FIELD priv:1;		/* private interface block */
	FIELD nlen:8;		/* name length */
	FIELD numints:16;	/* number of interfaces described in this interface block */
	FIELD scopeid:24;	/* scope id for interface block */
	long *procids;		/* ptr to list of specific procedure symbol ids */
	char *name;		/* interface block name */
};
#define F90_INT_BLOCK_SSIZE_2 11	/* short size of interface block */

#endif /* CIF_VERSION <= 2 */



/* --- F90 vectorization --- */
struct Cif_f90_vectorization {
	FIELD rectype:8;	/* type of record = CIF_F90_VECTORIZATION */

};
#define F90_VECTORIZATION_SSIZE 1	/* short size of vectorization */


#if CIF_VERSION == 2

/* --- back end nodes --- */
struct Cif_BE_node {
	FIELD	rectype:8;	/* type of record = CIF_BE_NODE */
	FIELD	block:24;	/* code block number */
	FIELD	blocklet:8;	/* code blocklet number */
	FIELD	nsuccs:4;	/* # of successor nodes */
	FIELD	nlines:4;	/* # of source lines */
	FIELD	type:7;		/* node type CIF_BE_xxx */
	FIELD	is_entry:1;	/* is entry to function */
	FIELD	subtype:8;	/* timing types */
	FIELD	app_before:8;	/* apprentice instr before blocklet */
	FIELD	app_after:8;	/* apprentice instr after  blocklet */
	FIELD	index:16;	/* index into statistic array */
	FIELD	clocks:32;	/* predicted # of clocks per pass */
	int	icnt[ CIF_IT_MAX ]; /* instruction counts */
	int	*succs;		/* array of successor code blocks */
	int	*lines;		/* array of source lines */
	char	*label;		/* func name, if CIF_TT_CALL */
};
#define BENODE_SSIZE	(16 + CIF_IT_MAX * sizeof( int )) /* short size */

#else

/* --- back end nodes --- */
struct Cif_BE_node {
	FIELD	rectype:8;	/* type of record = CIF_BE_NODE */
	FIELD	block:24;	/* code block number */
	FIELD	blocklet:8;	/* code blocklet number */
	FIELD	nsuccs:4;	/* # of successor nodes */
	FIELD	nlines:4;	/* # of source lines */
	FIELD	type:7;		/* node type CIF_BE_xxx */
	FIELD	is_entry:1;	/* is entry to function */
	FIELD	subtype:8;	/* timing types */
	FIELD	app_before:8;	/* apprentice instr before blocklet */
	FIELD	app_after:8;	/* apprentice instr after  blocklet */
	FIELD	index:16;	/* index into statistic array */
	FIELD	clocks:32;	/* predicted # of clocks per pass */
	int	icnt[ CIF_IT_MAX ]; /* instruction counts */
	int	*succs;		/* array of successor code blocks */
	int	*fid;		/* array of source fids */
	int	*lines;		/* array of source lines */
	char	*label;		/* func name, if CIF_TT_CALL */
};
#define BENODE_SSIZE	(16 + CIF_IT_MAX * sizeof( int )) /* short size */

/* --- back end nodes --- */
struct Cif_BE_node_2 {
	FIELD	rectype:8;	/* type of record = CIF_BE_NODE */
	FIELD	block:24;	/* code block number */
	FIELD	blocklet:8;	/* code blocklet number */
	FIELD	nsuccs:4;	/* # of successor nodes */
	FIELD	nlines:4;	/* # of source lines */
	FIELD	type:7;		/* node type CIF_BE_xxx */
	FIELD	is_entry:1;	/* is entry to function */
	FIELD	subtype:8;	/* timing types */
	FIELD	app_before:8;	/* apprentice instr before blocklet */
	FIELD	app_after:8;	/* apprentice instr after  blocklet */
	FIELD	index:16;	/* index into statistic array */
	FIELD	clocks:32;	/* predicted # of clocks per pass */
	int	icnt[ CIF_IT_MAX ]; /* instruction counts */
	int	*succs;		/* array of successor code blocks */
	int	*lines;		/* array of source lines */
				/* if < 0, contains line<<8 | fid */
	char	*label;		/* func name, if CIF_TT_CALL */
};
#define BENODE_SSIZE_2	(16 + CIF_IT_MAX * sizeof( int )) /* short size */

#endif /* CIF_VERSION == 2 */

struct Cif_BE_fid {
	FIELD	rectype:8;	/* type of record = CIF_BE_FID */
	FIELD	block:24;	/* code block number */
	FIELD	blocklet:8;	/* code blocklet number */
	FIELD	un1:4;		/* # of successor nodes */
	FIELD	nfid:4;		/* # of source lines */
	int	*fid;		/* array of source fids */
};
#define BEFID_SSIZE 6		/* short size */

#endif /* CIF_VERSION != 1 */


#if CIF_VERSION == 3

struct Cif_cc_type {
	FIELD	rectype:8;	/* type of record = CIF_CC_TYPE */
	FIELD	scopeid:24;	/* scope id */
	FIELD	ptype:16;	/* parent C type */
	FIELD	typeId:16;	/* C type id */
	FIELD	size:32;	/* container size in bits */
	FIELD	type:8;		/* type kind */
	FIELD	subtype:8;	/* sub type */
	FIELD	flags:8;	/* */
	FIELD	prec:8;		/* precision */
	FIELD	symid:24;	/* symbol id */
	FIELD	btype:8;	/* base type */
	FIELD	rtype:8;	/* return type */
	FIELD	nlen:8;		/* name length */
	FIELD	nmem:8;		/* # of member symid's */
	char	*name;		/* name */
	int	*mem;		/* array of symid's for members */
};
#define CCTYPE_SSIZE 23		/* short size */

struct Cif_cc_entry {
	FIELD	rectype:8;	/* type of record = CIF_CC_ENTRY */
	FIELD	symid:24;	/* symbol id of entry point */
	FIELD	linkage:8;	/* linkage */
	FIELD	scopeid:24;	/* scope id */
	FIELD	typeId:16;	/* C type id */
	FIELD	ptype:16;	/* parent C type of class, if member func */
	FIELD	attr:8;		/* misc attributes */
	FIELD	sfid:24;	/* start file id */
	FIELD	sline:24;	/* start line */
	FIELD	scol:8;		/* start column */
	FIELD	nlen:8;		/* name length */
	FIELD	efid:24;	/* end file id */
	FIELD	eline:24;	/* end line */
	FIELD	ecol:8;		/* end column */
	FIELD	fsymid:24;	/* actual function symbol id */
	FIELD	elen:8;		/* external name length */
	FIELD	nparam:8;	/* # of formal parameters */
	char	*name;		/* name */
	char	*ename;		/* external name */
	int	*param;		/* array of formal param symid's */
};
#define CCENTRY_SSIZE 33	/* short size */

struct Cif_cc_obj {
	FIELD	rectype:8;	/* type of record = CIF_CC_OBJ */
	FIELD	symid:24;	/* symbol id of entry point */
	FIELD	typeId:16;	/* C type id */
	FIELD	symcl:8;	/* symbol class, see CIF_CC_SC_?? */
	FIELD	linkage:8;	/* linkage */
	FIELD	storage:8;	/* storage class, see CIF_CC_ST_?? */
	FIELD	scopeid:24;	/* scope id */
	FIELD	offset:32;	/* offset of member within parent in bits */
	FIELD	ptype:24;	/* parent C type, or entry symid */
	FIELD	nlen:8;		/* name length */
	char	*name;		/* name */
};
#define CCOBJ_SSIZE 20		/* short size */

struct Cif_cc_subtype {
	FIELD	rectype:8;	/* type of record = CIF_CC_SUBTYPE */
	FIELD	symid:24;	/* symbol id */
	FIELD	ptype:24;	/* parent symid */
	FIELD	symkind:8;	/* symbol kind */
	FIELD	subkind:8;	/* sub type kind */
	FIELD	flags:8;	/* */
};
#define CCSUBTYPE_SSIZE 10	/* short size */

struct Cif_cc_enum {
	FIELD	rectype:8;	/* type of record = CIF_CC_ENUM */
	FIELD	symid:24;	/* symbol id */
	FIELD	typeId:16;	/* C type id */
	FIELD	nlen:8;		/* name length */
	FIELD	vlen:8;		/* value length */
	char	*name;		/* name of enum constant */
	char	*value;		/* ASCII form of constant value */
};
#define CCENUM_SSIZE 8		/* short size */

struct Cif_cc_expr {
	FIELD	rectype:8;	/* type of record = CIF_CC_EXPR */
	FIELD	exprid:24;	/* expression id */
	FIELD	type:8;		/* expression type */
	FIELD	fid:24;		/* file id */
	FIELD	line:24;	/* line number */
	FIELD	col:8;		/* column number */
	FIELD	noper:8;	/* # operands */
	int	*oper;		/* array of expression id's of operands */
};
#define CCEXPR_SSIZE 13		/* short size */

#endif

#if CIF_VERSION == 3
struct Cif_src_pos {
	FIELD rectype:8;	/* type of record = CIF_SRC_POS */
	FIELD srcid:24;		/* source id for this source position */
	FIELD kind:8;		/* kind of source position, see CIF_SRC_KIND_?? */
	FIELD psrcid:24;	/* parent source id for this source position */
	FIELD sline:24;		/* source line for the include or start of macro exp. */
	FIELD scol:8;		/* starting column for the above line
				 * For f90, first character of the file name on the
				 * INCLUDE line. For macros, this is the start column of
				 * the macro expansion */
	FIELD fid:24;		/* ID of the file in the file table */
	FIELD ecol:8;		/* end column */
	FIELD eline:24;		/* end line of the include or macro expansion */
	FIELD un1:8;		/* padding to maintin 32 boundaries */
	FIELD symid:24;		/* symbol id of the macro being expanded */
};
#define SRC_POS_SSIZE 23	/* short size of source position record */

struct Cif_orig_cmd {
	FIELD rectype:8;	/* type of record = CIF_ORIG_CMD */
	FIELD nlen:16;		/* length of the command line */
	char *name;		/* command line */
};
#define ORIG_CMD_SSIZE 3	/* short size of original command line record */
#endif /* CIF_VERSION == 3 */




#if CIF_VERSION != 1
#define CIF_MAX_SSIZE 100	/* max short size for any record, used when mapping
				   between a binary cif version 1 and an application
				   wanting a version 2 (and vice a versa) */
#endif /* CIF_VERSION != 1 */



/* --- Structure pointer casting macros --- */
#define CIFGEN(X)	((struct Cif_generic *)(X))
#define CIFCS(X)	((struct Cif_callsite *)(X))
#define CIFHDR(X)	((struct Cif_cifhdr *)(X))
#define CIFCB(X)	((struct Cif_comblk *)(X))
#define CIFCON(X)	((struct Cif_const *)(X))
#define CIFED(X)	((struct Cif_edopts *)(X))
#define CIFENTRY(X)	((struct Cif_entry *)(X))
#define CIFFILE(X)	((struct Cif_file *)(X))
#define CIFINC(X)	((struct Cif_include *)(X))
#define CIFLABEL(X)	((struct Cif_label *)(X))
#define CIFLOOP(X)	((struct Cif_loop *)(X))
#define CIFMC(X)	((struct Cif_mach_char *)(X))
#define CIFMSG(X)	((struct Cif_message *)(X))
#define CIFMO(X)	((struct Cif_misc_opts *)(X))
#define CIFNL(X)	((struct Cif_namelist *)(X))
#define CIFNMSG(X)	((struct Cif_nd_msg *)(X))
#define CIFOBJ(X)	((struct Cif_object *)(X))
#define CIFOPTOPT(X)	((struct Cif_opt_opts *)(X))
#define CIFSRC(X)	((struct Cif_srcfile *)(X))
#define CIFSUM(X)	((struct Cif_summary *)(X))
#define CIFSTMT(X)	((struct Cif_stmt_type *)(X))
#define CIFUNIT(X)	((struct Cif_unit *)(X))
#define CIFENDU(X)	((struct Cif_endunit *)(X))
#define CIFUSAGE(X)	((struct Cif_usage *)(X))
#define CIFUDIR(X)	((struct Cif_unitdir *)(X))
#define CIFFDIR(X)	((struct Cif_filedir *)(X))
#define CIFCCON(X)	((struct Cif_c_const *)(X))
#define CIFCENTRY(X)	((struct Cif_c_entry *)(X))
#define CIFCMSG(X)	((struct Cif_c_message *)(X))
#define CIFCOBJ(X)	((struct Cif_c_object *)(X))
#define CIFCOPTS(X)	((struct Cif_c_opts *)(X))
#define CIFCTAG(X)	((struct Cif_c_tag *)(X))

#if CIF_VERSION != 1
#define CIFCMSG1(X)	((struct Cif_c_message_1 *)(X))
#define CIFCENTRY1(X)	((struct Cif_c_entry_1 *)(X))

#define CIFOBJ1(X)	((struct Cif_object_1 *)(X))
#define CIFCB1(X)	((struct Cif_comblk_1 *)(X))
#define CIFMO1(X)	((struct Cif_misc_opts_1 *)(X))
#define CIFCON1(X)	((struct Cif_const_1 *)(X))
#define CIFUSAGE1(X)	((struct Cif_usage_1 *)(X))
#define CIFMC1(X)	((struct Cif_mach_char_1 *)(X))


#define CIFTRAN(X)	((struct Cif_transform *)(X))
#define CIFCDIR(X)	((struct Cif_cdir *)(X))
#define CIFCDIRDO(X)	((struct Cif_cdir_doshared *)(X))
#define CIFGEOM(X)	((struct Cif_geometry *)(X))
#define CIFCONT(X)	((struct Cif_continuation *)(X))
#define CIFF90CS(X)	((struct Cif_f90_callsite *)(X))
#define CIFF90CB(X)	((struct Cif_f90_comblk *)(X))
#define CIFF90CON(X)	((struct Cif_f90_const *)(X))
#define CIFF90ENTRY(X)	((struct Cif_f90_entry *)(X))
#define CIFF90LOOP(X)	((struct Cif_f90_loop *)(X))
#define CIFF90DTYPE(X)	((struct Cif_f90_derived_type *)(X))
#define CIFF90LABEL(X)	((struct Cif_f90_label *)(X))
#define CIFF90NL(X)	((struct Cif_f90_namelist *)(X))
#define CIFF90OBJ(X)	((struct Cif_f90_object *)(X))
#define CIFF90MO(X)	((struct Cif_f90_misc_opts *)(X))
#define CIFF90OPTOPT(X)	((struct Cif_f90_opt_opts *)(X))
#define CIFF90BS(X)	((struct Cif_f90_begin_scope *)(X))
#define CIFF90ES(X)	((struct Cif_f90_end_scope *)(X))
#define CIFF90SI(X)	((struct Cif_f90_scope_info *)(X))
#define CIFF90USE(X)	((struct Cif_f90_use_module *)(X))
#define CIFF90RN(X)	((struct Cif_f90_rename *)(X))
#define CIFF90IB(X)	((struct Cif_f90_int_block *)(X))
#define CIFF90VECT(X)	((struct Cif_f90_vectorization *)(X))
#define CIFCLDIR(X)	((struct Cif_c_lint_directive *)(X))
#define CIFCMDEF(X)	((struct Cif_c_macro_def *)(X))
#define CIFCMUDEF(X)	((struct Cif_c_macro_undef *)(X))
#define CIFCMUSE(X)	((struct Cif_c_macro_usage *)(X))
#define CIFCEEND(X)	((struct Cif_c_entry_end *)(X))
#define CIFBENODE(X)	((struct Cif_BE_node *)(X))
#define CIFBEFID(X)	((struct Cif_BE_fid *)(X))

#if CIF_VERSION >= 3
#define CIFF90IB2(X)	((struct Cif_f90_int_block_2 *)(X))
#define CIFF90DTYPE2(X)	((struct Cif_f90_derived_type_2 *)(X))
#define CIFMSG1(X)	((struct Cif_message_1 *)(X))
#define CIFFILE1(X)	((struct Cif_file_1 *)(X))
#define CIFCCTYPE(X)	((struct Cif_cc_type *)(X))
#define CIFCCENT(X)	((struct Cif_cc_entry *)(X))
#define CIFCCOBJ(X)	((struct Cif_cc_obj *)(X))
#define CIFCCSUB(X)	((struct Cif_cc_subtype *)(X))
#define CIFCCENUM(X)	((struct Cif_cc_enum *)(X))
#define CIFCCEXPR(X)	((struct Cif_cc_expr *)(X))
#define CIFSPOS(X)	((struct Cif_src_pos *)(X))
#define CIFOCMD(X)	((struct Cif_orig_cmd *)(X))
#define CIFBENODE2(X)	((struct Cif_BE_node_2 *)(X))
#endif

#endif /* CIF_VERSION != 1 */







CIF_BEGIN_DECLS
extern int Cif_Close __((int, int));
extern struct Cif_generic *Cif_Duplicate __((struct Cif_generic *));
extern char *Cif_Errstring __((int));
extern void Cif_Free __((struct Cif_generic *));
extern int Cif_Getfiledir __((int, struct Cif_filedir **));
extern int Cif_Getrecord __((int, struct Cif_generic **));
extern long Cif_Getpos __((int));
extern int Cif_Getunitdir __((int, struct Cif_unittbl *, struct Cif_unitdir **));
extern int Cif_Memmode __((int, int));
extern int Cif_Msginsert __((char *, struct Cif_generic *, char *, int));
extern int Cif_Putrecord __((int, struct Cif_generic *));

#if CIF_VERSION != 1
extern int Cif_Cifconv __((char *, char *, int *, int, int));
extern int Cif_Lines __((char *, char *, int *, int, int));
extern void Cif_ConvDir __((char *dir));

extern int Cif_CifStatus __(( ));

extern char *Cif_Filename __((int));
#endif /* CIF_VERSION != 1 */

extern char* cif_basename __((char *));
extern char *mktemp __((char *));

/* The version 1 and version 2 Cif_Open functions below should be accessed
   indirectly through Cif_Open, NOT Cif_Open_Vx */

/* Special open for version 1 applications, allows us to check if they are
   trying to open a cif greater than the library thay they were compiled
   with; ie app = v1, trying to open a v2 cif */

#if CIF_VERSION == 1
extern int Cif_Open_V1 __((char *, char *, int *, int));
#endif


/* Special open for version 2 applications, allows us to check if they are
   trying to open a cif less than the library thay they were compiled
   with; ie app = v1, trying to open a v2 cif */

#if CIF_VERSION == 2
extern int Cif_Open_V2 __((char *, char *, int *, int));
extern int Cif_Open_V2_1 __((char *, char *, int *, int, int));
extern int Cif_Lines_V2_1 __((char *, char *, int *, int, int, int));
extern int Cif_Cifconv_V2_1 __((char *, char *, int *, int, int, int));
#endif

#if CIF_VERSION == 3
extern int Cif_Open_V3 __((char *, char *, int *, int));
extern int Cif_Open_V3_1 __((char *, char *, int *, int, int));
extern int Cif_Lines_V3_1 __((char *, char *, int *, int, int, int));
extern int Cif_Cifconv_V3_1 __((char *, char *, int *, int, int, int));
#endif

extern int Cif_Recgroup __((int, struct Cif_unitdir *, int, struct Cif_generic **));
extern int Cif_Release __((int, int));
extern int Cif_Setpos __((int, long));
CIF_END_DECLS

#undef CIF_BEGIN_DECLS
#undef CIF_END_DECLS

/* --- interface routine return status values --- */
#define CIF_NOTCIF	-1	/* file is not a CIF file */
#define CIF_MAXOPENS	-2	/* Maximum number of CIF files open already */
#define CIF_NOTOPEN	-3	/* CIF file descriptor not an open file */
#define CIF_NOMEM	-4	/* problem encountered acquiring memory */
#define CIF_EOF		-5	/* end of file encountered */
#define CIF_INTERNAL	-6	/* internal error */
#define CIF_BADREQ	-7	/* the requested func can't be performed */
#define CIF_BADFORM	-8	/* the CIF file has incorrect format */
#define CIF_SYSERR	-9	/* error occurred calling a system routine */
#define CIF_EXP_VERS	-10	/* expected CIF version too large */
#define CIF_FILE_VERS	-11	/* CIF file version too large */
#if CIF_VERSION == 1
#define CIF_MAXERROR	-11	/* "largest" CIF error status */
#else
#define CIF_EXP_VERS2	-12	/* CIF file version too small (application is compiled
				 * including the v2 cif definitions, but tries to
				 * open a cif as v1
				 */
#define CIF_SUBVER	-13	/* cif sub-version number incompatability */
#define CIF_MAXERROR_1	-11	/* version 1 "largest" CIF error status */
#define CIF_MAXERROR	-13	/* "largest" CIF error status */
#endif /* CIF_VERSION == 1 */

/* --- special interface values --- */
#define CIF_FIRST_RECORD -1	/* special start_of_file indicator for
				 * Cif_Setpos */

#undef FIELD

#endif	/* !_CIF_H */


