//-*-c++-*-
// ====================================================================
// ====================================================================
//
// Module: opt_bool.cxx
// $Revision: 1.1.1.1 $
// $Date: 2005/10/21 19:00:00 $
// $Author: marcel $
// $Source: /proj/osprey/CVS/open64/osprey1.0/be/opt/opt_bool.cxx,v $
//
// ====================================================================
//
// Copyright (C) 2000, 2001 Silicon Graphics, Inc.  All Rights Reserved.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of version 2 of the GNU General Public License as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it would be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
//
// Further, this software is distributed without any warranty that it
// is free of the rightful claim of any third person regarding
// infringement  or the like.  Any license provided herein, whether
// implied or otherwise, applies only to this software file.  Patent
// licenses, if any, provided herein do not apply to combinations of
// this program with other software, or any other product whatsoever.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write the Free Software Foundation,
// Inc., 59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
//
// Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
// Mountain View, CA 94043, or:
//
// http://www.sgi.com
//
// For further information regarding this notice, see:
//
// http://oss.sgi.com/projects/GenInfo/NoticeExplan
//
// ====================================================================
//
// Description:
//
//  Simplify bool expressions using predicates.
//  e.g., some of the predicates are generated by IVR.
//
// ====================================================================
// ====================================================================


#ifdef USE_PCH
#include "opt_pch.h"
#endif // USE_PCH
#pragma hdrstop


#include "opt_transform.h"


struct BOOL_SIMP : public NULL_TRANSFORM {
  const char *Name() const { return "Boolean simp"; }
  CODEREP *Apply_cr(CODEREP *cr, bool is_mu, STMTREP *stmt, BB_NODE *bb, CODEMAP *htable) const 
  {
    if (is_mu) return NULL;
    if (cr->Kind() != CK_OP) return NULL;
    
    if (OPCODE_is_compare(cr->Op()) ||
	OPCODE_operator(cr->Op()) == OPR_MAX) {

      BB_LOOP *loop = bb->Innermost();
      for (loop = bb->Innermost(); loop != NULL; loop = loop->Parent()) {
	CODEREP *entry_test = loop->Entry_test();
	if (entry_test == NULL) continue;
      
	// use the BB_LOOP::Entry_test() to simplify the condition
	if (OPCODE_is_compare(cr->Op()) && 
	    bb->Innermost()->Entry_test() == cr) {
	  return htable->Add_const(MTYPE_I4, 1);   // TRUE
      
	} else if (OPCODE_operator(cr->Op()) == OPR_MAX) {
	  switch (OPCODE_operator(entry_test->Op())) {
	  case OPR_GT:
	  case OPR_GE:
	    if ((entry_test->Opnd(0) == cr->Opnd(0) &&
		 entry_test->Opnd(1) == cr->Opnd(1)) ||
		(entry_test->Opnd(0) == cr->Opnd(1) &&
		 entry_test->Opnd(1) == cr->Opnd(0)))
	      return entry_test->Opnd(0);
	    break;
	  case OPR_LE:
	  case OPR_LT:
	    if ((entry_test->Opnd(0) == cr->Opnd(0) &&
		 entry_test->Opnd(1) == cr->Opnd(1)) ||
		(entry_test->Opnd(0) == cr->Opnd(1) &&
		 entry_test->Opnd(1) == cr->Opnd(0)))
	      return entry_test->Opnd(1);
	    break;
	  }
	}
      }
    }
    return NULL;
  }

  // Setup control which combinations are legal
  void Setup(PER_BB_CACHE *, DONT_TRACK_CUR_VERSION *) {}
};


struct GVN : public NULL_TRANSFORM {
  typedef UPDATE<SUBSTITUE, PER_SR_CACHE, DONT_TRACK_CUR_VERSION> UPDATE_GVN_SUB;  

  MEM_POOL  _mem_pool;
  STMTREP **_stmt;
  CODEMAP  *_htable;
  OPT_STAB *_sym;
  COMP_UNIT *_cu;
  SUBSTITUE gvn_sub;
  mutable UPDATE_GVN_SUB  update_gvn_sub;    // 7.2 bug?  Why needs mutable?
  const char *Name() const { return "GVN"; }
  
  CODEREP *Apply_cr(CODEREP *cr, bool is_mu, STMTREP *stmt, BB_NODE *bb, CODEMAP *htable) const 
  {
    if (cr->Kind() != CK_OP) return NULL;
    if (is_mu) return NULL;
    INT32 id = cr->Coderep_id();
    if (_stmt[id] && _stmt[id]->Bb()->Dominates(bb)) {
      MTYPE dtype = cr->Dtyp();
      IDTYPE aux_id = _sym->Create_preg(dtype, "crxxx", NULL);
      CODEREP *newcr = _htable->Add_def
	(aux_id, 1, NULL, dtype, dtype, _sym->St_ofst(aux_id),
	 ST_type(MTYPE_To_PREG(dtype)), 0, TRUE);

      // generate the save statement
      STMTREP *savestmt;
      savestmt = CXX_NEW(STMTREP, _htable->Mem_pool());
      savestmt->Init( newcr, cr,
		      OPCODE_make_op(OPR_STID, MTYPE_V, newcr->Dsctyp()));
      savestmt->Set_chi_list(NULL);
      newcr->Set_defstmt(savestmt);
      savestmt->Set_bb( _stmt[id]->Bb() );
      savestmt->Set_linenum( _stmt[id]->Linenum() );
      savestmt->Set_live_stmt();
      bb->Stmtlist()->Insert_Before(savestmt, _stmt[id]);

      update_gvn_sub._trans->Init(cr, newcr);
      update_gvn_sub.Process_SR(_stmt[id], _stmt[id]->Bb());

      return newcr;
    } else {
      _stmt[id] = stmt;
      return NULL;
    }
  }

  void Setup(PER_PU_CACHE *, DONT_TRACK_CUR_VERSION *) {}

  GVN(COMP_UNIT *cu, BOOL trace):
    _cu(cu),
    _htable(cu->Htable()),
    _sym(cu->Opt_stab()),
    gvn_sub(),
    update_gvn_sub(cu, &gvn_sub, trace)
  {
    OPT_POOL_Initialize(&_mem_pool, "Current version pool", FALSE, 0);
    OPT_POOL_Push(&_mem_pool, IVR_DUMP_FLAG); 
    _stmt = (STMTREP **) 
      CXX_NEW_ARRAY(STMTREP *, cu->Htable()->Coderep_id_cnt(), &_mem_pool);
    for (INT32 i = 0; i < cu->Htable()->Coderep_id_cnt(); i++) 
      _stmt[i] = NULL;
  }
  ~GVN() {
    OPT_POOL_Pop(&_mem_pool, 0); 
    OPT_POOL_Delete(&_mem_pool, 0);
  }
};


struct AGGR_COPY : public NULL_TRANSFORM {
  TRACK_CUR_VERSION  *cur_ver;
const  char  *Name() const { return "AGGR_COPY"; }
  
  CODEREP *Apply_cr(CODEREP *cr, bool is_mu, STMTREP *stmt, BB_NODE *, CODEMAP *htable) const
  {
    if (is_mu) return NULL;
    if (cr->Kind() == CK_VAR &&
	!cr->Is_flag_set((CR_FLAG)(CF_DEF_BY_PHI|CF_DEF_BY_CHI)) &&
	cr->Defstmt() != NULL &&
	is_current_version(cur_ver, cr->Defstmt()->Rhs()))
      return cr->Defstmt()->Rhs();
    return NULL;
  }

  void Setup(PER_PU_CACHE *, TRACK_CUR_VERSION *ver) {
    cur_ver = ver;
  }
};




void
Simplify_bool_expr(COMP_UNIT *cu)
{

  {
    BOOL_SIMP bool_simp;
    UPDATE<BOOL_SIMP, PER_BB_CACHE> 
      UPDATE_bool_simp(cu, &bool_simp, Get_Trace(TP_WOPT2, BOOL_SIMP_FLAG) );
    UPDATE_bool_simp.Process_PU();

    if (Get_Trace (TP_WOPT2, BOOL_SIMP_FLAG)) {
      fprintf (TFile, "%sDump after Boolean Simplification\n%s", DBar, DBar );
      cu->Cfg()->Print (TFile);
    }
  }

}


