/*
 * Copyright (c) 2006. QLogic Corporation.  All rights reserved.
 *
 * Unpublished -- rights reserved under the copyright laws of the United
 * States. USE OF A COPYRIGHT NOTICE DOES NOT IMPLY PUBLICATION OR
 * DISCLOSURE. THIS SOFTWARE CONTAINS CONFIDENTIAL INFORMATION AND TRADE
 * SECRETS OF QLOGIC CORPORATION. USE, DISCLOSURE, OR REPRODUCTION IS
 * PROHIBITED WITHOUT THE PRIOR EXPRESS WRITTEN PERMISSION OF QLOGIC,
 * CORPORATION.
 *
 * U.S. Government Restricted Rights:
 * The Software is a "commercial item," as that term is defined at 48
 * C.F.R. 2.101 (OCT 1995), consisting of "commercial computer software"
 * and "commercial computer software documentation," as such terms are used
 * in 48 C.F.R. 12.212 (SEPT 1995).  Consistent with 48 C.F.R. 12.212 and
 * 48 C.F.R. 227-7202-1 through 227-7202-4 (JUNE 1995), all U.S. Government
 * End Users acquire the Software with only those rights set forth in the
 * accompanying license agreement. QLogic Corporation, 26650 Aliso Viejo 
 * Parkway, Aliso Viejo, CA 92656.
 */

/*
 * Use the definitions in math.h to generate on stdout a set of cpp "define"s
 * for the symbols associated with ISO C99 "fpclassify", suitable for inclusion
 * by Fortran (which would choke on C syntax if it simply included "math.h".)
 *
 * Also generate a symbol "FP_NANS" whose value is one greater than the biggest
 * of the "fpclassify" symbols.
 *
 * Similarly, generate cpp "define"s for the rounding-mode and exception
 * macros in fenv.h, and for the size of fenv_t.
 *
 * Finally, generate cpp "define"s for the IO EOF and EOR codes needed by
 * iso_fortran_env.F90.
 */
#include <math.h>
#include <fenv.h>
#include <stdio.h>
#include <liberrno.h>

#define MAX(a,b) (((a) > (b)) ? (a) : (b))

static void gen(char *s, int i) {
  printf("#define %s %d\n", s, i);
  }

int main(int argc, char **argv) {

  printf("/* Generated by gen_ieee_cpp_macros program - do not edit */\n");

  gen("FP_NAN", FP_NAN);
  gen("FP_INFINITE", FP_INFINITE);
  gen("FP_ZERO", FP_ZERO);
  gen("FP_SUBNORMAL", FP_SUBNORMAL);
  gen("FP_NORMAL", FP_NORMAL);

  int fp_nans = 1 +
    MAX(FP_NAN,
      MAX(FP_INFINITE,
	MAX(FP_ZERO,
	  MAX(FP_SUBNORMAL,
	    FP_NORMAL))));

  gen("FP_NANS", fp_nans);
  gen("FP_OTHER", fp_nans + 1);

  gen("FE_DOWNWARD", FE_DOWNWARD);
  gen("FE_TONEAREST", FE_TONEAREST);
  gen("FE_TOWARDZERO", FE_TOWARDZERO);
  gen("FE_UPWARD", FE_UPWARD);

  gen("FE_DIVBYZERO", FE_DIVBYZERO);
  gen("FE_INEXACT", FE_INEXACT);
  gen("FE_INVALID", FE_INVALID);
  gen("FE_OVERFLOW", FE_OVERFLOW);
  gen("FE_UNDERFLOW", FE_UNDERFLOW);
  gen("FE_ALL_EXCEPT", FE_ALL_EXCEPT);

  gen("SIZEOF_FENV_T", sizeof(fenv_t));

  gen("FERDENDR", FERDENDR);
  gen("FEEORCND", FEEORCND);

  return 0;
  }
