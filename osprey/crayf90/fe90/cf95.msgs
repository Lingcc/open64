$
$  Copyright (C) 2007, 2008. PathScale, LLC. All Rights Reserved.
$
$  Copyright (C) 2006, 2007. QLogic Corporation. All Rights Reserved.
$
$  Copyright 2003, 2004, 2005, 2006 PathScale, Inc.  All Rights Reserved.
$
$  Copyright (C) 2000, 2001 Silicon Graphics, Inc.  All Rights Reserved.
$
$  This program is free software; you can redistribute it and/or modify it
$  under the terms of version 2 of the GNU General Public License as
$  published by the Free Software Foundation.
$
$  This program is distributed in the hope that it would be useful, but
$  WITHOUT ANY WARRANTY; without even the implied warranty of
$  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
$
$  Further, this software is distributed without any warranty that it is
$  free of the rightful claim of any third person regarding infringement 
$  or the like.  Any license provided herein, whether implied or 
$  otherwise, applies only to this software file.  Patent licenses, if 
$  any, provided herein do not apply to combinations of this program with 
$  other software, or any other product whatsoever.  
$
$  You should have received a copy of the GNU General Public License along
$  with this program; if not, write the Free Software Foundation, Inc., 59
$  Temple Place - Suite 330, Boston MA 02111-1307, USA.
$
$  Contact information:  Silicon Graphics, Inc., 1600 Amphitheatre Pky,
$  Mountain View, CA 94043, or:
$
$  http://www.sgi.com
$
$  For further information regarding this notice, see:
$
$  http://oss.sgi.com/projects/GenInfo/NoticeExplan
$
$
$ |**************************************************************************|
$ |**                                                                      **|
$ |**                     MESSAGE AND EXPLANATION FILE                     **|
$ |**                                                                      **|
$ |**************************************************************************|
$ \**************************************************************************/
$
$
$ MESSAGE GROUPINGS:
$   0000 - 1999 : Front-end messages.  There is no particular order.
$                 The largest front-end message number is recorded in
$                 MAX_FE_MSG in messages.m.  If the front-end message number
$                 range changes, MAX_FE_MSG must also be updated.
$   2000 - 2099 : arith.a (folder) messages.  The largest folder message 
$                 number is recorded in MAX_FOLDER_MSG in messages.m.  If the 
$                 folder message number range changes, MAX_FOLDER_MSG must 
$                 also be updated.
$   2100 - 2499 : f90 command.
$   2500 - 4999 : Currently unused.
$   5000 - 5999 : Reserved for lint (will not be used by compilers).
$   6000 - 7999 : PDGCS messages.
$   8000 - 9999 : Compiler back-end (CCG, MPPCG, CMCS) messages.
$
$ Since message texts do not reflect the message level, a comment defining 
$ the level should precede each message entry.
$ --------------------------------------------------------------------------
$
$$ DO NOT REMOVE THIS LINE, psm USES IT TO FIND THE FIRST MESSAGE
$
$ Internal : 0001
$msg  0001 Message number %d, exceeds allowed range.
$nexp 0001
Internal : Message number %d, exceeds allowed range.
.PP
The message number exceeds the allowed maximum size.  It is either larger
than the maximum allowed message number for the front end or is less than 1.
.PP
This message should never be generated.  There is something wrong with the
message catalog or installation of the compiler.  Please notify your product
support organization with this error message number and any supporting
information.  This message does not indicate a problem with your code.
You may be able to change your code, so that the compiler does not try to
issue this message.
.ME
$
$ Internal : 0002
$msg  0002 Message level %d, is out of range.
$nexp 0002
Internal : Message level %d, is out of range.
.PP
The message level exceeds the allowed range.  It is not in the valid range
of message levels for the message system.
.PP
This message should never be generated.  There is something wrong with the
message catalog or installation of the compiler.  Please notify your product
support organization with this error message number and any supporting
information.  This message does not indicate a problem with your code.
You may be able to change your code, so that the compiler does not try to
issue this message.
.ME
$
$ Internal : 0003
$msg  0003 Message system failed trying to issue message %d
$nexp 0003
Internal : Message system failed trying to issue message %d
.PP
The message system was unable to issue the message indicated by the message
number included in this message.  This internal error can arise for a number
of possible reasons, including:

  * The message number is not in the message system messages file.

    It is probable that either the message number does not exist in the
    message catalog or the message catalog has been corrupted.

  * The message catalog is out of date or does not match the release of
    the compiler that tried to issue the message. 

  * The \*CNLSPATH\fR environment variable is not set correctly.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 0004
$msg  0004 The MODULE PROCEDURE statement is only allowed in a generic interface block.
$nexp 0004
Error : The MODULE PROCEDURE statement is only allowed in a generic interface block.
.PP
A \*CMODULE PROCEDURE\fR statement can
only be specified in an interface block that has a \fIgeneric_spec\fR.
The compiler found
a \*CMODULE PROCEDURE\fR statement in an interface block that does not have a generic
specification.
.ME
$
$ Error : 0005
$msg  0005 The %s statement is out of order.
$nexp 0005
Error : The %s statement is out of order.
.PP
The current statement violates the Fortran standard statement ordering rules.
See the \fICFortran Language Reference Manual\fR, publication SR-3902, for details.
.ME
$
$ Error : 0006
$msg  0006 A keyword or identifier must follow the label or construct name.
$nexp 0006
Error : A keyword or identifier must follow the label or construct name.
.PP
The compiler has found a label or construct name.  A keyword or identifier 
must follow the label or construct name.  The following examples may clarify this.
.CS
10          ! This is an illegal statement
10 CONTINUE ! This is legal; a keyword follows 10
.CE
.ME
$
$ Error : 0007
$msg  0007 A construct name is not allowed on a %s statement.
$nexp 0007
Error : A construct name is not allowed on a %s statement.
.PP
A construct name can only appear on an \*CIF-THEN\fR statement, a \*CDO\fR statement, or
a \*CSELECT CASE\fR statement.  This error is generated when a construct name is
found on a statement other than those listed above.
.ME
$
$ Error : 0008
$msg  0008 The %s statement must precede all component definitions in derived type definition "%s".
$nexp 0008
Error : The %s statement must precede all component definitions in derived type definition "%s".
.PP
This \*CPRIVATE\fR or \*CSEQUENCE\fR statement follows one or more component definitions
in the  derived type definition.  The \*CPRIVATE\fR and \*CSEQUENCE\fR statements
must precede any component definitions.
.ME
$
$ Internal : 0009
$msg  0009 No forward reference entries exist for label %s even though it is undefined.
$nexp 0009
Internal : No forward reference entries exist for label %s even though it is undefined.
.PP
If an attribute entry exists for the label then it must be referenced in
the scoping unit.  If it was referenced but was never defined, there must be at
least one forward reference entry to represent the unresolved forward reference.
However, the forward reference chain for the label is empty.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0010
$msg  0010 Dummy argument "%s" is already defined in this argument list.
$nexp 0010
Error : Dummy argument "%s" is already defined in this argument list.
.PP
The name of a dummy argument appears more than once in the argument list on a
\*CFUNCTION\fR, \*CSUBROUTINE\fR, \*CENTRY\fR or statement function definition statement. 
.ME
$
$ Log_Warning : 0011
$msg  0011 The line size option is ignored because free source form is in effect.
$nexp 0011
Log_Warning : The line size option is ignored because free source form is in effect.
.PP
The line size option is ignored when the source form is set to \*Cfree\fR, because
the line may contain up to 132 characters.  With fixed source form the line
size option is valid, because the Fortran standard limits the line to 72
characters.  The option allows the line length to be extended to 80 characters.
.ME
$
$ Internal : 0012
$msg  0012 %s underflow.
$nexp 0012
Internal : %s underflow.
.PP
This message is generated from \*CPOP_SRC\fR macro in \*Csrc_input.m\fR.
The source stack has underflowed.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0013
$msg  0013 The Fortran standard requires multiple entry point function results "%s" and "%s" to both be default intrinsic types.
$nexp 0013
Ansi : The Fortran standard requires multiple entry point function results "%s" and "%s" to both be default intrinsic types.
.PP
A multiple entry point function (a function with one or more \*CENTRY\fR 
statements) can have entry points which return results of differing 
declared types only if all entry points return results which are scalar
and of type default real, default logical, double precision real, default
complex, or default integer.  If the entry point has the \*CPOINTER\fR attribute,
all entry points must be the same type and be pointers. The compiler allows
the entry points with the same declared types to have different kind parameters.
.ME
$
$ Limit : 0014
$msg  0014 Insufficient memory is available for compilation to continue.
$nexp 0014
Limit : Insufficient memory is available for compilation to continue.
.PP
The compiler ran out of memory during compilation of the program.  Check
with your product support organization and request more memory for the job.
Remember that program compilation may be only one of several processes
executing in the job space.
.ME
$
$ Error : 0015
$msg  0015 The %s statement is not allowed in a block data program unit.
$nexp 0015
Error : The %s statement is not allowed in a block data program unit.
.PP
Derived type definitions, type declaration statement and
the following statements are allowed in a block data program unit:
.CS
	COMMON
	DATA
	DIMENSION
	END BLOCK DATA
	EQUIVALENCE
	IMPLICIT
	IMPLICIT NONE
	INTRINSIC
	PARAMETER
	POINTER
	SAVE
	TARGET
	TASK COMMON
	USE
.CE
.PP
\fRThe \*CSEQUENCE\fR statement must be specified in a derived type definition
to be in a block data program unit.
.ME
$
$ Error : 0016
$msg  0016 The %s statement is not allowed in a main program unit.
$nexp 0016
Error : The %s statement is not allowed in a main program unit.
.PP
The following statements are not allowed in a main program unit:
.CS
	ENTRY
	INTENT
	OPTIONAL
	PRIVATE
	PUBLIC
	RETURN
.CE
.PP
These statements must be inside a construct or contained scoping unit to be in a main program unit:
.BL
\*CSEQUENCE\fR, \*CEND TYPE \fRin a derived type definition
.BL
\*CMODULE PROCEDURE \fRin a generic interface block
.BL
\*CELSE\fR, \*CELSE IF\fR, \*CEND IF\fR in an \*CIF\fR construct 
.BL
\*CCASE\fR, \*CEND SELECT\fR in a \*CCASE\fR construct 
.BL
\*CELSEWHERE\fR, \*CEND WHERE\fR in a \*CWHERE\fR construct 
.BL
\*CCYCLE\fR, \*CEXIT\fR, \*CEND DO\fR in a \*CDO\fR construct  
.BL
\*CFUNCTION\fR, \*CSUBROUTINE\fR in an interface block
.BL
\*CEND FUNCTION\fR in an interface body 
.BL
\*CEND SUBROUTINE\fR in an interface body 
.BL
\*CEND INTERFACE \fR in an interface block
.ME
$
$ Error : 0017
$msg  0017 Cannot open "%s" file.  It is needed for debugging or tracing.
$nexp 0017
Error : Cannot open "%s" file.  It is needed for debugging or tracing.
.PP
The compiler cannot open the debug file or the trace file.
.ME
$
$ Error : 0018
$msg  0018 The %s statement must not follow a MODULE PROCEDURE statement in a generic interface block.
$nexp 0018
Error : The %s statement must not follow a MODULE PROCEDURE statement in a generic interface block.
.PP
The syntax for an interface block is:
.CS
        interface_stmt
          [interface_body]...
          [module_procedure_stmt]...
        end_interface_stmt
.CE
.ME
$
$ Error : 0019
$msg  0019 The %s statement is not allowed in a module.
$nexp 0019
Error : The %s statement is not allowed in a module.
.PP
Derived-type definitions, type declaration statements and the
following statements are allowed in a module (before the \*CEND MODULE\fR or
the \*CCONTAINS\fR statement):
.CS
	ALLOCATABLE
	COMMON
	DATA
	DIMENSION
	EQUIVALENCE
	EXTERNAL
	IMPLICIT
	IMPLICIT NONE
	INTERFACE
	INTRINSIC
	NAMELIST
	PARAMETER
	POINTER
	PUBLIC
	PRIVATE
	SAVE
	TARGET
	USE
.CE
.PP
\fRThese statements must be in an interface block or contained scoping unit to be in a module program unit.
.BL
\*CMODULE PROCEDURE\fR in a generic interface block
.BL
\*CSEQUENCE\fR, \*CEND TYPE\fR in a derived-type definition
.BL
\*CFUNCTION\fR, \*CSUBROUTINE\fR, \*CEND FUNCTION\fR, \*CEND SUBROUTINE\fR, \*CEND INTERFACE\fR
in an interface block
.ME
$
$ Ansi : 0020
$msg  0020 The use of DOUBLE COMPLEX is an extension to the Fortran standard.
$nexp 0020
Ansi : The use of DOUBLE COMPLEX is an extension to the Fortran standard.
.PP
The \*CDOUBLE COMPLEX\fR statement is not part of the Fortran standard.
.ME
$
$ Error : 0021
$msg  0021 The type attributes for entry points "%s" and "%s" conflict.
$nexp 0021
Error : The type attributes for entry points "%s" and "%s" conflict.
.PP
If the result of any entry point of a multiple entry function (a function with
one or more \*CENTRY\fR statements) is of type character, or a derived type 
then all entry points in that function must return a result that is of the same
type.  If the function result is of type character, all entry points must
return a result with the same declared character length.  If the result is of
a derived type, then all entries must be the same derived type.
.ME
$
$ Ansi : 0022
$msg  0022 The type of function result "%s" must be a default intrinsic type if it does not match the type of other entry points.
$nexp 0022
Ansi : The type of function result "%s" must be a default intrinsic type if it does not match the type of other entry points.
.PP
A multiple entry point function (a function with one or more \*CENTRY\fR 
statements) may have entry points which return results of differing
declared types only if all entry points return  results which are scalar
and of type default real, default logical, double precision real, default
complex, or default integer.  If the entry point has the \*CPOINTER\fR attribute,
all entry points must be of the same type and have the \*CPOINTER\fR attribute.
.PP
The compiler allows the mix of default and non-default real, logical, double 
precision, complex and integer.
.ME
$
$ Error : 0023
$msg  0023 Label %s is not defined in this scoping unit.
$nexp 0023
Error : Label %s is not defined in this scoping unit.
.PP
When a statement label is referenced, the label must be the statement label of a
branch target statement that appears in the same scoping unit as the label 
reference.  For example, if the following \*CGO TO\fR statement appears in a subprogram,
label 10 must be defined in the same subprogram.
.CS
     GO TO 10
.CE
.ME
$
$ Error : 0024
$msg  0024 The character constant "%s", for the I/O control information list item %s, is not allowed.
$nexp 0024
Error : The character constant "%s", for the I/O control information list item %s, is not allowed.
.PP
Many I/O control information list items allow only a limited set of valid
character constants.  A character constant was encountered that is not
valid for this control list item.  Following are the I/O control items and
their valid character constants:
.CS
OPEN I/O control                         
 list item                   Character constants
 STATUS    OLD, NEW, SCRATCH, REPLACE, UNKNOWN
 ACCESS    SEQUENTIAL, DIRECT
 FORM      FORMATTED, UNFORMATTED
 BLANK     NULL, ZERO
 POSITION  ASIS, REWIND, APPEND
 ACTION    READ, WRITE, READWRITE
 DELIM     APOSTROPHE, QUOTE, NONE
 PAD       YES, NO
.CE
.PP
For the \*CCLOSE\fR I/O control list item \*CSTATUS\fR, the 
allowed character constants are \*CKEEP\fR and \*CDELETE\fR.
.PP
For the \*CREAD/WRITE\fR I/O control list item \*CADVANCE\fR, 
the allowed character constants are \*CYES\fR and \*CNO\fR.
.ME
$
$ Error : 0025
$msg  0025 This statement is not allowed in a derived type definition.
$nexp 0025
Error : This statement is not allowed in a derived type definition.
.PP
The only statements allowed in a derived type definition are \*CPRIVATE\fR, \*CSEQUENCE\fR
and the component definition statement.  \*CPRIVATE\fR is only allowed if the
derived type definition is in a module program unit.
.ME
$
$ Error : 0026
$msg  0026 The %s statement is not allowed in an interface block; expected SUBROUTINE, FUNCTION, MODULE PROCEDURE or END statement.
$nexp 0026
Error : The %s statement is not allowed in an interface block; expected SUBROUTINE, FUNCTION, MODULE PROCEDURE or END statement.
.PP
The only statements allowed in an interface block are \*CFUNCTION\fR,
\*CSUBROUTINE\fR, \*CMODULE PROCEDURE\fR, and \*CEND INTERFACE\fR.
\*CFUNCTION\fR and \*CSUBROUTINE\fR start an interface body.
\*CEND INTERFACE\fR ends the interface block.
\*CMODULE PROCEDURE\fR can be specified if the interface block is a generic
interface.  A generic interface contains a list of module procedures that can
be referenced with the generic name.
.ME
$
$ Error : 0027
$msg  0027 Function entry "%s" has result name "%s".  It must be used when declaring the result to be an array.
$nexp 0027
Error : Function entry "%s" has result name "%s".  It must be used when declaring the result to be an array.
.PP
If a function has a result name, the result name must be used when declaring
the result to be an array.
.ME
$
$ Error : 0028
$msg  0028 A trailing ")" is missing in the program string.
$nexp 0028
Error : A trailing ")" is missing in the program string.
.PP
The parentheses groups do not match in the optional parenthesized list that can appear on 
the \*CPROGRAM\fR statement.
.ME
$
$ Error : 0029
$msg  0029 The maximum number of unnamed block data program units is 26 and has been exceeded.
$nexp 0029
Error : The maximum number of unnamed block data program units is 26 and has been exceeded.
.PP
The Fortran standard limits unnamed block data program units to 1 in an
executable program.  However, the compiler extends this limit to 26.  The
compiler detected more than 26 unnamed block data program units.
.ME
$
$ Ansi : 0030
$msg  0030 The Fortran standard does not allow more than one unnamed BLOCK DATA program unit.
$nexp 0030
Ansi : The Fortran standard does not allow more than one unnamed BLOCK DATA program unit.
.PP
The Fortran standard does not allow more than one unnamed block data 
program unit.
.ME
$
$ Ansi : 0031
$msg  0031 Arguments to a PROGRAM statement are an extension to the Fortran standard.
$nexp 0031
Ansi : Arguments to a PROGRAM statement are an extension to the Fortran standard.
.PP
A \*CPROGRAM\fR statement contains an argument list enclosed in parentheses.  The
Fortran standard does not provide for actual arguments to a main program.
.ME
$
$ Error : 0032
$msg  0032 The type specification "CHARACTER*(*)" is not allowed in an IMPLICIT statement.
$nexp 0032
Error : The type specification "CHARACTER*(*)" is not allowed in an IMPLICIT statement.
.PP
Assumed-length character type declarations are not allowed in \*CIMPLICIT\fR statements.
.ME
$
$ Error : 0033
$msg  0033 If the component is being typed as the derived type being defined, it must have the POINTER attribute.
$nexp 0033
Error : If the component is being typed as the derived type being defined, it must have the POINTER attribute.
.PP
The Fortran standard requires that a component of a derived type may not be
declared to be of the derived type, unless it is a pointer.  For example:
.CS
      TYPE BB
        TYPE(BB) :: A
      END TYPE
.CE
.PP
Component \*CA\fR is illegal, because it is defined as the type being declared (\*CBB\fR).
.CS
      TYPE ZZ
        TYPE(ZZ), POINTER :: A
      END TYPE 
.CE
.PP
Component \*CA\fR is legal here, because it is a pointer to a structure of the type being declared (\*CZZ\fR).
.ME
$
$ Internal : 0034
$msg  0034 The name or attribute index is not valid.  It is less than 0 or greater than the table index.
$nexp 0034
Internal : The name or attribute index is not valid.  It is less than 0 or greater than the table index.
.PP
The local name table index or attribute table index is not valid.  It is
either less than zero or greater than the last table index entered.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0035
$msg  0035 The character length of "%s" has exceeded the maximum length of %d.
$nexp 0035
Error : The character length of "%s" has exceeded the maximum length of %d.
.PP
The maximum character length was exceeded.
.ME
$
$ Error : 0036
$msg  0036 Function entry "%s" has result name "%s", which must be used when declaring the result to be a pointer.
$nexp 0036
Error : Function entry "%s" has result name "%s", which must be used when declaring the result to be a pointer.
.PP
If a function has a result name, the result name must be used when declaring
the result to be a pointer.
.ME
$
$ Ansi : 0037
$msg  0037 Input lines greater than 72 characters long are an extension to the Fortran standard.
$nexp 0037
Ansi : Input lines greater than 72 characters long are an extension to the Fortran standard.
.PP
The compiler detected an input line greater than 72 characters.  The Fortran
standard does not provide for input lines greater than 72 characters long
in fixed source form.
.ME
$
$ Internal : 0038
$msg  0038 This character is not valid.  Expected keyword DO following failed parse of type spec DOUBLE.
$nexp 0038
Internal : This character is not valid.  Expected keyword DO following failed parse of type spec DOUBLE.
.PP
This error is generated when \*CDO\fR is not encountered as expected.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0039
$msg  0039 Namelist group name "%s" was referenced in an I/O statement.  It must not be specified in this NAMELIST statement.
$nexp 0039
Error : Namelist group name "%s" was referenced in an I/O statement.  It must not be specified in this NAMELIST statement.
.PP
Namelist statements may be mixed in with executable statements.  However, all
definitions of a specific namelist group must occur before the first reference to the
namelist group by an I/O statement.
.ME
$
$ Error : 0040
$msg  0040 If this main program has no PROGRAM statement specified, then no name can be specified on the END PROGRAM statement.
$nexp 0040
Error : If this main program has no PROGRAM statement specified, then no name can be specified on the END PROGRAM statement.
.PP
The compiler detected an \*CEND PROGRAM\fR statement followed by a name for 
a program unit.  This program unit has no \*CPROGRAM\fR statement
and therefore no name.
.ME
$
$ Error : 0041
$msg  0041 The %s statement must only be specified once for derived type definition "%s".
$nexp 0041
Error : The %s statement must only be specified once for derived type definition "%s".
.PP
The \*CPRIVATE\fR and \*CSEQUENCE\fR statements must only be specified once in a derived type definition.
.ME
$
$ Internal : 0042
$msg  0042 Attribute entry %d has a variant problem with field %s.
$nexp 0042
Internal : Attribute entry %d has a variant problem with field %s.
.PP
The compiler detected a variant problem.  A field is being accessed in the
attribute table, but the wrong variant is active.  The field may actually be
in the attribute auxiliary table, but it is checking the attribute table
variant.  In general whether the field actually resides in the attribute
table or the attribute auxiliary table should make no difference in resolving
the problem.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0043
$msg  0043 Only one %s statement is allowed in each %s construct.
$nexp 0043
Error : Only one %s statement is allowed in each %s construct.
.PP
Each \*CIF\fR construct must only have one \*CELSE\fR block.  Each \*CWHERE\fR construct must only
have one \*CELSEWHERE\fR block.  The compiler detected more than one \*CELSE\fR
or \*CELSE WHERE\fR statement in the \*CIF\fR or \*CWHERE\fR construct.
.ME
$
$ Error : 0044
$msg  0044 The entry point name of the host, "%s", must not be redefined in an interface body.
$nexp 0044
Error : The entry point name of the host, "%s", must not be redefined in an interface body.
.PP
Within an external subprogram one of the entry point names was specified
in an explicit interface in a contained subprogram.  Entry point names
already have explicit interfaces in the host, so they may not have another
interface specified in a contained procedure.  The following example illustrates an
illegal redefinition.
.CS
   FUNCTION ABC()
     CONTAINS
       SUBROUTINE SAM()
         INTERFACE
            FUNCTION ABC() !  Illegal re-definition
            END FUNCTION   !  of ABC's interface
         END INTERFACE
       END SUBROUTINE
   END FUNCTION
.CE
.ME
$
$ Error : 0045
$msg  0045 Component "%s" is private type "%s", therefore derived type "%s" must also be private or have private components.
$nexp 0045
Error : Component "%s" is private type "%s", therefore derived type "%s" must also be private or have private components.
.PP
If a component of a derived type is declared to be a private type, either
the derived type definition must contain the \*CPRIVATE\fR statement or the
derived type must be private.
.ME
$
$ Ansi : 0046
$msg  0046 The TASK COMMON statement is an extension to the Fortran standard.
$nexp 0046
Ansi : The TASK COMMON statement is an extension to the Fortran standard.
.PP
The \*CTASK COMMON\fR statement is an extension to the Fortran standard.
.ME
$
$ Error : 0047
$msg  0047 A '*' must only be used with the UNIT or FMT I/O control information list items.
$nexp 0047
Error : A '*' must only be used with the UNIT or FMT I/O control information list items.
.PP
An asterisk (*) was encountered in an I/O control information list in a position 
or with a keyword other than \*CUNIT\fR or \*CFMT\fR.
.ME
$
$ Error : 0048
$msg  0048 The DO variable must not be defined while it is active.
$nexp 0048
Error : The DO variable must not be defined while it is active.
.PP
The name of an active \*CDO\fR variable appeared in a statement that would change the
\*CDO\fR variable's value.  The \*CDO\fR variable can be used but not redefined within the
range of its loop.
.ME
$
$ Log_Error : 0049
$msg  0049 Cannot open source file "%s".
$nexp 0049
Log_Error : Cannot open source file "%s".
.PP
The compiler cannot open the source file.
.ME
$
$ Internal : 0050
$msg  0050 Attempt to read past end of file.
$nexp 0050
Internal : Attempt to read past end of file.
.PP
This is generated from \*Cfixed_get_line\fR in \*Csrc_input.c\fR.
The compiler has attempted to read past EOF.
The source input file may be corrupted.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0051
$msg  0051 A compiler directive must not be followed by a Fortran continuation line.
$nexp 0051
Error : A compiler directive must not be followed by a Fortran continuation line.
.PP
A Fortran continuation source line was encountered following
a compiler directive. Compiler directives may be continued,
but they require the directive sentinal at the beginning
of the line. Compiler directives may not be embedded within
a continued Fortran source line.
.ME
$
$ Ansi : 0052
$msg  0052 More than %d continuation lines is an extension to the Fortran standard in %s source form.
$nexp 0052
Ansi : More than %d continuation lines is an extension to the Fortran standard in %s source form.
.PP
The Fortran standard only allows for 19 continuation lines in fixed
source form and 39 continuation lines in free form.
.ME
$
$ Error : 0053
$msg  0053 The first line of an include file must not be a continuation line.
$nexp 0053
Error : The first line of an include file must not be a continuation line.
.PP
The first line of an include file must not be a continuation line.
.ME
$
$ Error : 0054
$msg  0054 The source line following an INCLUDE line must not be a continuation line.
$nexp 0054
Error : The source line following an INCLUDE line must not be a continuation line.
.PP
The line following an \*CINCLUDE\fR line must not be a continuation line.
.ME
$
$ Warning : 0055
$msg  0055 The file line does not end with a newline.
$nexp 0055
Warning : The file line does not end with a newline.
.PP
The compiler expects all lines in the source file to end with a newline
character.  This line does not end with a newline character.
.ME
$
$ Error : 0056
$msg  0056 A continuation line must not contain a label.
$nexp 0056
Error : A continuation line must not contain a label.
.PP
It is illegal to define a label on a continuation line.
.ME
$
$ Error : 0057
$msg  0057 The file name length exceeds the maximum of %d characters.
$nexp 0057
Error : The file name length exceeds the maximum of %d characters.
.PP
The length of the name of the file exceeds the maximum length.
Shorten the name of the file.
.ME
$
$ Error : 0058
$msg  0058 The INCLUDE file name is missing.
$nexp 0058
Error : The INCLUDE file name is missing.
.PP
An \*CINCLUDE\fR line does not follow the expected form.  In the following
syntax, \fIfile\fR is the name of the file to be included:
.CS
      INCLUDE 'file'
.CE
.PP
The file name must be enclosed in apostrophes or quotation marks.  Only an embedded comment can
follow the closing delimiter.
.ME
$
$ Error : 0059
$msg  0059 There is a missing delimiter on an INCLUDE file name.
$nexp 0059
Error : There is a missing delimiter on an INCLUDE file name.
.PP
An \*CINCLUDE\fR line does not follow the expected form.  In the following
syntax, \*Vfile\fR is the name of the file to be included:
.CS
      INCLUDE 'file'
.CE
.PP
The file name must be enclosed in apostrophes or quotation marks.  Only embedded comments can
follow the closing delimiter.
.ME
$
$ Error : 0060
$msg  0060 The source following the INCLUDE file name is not a comment.
$nexp 0060
Error : The source following the INCLUDE file name is not a comment.
.PP
An \*CINCLUDE\fR line does not follow the expected form.  In the following
syntax, \*Vfile\fR is the name of the file to be included:
.CS
      INCLUDE 'file'
.CE
.PP
The file name must be enclosed in apostrophes or quotation marks.  Only an embedded comment can
follow the closing delimiter.
.ME
$
$ Error : 0061
$msg  0061 The INCLUDE line must not contain a statement label.
$nexp 0061
Error : The INCLUDE line must not contain a statement label.
.PP
An \*CINCLUDE\fR line does not follow the expected form.  In the following
syntax, \*Vfile\fR is the name of the file to be included:
.CS
      INCLUDE 'file'
.CE
.PP
The file name must be enclosed in apostrophes or quotation marks.  Only an embedded comment can
follow the closing delimiter.
.ME
$
$ Error : 0062
$msg  0062 Operator "%s" is not intrinsic.  All operations in a DATA statement expression must be intrinsic.
$nexp 0062
Error : Operator "%s" is not intrinsic.  All operations in a DATA statement expression must be intrinsic.
.PP
The \*CDATA\fR statement has the general form:
.CS
  data_stmt_object_list /data_stmt_value_list/
.CE
.PP
where a \*Vdata_stmt_object\fR can be a variable or an implied-\*CDO\fR.  In a 
\*Vdata_stmt_object\fR that is a variable; each subscript, section subscript, 
substring starting point, and substring ending point must be an expression 
where each operation is intrinsic.
.PP
The \*CDATA\fR statement implied-\*CDO\fR has the form:
.CS
  (\*Vdata_i_do_object_list\*C, \*Vdata_i_do_variable\*C = 
	\*Vscalar_int_expr\*C, \*Vscalar_int_expr\*C
	[, \*Vscalar_int_expr\*C])\fR
.CE
.PP
All operations in each subscript of a \*Vdata_i_do_object\fR subscript list must be
intrinsic.  Likewise, all operations in each loop control \*Vscalar_int_expr\fR must
be intrinsic.
.ME
$
$ Error : 0063
$msg  0063 Cannot open INCLUDE file "%s".
$nexp 0063
Error : Cannot open INCLUDE file "%s".
.PP
The compiler cannot open the specified \*CINCLUDE\fR file.
.ME
$
$ Error : 0064
$msg  0064 Recursive use of INCLUDE file "%s".
$nexp 0064
Error : Recursive use of INCLUDE file "%s".
.PP
An \*CINCLUDE\fR file must not include itself.
.ME
$
$ Error : 0065
$msg  0065 A defined operator exceeds the maximum length of 31 characters.
$nexp 0065
Error : A defined operator exceeds the maximum length of 31 characters.
.PP
A defined operator must not exceed 31 characters.
.ME
$
$ Error : 0066
$msg  0066 A defined operator is missing the "." delimiter.
$nexp 0066
Error : A defined operator is missing the "." delimiter.
.PP
A defined operator must start and end with a period delimiter.  This defined
operator is missing its end delimiter.
.ME
$
$ Error : 0067
$msg  0067 Truncating identifier which exceeds the maximum of 63 characters.
$nexp 0067
Error : Truncating identifier which exceeds the maximum of 63 characters.
.PP
Due to an internal limit, when the compiler reads an identifier, it discards
characters beyond the 63rd.
.ME
$
$ Error : 0068
$msg  0068 The label length exceeds the maximum of 5 digits.
$nexp 0068
Error : The label length exceeds the maximum of 5 digits.
.PP
The Fortran standard requires labels to be 5 or less digits.  The compiler has 
detected a label with more than 5 digits.
.ME
$
$ Error : 0069
$msg  0069 A label must have at least one nonzero digit.
$nexp 0069
Error : A label must have at least one nonzero digit.
.PP
The compiler detected a label consisting of all zeros.  A label must have at 
least one nonzero digit.
.ME
$
$ Error : 0070
$msg  0070 Each control item specifier must be specified only once.
$nexp 0070
Error : Each control item specifier must be specified only once.
.PP
An I/O statement contains the same specifier more than once.  For
example, the following would cause this message to be issued, because
\*CUNIT=\fR is specified twice.
.CS
      WRITE (UNIT=101,FMT=10,UNIT=101)
.CE
.ME
$
$ Ansi : 0071
$msg  0071 The Fortran standard requires continuation lines to contain text following the & symbol in free source form.
$nexp 0071
Ansi : The Fortran standard requires continuation lines to contain text following the & symbol in free source form.
.PP
The Fortran standard requires continuation lines to contain characters other
than the continuation character.
.ME
$
$ Internal : 0072
$msg  0072 Object "%s" is host associated to itself.  Attr index is %d.
$nexp 0072
Internal : Object "%s" is host associated to itself.  Attr index is %d.
.PP
AT_ATTR_LINK(attr_idx) = attr_idx.  This causes all kinds of internal loops
during compilation.  An attribute should never link to itself.

This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 0073
$msg  0073 This control item specifier is not allowed for this I/O statement.
$nexp 0073
Error : This control item specifier is not allowed for this I/O statement.
.PP
An I/O statement contains an inappropriate or unrecognized specifier.
The specifiers allowed on a \*CREAD\fR or \*CWRITE\fR statement are: 
.CS
UNIT    FMT         END         REC
ERR     IOSTAT      NML         ADVANCE
SIZE    EOR
.CE
The specifiers allowed on an \*COPEN\fR statement are: 
.CS
UNIT     FILE       STATUS      IOSTAT
ERR      FORM       ACCESS      RECL
BLANK    POSITION   ACTION      DELIM
PAD
.CE
The specifiers allowed on a \*CCLOSE\fR statement are:
.CS
UNIT     IOSTAT     STATUS      ERR
.CE
The specifiers allowed on an \*CINQUIRE\fR statement are:
.CS
FILE     IOSTAT     ERR         EXIST
OPENED   NUMBER     NAMED       RECL
NEXTREC  NAME       ACCESS      SEQUENTIAL
FORM     DIRECT     FORMATTED   UNFORMATTED
BLANK    UNIT       POSITION    ACTION
READ     WRITE      READWRITE   DELIM
PAD
.CE
.ME
$
$ Log_Warning : 0074
$msg  0074 Assembly language output (-eS or -S filename) disables binary output.  Assembly language output selected.
$nexp 0074
Log_Warning : Assembly language output (-eS or -S filename) disables binary output.  Assembly language output selected.
.PP
The compiler cannot have an assembly language file and a binary file open at the
same time.  The binary output file is disabled, because assembly language 
output is requested on the command line (\*C-eS\fR or \*C-S\fR \*Vfilename\fR).
The binary output file is on by default; therefore, specifying an assembly
language file on the command line (without turning off the binary file)
results in this warning message.
.CS
\*C-eS \fIfile.\*Cf     \fRWarning message issued
\*C-dB -eS \fIfile.\*Cf \fRNo warning, because \*C-dB\*C 
                        \fRturns off binary output\*C
\*C-eS -dS \fIfile.\*Cf \fRWarning message for \*C-eS.\*C
                        \fRBoth assembly and binary output are disabled.
.CE
.ME
$
$ Log_Warning : 0075
$msg  0075 Rounding/truncation conflict detected.  %s option selected.
$nexp 0075
Log_Warning : Rounding/truncation conflict detected.  %s option selected.
.PP
The compiler detected a rounding/truncation conflict on the command line.
The last option specified is used.
.ME
$
$ Log_Warning : 0076
$msg  0076 Inline option conflict detected.  Automatic mode selected.
$nexp 0076
Log_Warning : Inline option conflict detected.  Automatic mode selected.
.PP
This message is issued when both \*C-O inline[0-3]\fR and \*C-I \fIfilename\fR are
specified on the command line.  Automatic inlining is selected.
.ME
$
$ Log_Error : 0077
$msg  0077 Command line has an unknown option "%c".
$nexp 0077
Log_Error : Command line has an unknown option "%c".
.PP
The compiler detected an unknown option on the command line.
.ME
$
$ Log_Error : 0078
$msg  0078 -%c option has an illegal argument "%s".
$nexp 0078
Log_Error : -%c option has an illegal argument "%s".
.PP
The argument for the specified option is illegal.
.ME
$
$ Log_Error : 0079
$msg  0079 Options are not allowed after the input file name.
$nexp 0079
Log_Error : Options are not allowed after the input file name.
.PP
Nothing must follow the source input file name on the command line.
.ME
$
$ Log_Error : 0080
$msg  0080 Name must be specified for %s file when input is from stdin.
$nexp 0080
Log_Error : Name must be specified for %s file when input is from stdin.
.PP
If the source is input from \*Cstdin\fR, a name must be specified for the binary
or the assembly language file (depending on which one is requested).
.ME
$
$ Internal : 0081
$msg  0081 Unexpected attribute entry "%s" (index = %d) has been found in the local scope during use processing.
$nexp 0081
Internal : Unexpected attribute entry "%s" (index = %d) has been found in the local scope during use processing.
.PP
Routine not_visible_semantics has found an attribute in the symbol table
The only things allowed to be in the local scope during use processing
are the procedure name, function result name, dummy argument names,
use associated objects and objects used in declaration bounds expressions.
Other items that may be present, must have a declaration error.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Warning : 0082
$msg  0082 Debugging (-G) requires binary output (-eB).  Binary output is enabled.
$nexp 0082
Log_Warning : Debugging (-G) requires binary output (-eB).  Binary output is enabled.
.PP
If binary output is disabled (using the \*C-dB\fR option), the compiler can only
provide semantic and syntactic error checking.  Debugging requires binary
output to be generated.  Although binary output is on by default, it can be
turned off by specifying \*C-dB\fR or requesting an assembly language file 
(\*C-eS\fR or \*C-S\fR \*Vfilename\fR).
Following are examples to clarify this:
.nf
 \*C-dB -G0\fR   illegal - binary output is off, debug is on
 \*C-eS -G0\fR   illegal - assembly language file is on, debug is on
.fi
.ME
$
$ Error : 0083
$msg  0083 This token is missing the %c delimiter.
$nexp 0083
Error : This token is missing the %c delimiter.
.PP
The compiler detected the start of a token delimited by an apostrophe or 
a quotation mark.  The matching end delimiter is missing.
.ME
$
$ Error : 0084
$msg  0084 This Hollerith constant should have %d characters, but it only contains %d characters.
$nexp 0084
Error : This Hollerith constant should have %d characters, but it only contains %d characters.
.PP
The compiler detected an inconsistency between the count and the
number of characters actually specified in a Hollerith constant.  An example of this would be:
.CS
 4H123   \fRThe constant contains only 3 characters,\*C
         \fRbut the 4H indicates there should be 4.
.CE
.ME
$
$ Error : 0085
$msg  0085 The number of characters in the Hollerith specifier must be greater than zero.
$nexp 0085
Error : The number of characters in the Hollerith specifier must be greater than zero.
.PP
Specifying 0H is not valid.  The Hollerith constant must have a length greater than 0.
.ME
$
$ Error : 0086
$msg  0086 The END statement of this %s must be followed by %s.
$nexp 0086
Error : The END statement of this %s must be followed by %s.
.PP
The Fortran standard requires that the \*CEND\fR statement for a module 
procedure or internal procedure be \*CEND FUNCTION\fR if it is a function, and \*CEND SUBROUTINE\fR
if it is a subroutine.  The compiler detected only an \*CEND\fR statement.
.ME
$
$ Error : 0087
$msg  0087 In a real constant with a D or E following the decimal field, the D or E must be followed by an exponent.
$nexp 0087
Error : In a real constant with a D or E following the decimal field, the D or E must be followed by an exponent.
.PP
The compiler detected a missing exponent field in a real constant.
The syntax for a real constant is
.CS
   [\fIsign\*C] \fIreal_literal_constant\*C
.CE
.PP
\*Vreal_literal_constant\fR is 
\*Vsignificand\fR [\*Vexponent_letter exponent\fR] [_\*Vkind_param\fR]
.PP
     or
.PP
\*Vdigit_string exponent_letter exponent\fR [_\*Vkind_param\fR]
.PP
\*Vsignificand\fR is \*Vdigit_string\fR.[\*Vdigit_string\fR]
.PP
  or
.PP
\*Vdigit_string\fR
.PP
\*Vexponent_letter\fR is E or \*Vexponent\fR is \*Vsigned_digit_string\fR
.ME
$
$ Error : 0088
$msg  0088 The kind parameter suffix is not valid on a double precision real constant form.
$nexp 0088
Error : The kind parameter suffix is not valid on a double precision real constant form.
.PP
The compiler detected a kind parameter following a D exponent.
.PP
The syntax for a real constant is
.CS
[\*Vdigit_str\*C].\*Vdigit_str\*C[\*Vexponent_letter exponent\fR\*C]
[_\*Vkind_param\fR\*C]\fR
.CE
.PP
\*Vexponent_letter\fR is D or E; \*Vexponent\fR is \*Vsigned_digit_string\fR
with the following constraint:
if both \*Vkind_param\fR and \*Vexponent_letter\fR are present, \fIexponent_letter\fR must be E.
.ME
$
$ Error : 0089
$msg  0089 The kind parameter on a literal constant must be an integer number or named constant.
$nexp 0089
Error : The kind parameter on a literal constant must be an integer number or named constant.
.PP
If a kind parameter is specified on a literal constant, it must be an integer
number or named constant of type integer.  For example:
.CS
  r = 10.0_8    \fR! is a valid kind parameter\*C
  END

  PARAMETER (KIND=4)
  j = 10_KIND   \fR! is a valid kind parameter\*C
  END

  r = 10.0_IT   \fR! is not valid, because \*CIT\*C
                \fR! is not an integer constant value.
.CE
.ME
$
$ Ansi : 0090
$msg  0090 Boolean constants are an extension to the Fortran standard.
$nexp 0090
Ansi : Boolean constants are an extension to the Fortran standard.
.PP
Octal and hexadecimal values may be specified as Boolean constants in the
following ways:
.nf
.br
\*C1000B -->    \fRoctal   
.br
\*C'1a3'X -->   \fRhexadecimal
.fi
.PP
The Fortran standard does not support Boolean constants.
.ME
$
$ Error : 0091
$msg  0091 This constant contains %d characters.  The number of allowed characters must be > 0 and <= %d.
$nexp 0091
Error : This constant contains %d characters.  The number of allowed characters must be > 0 and <= %d.
.PP
Both nonstandard Boolean constants and Fortran BOZ constants
have limits to their size.  These limits are determined by machine type.

If the machine type has 64-bit words, the maximum lengths are as follows:

   For octal constants:        22
   For hexadecimal constants:  16
   For binary constants:       64

If the octal constant contains 22 characters, the high order (leftmost) digit
must only be a 0 or a 1.

If the machine type has 32-bit words, the maximum lengths are as follows:

   For octal constants:        11
   For hexadecimal constants:   8
   For binary constants:       32

If the octal constant contains 11 characters, the high order (leftmost) digit
must only be 0-3.
.ME
$
$ Error : 0092
$msg  0092 The value of this constant exceeds the range allowed on this machine type.
$nexp 0092
Error : The value of this constant exceeds the range allowed on this machine type.
.PP
Nonstandard Boolean constants and Fortran BOZ constants
have limits to their size.  These limits are determined by machine type.

If the machine type has 64-bit words, the maximum lengths are as follows:

   For octal constants:        22
   For hexadecimal constants:  16
   For binary constants:       64

If the octal constant contains 22 characters, the high order (leftmost) digit
must only be a 0 or a 1.

If the machine type has 32-bit words, the maximum lengths are as follows:

   For octal constants:        11
   For hexadecimal constants:   8
   For binary constants:       32

If the octal constant contains 11 characters, the high order (leftmost) digit
must only be 0-3.
.ME
$
$ Error : 0093
$msg  0093 Character '%c' is not valid in an octal constant.
$nexp 0093
Error : Character '%c' is not valid in an octal constant.
.PP
In octal constants (either BOZ or Boolean constants), the only allowed digits
are 0-7.  The compiler detected a character outside of this range.
.ME
$
$ Error : 0094
$msg  0094 A Hollerith constant must be %d characters or less when the "R" form is specified.
$nexp 0094
Error : A Hollerith constant must be %d characters or less when the "R" form is specified.
.PP
The "R" Hollerith form is specified as follows:
    '123456789'R
     9R123456789
.PP
Both of these cases are in error, because there are more than the maximum
number of characters that fit in a word specified in the Hollerith constant.
On 64 bit machines, a maximum of 8 characters is allowed. On 32 bit machines,
a maximum of 4 characters is allowed.
.ME
$
$ Error : 0095
$msg  0095 The real constant must contain digits in the whole and/or the fractional part of the constant.
$nexp 0095
Error : The real constant must contain digits in the whole and/or the fractional part of the constant.
.PP
The compiler is looking for a real constant but can only find a period.
.PP
For example:\*C
.nf
  \*C1.2       \fRLegal\*C
  \*C .2       \fRLegal\*C
  \*C1.        \fRLegal\*C
   \*C.        \fRIllegal
.fi
.ME
$
$ Ansi : 0096
$msg  0096 Hollerith constants are an extension to the Fortran standard.
$nexp 0096
Ansi : Hollerith constants are an extension to the Fortran standard.
.PP
The following specifications for a Hollerith constant are nonstandard.

    2Hab
    2Lab
    2Rab
    'ab'h
    'ab'l
    'ab'r
    "ab"H
    "ab"L
    "ab"R
.ME
$
$ Error : 0097
$msg  0097 The constant is not assignment compatible with "%s".
$nexp 0097
Error : The constant is not assignment compatible with "%s".
.PP
A variable is being initialized in either a type declaration statement or a 
\*CDATA\fR statement.  In either case, the value of the constant or structure
constructor must be compatible with its corresponding variable according to the
rules of intrinsic assignment.
.ME
$
$ Error : 0098
$msg  0098 A dot operator consisting of only letters is expected.
$nexp 0098
Error : A dot operator consisting of only letters is expected.
.PP
A dot operator is expected but not found.  A dot operator must consist of 
only letters.
.ME
$
$ Log_Error : 0099
$msg  0099 "-O %s" is specified, therefore "-O %s" must not be specified.
$nexp 0099
Log_Error : "-O %s" is specified, therefore "-O %s" must not be specified.
.PP
Two optimization options appearing on the command line request conflicting
optimizations. 
.ME
$
$ Error : 0100
$msg  0100 This statement must begin with a label, a keyword, or an identifier.
$nexp 0100
Error : This statement must begin with a label, a keyword, or an identifier.
.PP
The token that begins the statement is not valid.  The token must be either a 
label or an identifier.  An identifier can be a language keyword, a 
construct name, an identifier that is the target variable in an 
assignment statement, or the name of a statement function in a statement
function definition statement.
.ME
$
$ Error : 0101
$msg  0101 The length of the kind parameter exceeds the maximum length of 31.
$nexp 0101
Error : The length of the kind parameter exceeds the maximum length of 31.
.PP
The length of the kind parameter exceeds 31 characters.  Shorten the length
of the kind parameter.
.ME
$
$ Error : 0102
$msg  0102 Only an assignment statement can be used on a WHERE statement.
$nexp 0102
Error : Only an assignment statement can be used on a WHERE statement.
.PP
On a \*CWHERE\fR statement, the statement following the mask expression is not an
assignment statement.
.ME
$
$ Log_Summary : 0103
$msg  0103 openf95: Open64 Fortran Version %s (%s) %s
$nexp 0103
Log_Summary : openf95: Open64 Fortran Version %s (%s) %s
.PP
This identifies which version and release of the compiler is being used.
.ME
$
$ Log_Summary : 0104
$msg  0104 openf95: COMPILE TIME %f SECONDS
$nexp 0104
Log_Summary : openf95: COMPILE TIME %f SECONDS
.PP
This message reports the time, in seconds, that elapsed during the
compilation of the program.
.ME
$
$ Log_Summary : 0105
$msg  0105 openf95: MAXIMUM FIELD LENGTH %d DECIMAL WORDS
$nexp 0105
Log_Summary : openf95: MAXIMUM FIELD LENGTH %d DECIMAL WORDS
.PP
This message reports the maximum amount of memory used by the
compiler during compilation.
.ME
$
$ Log_Summary : 0106
$msg  0106 openf95: %d SOURCE LINES
$nexp 0106
Log_Summary : openf95: %d SOURCE LINES
.PP
This message reports the number of lines of source code read from the input
file and from any \*CINCLUDE\fR files specified on \*CINCLUDE\fR lines.
.ME
$
$ Log_Summary : 0107
$msg  0107 openf95: %d ERRORS, %d WARNINGS, %d OTHER MESSAGES, %d ANSI
$nexp 0107
Log_Summary : openf95: %d ERRORS, %d WARNINGS, %d OTHER MESSAGES, %d ANSI
.PP
This message gives a summary of messages issued during compilation.
.ME
$
$ Log_Summary : 0108
$msg  0108 openf95: CODE: %d WORDS, DATA: %d WORDS
$nexp 0108
Log_Summary : openf95: CODE: %d WORDS, DATA: %d WORDS
.PP
This message reports the number of words of instructions and the number of words
of data generated by the compiler.
.ME
$
$ Error : 0109
$msg  0109 Blank common must not be declared in a TASK COMMON statement or directive.
$nexp 0109
Error : Blank common must not be declared in a TASK COMMON statement or directive.
.PP
A \*CTASK COMMON\fR statement specifies the blank (unnamed) common block.
A \*CTASK COMMON\fR block must be named.  For example:
.PP
.nf
\*CTASK COMMON /\fIcbname\*C/ \fIn\*C, ...        \fR! Legal
\*CTASK COMMON // \fIn\*C, ...              \fR! Illegal
.fi
.ME
$
$ Error : 0110
$msg  0110 The SAVE attribute is specified more than once for common block "%s".
$nexp 0110
Error : The SAVE attribute is specified more than once for common block "%s".
.PP
The \*CSAVE\fR attribute must only be specified once for a common block name.
For example:
.CS
 PROGRAM MAIN
 COMMON /BLK/A
 SAVE /BLK/
 SAVE /BLK/ \fR! Illegal
.PP
This is illegal because \*CSAVE\fR is specified twice for \*CBLK\fR.
.CE
.ME
$
$ Error : 0111
$msg  0111 The PARAMETER attribute is specified, therefore an initialization expression must be specified for "%s".
$nexp 0111
Error : The PARAMETER attribute is specified, therefore an initialization expression must be specified for "%s".
.PP
The \*C= \fIinitialization_expr\fR must appear for the data object name if the
statement contains a \*CPARAMETER\fR attribute.
.ME
$
$ Ansi : 0112
$msg  0112 The arithmetic IF statement is an obsolescent feature.
$nexp 0112
Ansi : The arithmetic IF statement is an obsolescent feature.
.PP
This feature was declared obsolescent in the Fortran 2003 standard.
Use the Fortran \*CIF\fR
statement or \*CIF\fR construct in place of the arithmetic \*CIF\fR.
.ME
$
$ Error : 0113
$msg  0113 IMPLICIT NONE is specified in the local scope, therefore an explicit type must be specified for data object "%s".
$nexp 0113
Error : IMPLICIT NONE is specified in the local scope, therefore an explicit type must be specified for data object "%s".
.PP
When \*CIMPLICIT NONE\fR is specified, all data objects must have an explicit type.
.ME
$
$ Error : 0114
$msg  0114 A deferred-shape or assumed-shape array must not have an assumed-size specifier or an upper bound specified.
$nexp 0114
Error : A deferred-shape or assumed-shape array must not have an assumed-size specifier or an upper bound specified.
.PP
The compiler found \fIarray\fR(:10) or \*Varray\fR(:*) or a variation of this.  A
deferred-shape specifier and an assumed-shape specifier must not have an upper
bound specified.  The following bound forms are permissible:
.PP
.nf
explicit-shape array	[\fIlower-bound\fR:] \fIupper-bound\fR
.br
assumed-shape array	[\fIlower-bound\fR]:
.br
deferred-shape array	:
.br
assumed-size array	[\*Vlower-bound\fR:]*
.fi
.PP
The following example declares a 2-dimensional assumed-shape array of type integer.
.CS
    INTEGER, DIMENSION(1:,:) :: ARRAY
.CE
.ME
$
$ Error : 0115
$msg  0115 An explicit-shape array must have an upper bound specified.
$nexp 0115
Error : An explicit-shape array must have an upper bound specified.
.PP
The type of an array is determined by the first dimension.  If the 
dimension is 1:2  (where 1 and 2 are integers and 1 is optional), this
is an explicit-shape array declaration and the rest of the dimensions must
have an upper bound specified.
.ME
$
$ Error : 0116
$msg  0116 The assumed-size specifier (*) must be the upper bound for the last dimension of an explicit-shape array declaration.
$nexp 0116
Error : The assumed-size specifier (*) must be the upper bound for the last dimension of an explicit-shape array declaration.
.PP
The assumed-size specifier (*) can only be declared for the last dimension
of an explicit-shape array.  It must be the upper bound and be followed by a
right parenthesis.  The following bound forms are permissible:
.PP
.nf
explicit-shape array	[\*Vlower-bound\fR:] \*Vupper-bound\fR
.br
assumed-shape array	[\*Vlower-bound\fR]:
.br
deferred-shape array	:
.br
assumed-size array	[\*Vlower-bound\fR:]*
.fi
.ME
$
$ Error : 0117
$msg  0117 The maximum rank for an array declaration is 7.
$nexp 0117
Error : The maximum rank for an array declaration is 7.
.PP
An array can have no more than 7 dimensions.
.ME
$
$ Error : 0118
$msg  0118 Function "%s" was used in an expression.  The type is assumed to be %s.
$nexp 0118
Error : Function "%s" was used in an expression.  The type is assumed to be %s.
.PP
The compiler detected an attempt to retype a function that was previously
implicitly typed and used in an expression.  The following is an example of this
error:
.CS   
     DIMENSION ARRAY(KFUNC())
     REAL KFUNC
.CE
In this example, \*CKFUNC\fR can only be typed integer, because that is how 
it is implicitly typed in the \*CDIMENSION\fR statement.
.ME
$
$ Error : 0119
$msg  0119 This is a deferred-shape dimension specifier.  Therefore a comma or right parenthesis is expected, but a "%s" was found.
$nexp 0119
Error : This is a deferred-shape dimension specifier.  Therefore a comma or right parenthesis is expected, but a "%s" was found.
.PP
While parsing a deferred-shape array specification, the compiler expected a
comma or right parenthesis, but found something else.
A deferred-shape dimension specifier is simply a colon (:).

Other types of permissible bound forms are:
.PP
.nf
  explicit-shape array	[\*Vlower-bound\fR:] \*Vupper-bound\fR
.br
  assumed-shape array	[\*Vlower-bound\fR]:
.br
  assumed-size array	[\*Vlower-bound\fR:]*
.fi
.PP
If an array has the \*CALLOCATABLE\fR or \*CPOINTER\fR attribute, it must be specified as a
deferred-shape array.

The following example declares a 3-dimensional pointer array called \*CJOE\fR of type integer:
.CS
INTEGER, POINTER, DIMENSION(:,:,:) :: JOE
.CE     
.ME
$
$ Error : 0120
$msg  0120 The mask expression of a WHERE statement or WHERE construct must be type logical.
$nexp 0120
Error : The mask expression of a WHERE statement or WHERE construct must be type logical.
.PP
The expression used as the mask expression in a \*CWHERE\fR statement or \*CWHERE\fR 
construct is not the correct type.  It must be a logical expression.
.ME
$
$ Error : 0121
$msg  0121 If the "= initialization" expression is specified, "::" must separate the type and attributes from the identifier list.
$nexp 0121
Error : If the "= initialization" expression is specified, "::" must separate the type and attributes from the identifier list.
.PP
The \*C::\fR separator is required if \*C= \fIinitialization_expr\fR is specified
on the type declaration statement.
.ME
$
$ Error : 0122
$msg  0122 The RESULT keyword is only permitted on ENTRY statements in function subprograms.
$nexp 0122
Error : The RESULT keyword is only permitted on ENTRY statements in function subprograms.
.PP
The \*CRESULT\fR keyword is used on an \*CENTRY\fR statement that is not in a function
subprogram.  A \*CRESULT\fR keyword can only be specified on the \*CFUNCTION\fR and \*CENTRY\fR
statements in a function subprogram.
.ME
$
$ Error : 0123
$msg  0123 "%s" is a derived type type-name.  It cannot be defined as a type-name more than once.
$nexp 0123
Error : "%s" is a derived type type-name.  It cannot be defined as a type-name more than once.
.PP
A derived type type-name must only be defined once.  The compiler found
a type-name being used a subsequent time to define another derived type.
.ME
$
$ Ansi : 0124
$msg  0124 Use of %s*%d is an extension to the Fortran standard.
$nexp 0124
Ansi : Use of %s*%d is an extension to the Fortran standard.
.PP
Use of \fIdata_type\*C*\fIlength\fR is an extension to the Fortran standard for noncharacter data types.
.ME
$
$ Error : 0125
$msg  0125 "%d" is not an allowed length for %s.
$nexp 0125
Error : "%d" is not an allowed length for %s.
.PP
The length specified after the asterisk is an illegal length for the type.
For example: \*CDOUBLE PRECISION*8\fR is illegal because 16 is the only valid
star type for \*CDOUBLE PRECISION\fR.
.PP
Following are types and their legal star types:
.PP
.nf
 Integer: 1, 2, 4, 6, 8
 Real: 4, 8, 16
 Complex: 8, 16, 32
 Logical: 1, 2, 4, 8
 Double precision: 16
.fi
.ME
$
$ Error : 0126
$msg  0126 Derived type "%s" is used, but it does not have any components defined for it.
$nexp 0126
Error : Derived type "%s" is used, but it does not have any components defined for it.
.PP
The components of a derived type must be defined before they are accessed,
unless the type is specified on a \*CFUNCTION\fR statement or an \*CIMPLICIT\fR
statement.  In these cases, the derived type must be defined after the
reference.  In all cases, the derived type must be defined.  A derived type
is defined by specifying the component definitions.
.ME
$
$ Error : 0127
$msg  0127 More than one part reference of this data reference has a rank greater than zero.
$nexp 0127
Error : More than one part reference of this data reference has a rank greater than zero.
.PP
This data reference has more than one part that is array-valued.
In an array-valued data reference, there must be only one array-valued
part.  In the following example, both \*CA\fR and \*CB\fR are arrays:
.CS
	A(1:4)%B(3:4)  ! Illegal reference
.CE
.ME
$
$ Error : 0128
$msg  0128 Positional actual arguments in an actual argument list must precede any keywords.
$nexp 0128
Error : Positional actual arguments in an actual argument list must precede any keywords.
.PP
A positional argument follows an argument keyword in this actual argument list.
.ME
$
$ Error : 0129
$msg  0129 The kind type parameter must be a scalar integer constant.
$nexp 0129
Error : The kind type parameter must be a scalar integer constant.
.PP
A kind type parameter may be a \fIdigit_string\fR or the name of a scalar integer
constant.  For example:
.CS
INTEGER, PARAMETER :: large = 8
REAL, PARAMETER    :: rkind = 8.0
INTEGER            :: ikind = 8

i = 123_8      \fR! Legal\*C
i = 123_large  \fR! Legal\*C
 
i = 123_rkind  \fR! Illegal \*Crkind\fR not type integer.\*C
i = 123_ikind  \fR! Illegal \*Cikind\fR not named constant.\*C
.CE
.PP
.ME
$
$ Warning : 0130
$msg  0130 The kind type parameter value %s is not valid for type %s.
$nexp 0130
Warning : The kind type parameter value %s is not valid for type %s.
.PP
Following are valid kind types for each type:
.nf
  Character: 1
  Integer: 1, 2, 4, 6, 8
  Real: 4, 8, 16
  Complex: 4, 8, 16
  Logical: 1, 2, 4, 8
.ME
$
$ Error : 0131
$msg  0131 Explicit-shape array "%s" has nonconstant bounds so it can only be declared in a function or subroutine program unit.
$nexp 0131
Error : Explicit-shape array "%s" has nonconstant bounds so it can only be declared in a function or subroutine program unit.
.PP
Explicit-shape arrays with nonconstant bounds can only be declared in
subroutines, functions, or interface bodies which describe
subroutines and functions.  The compiler detected an array with 
nonconstant bounds, but the program unit is not a subroutine or function.
.ME
$
$ Error : 0132
$msg  0132 Function entry "%s" has result name "%s", which must be used when declaring the result to be a target.
$nexp 0132
Error : Function entry "%s" has result name "%s", which must be used when declaring the result to be a target.
.PP
If a function has a result name, the result name must be used when declaring
the result to be a target.
.ME
$
$ Ansi : 0133
$msg  0133 The Fortran standard requires a SAVE statement with no saved-entity-list to be the only SAVE in the scoping unit.
$nexp 0133
Ansi : The Fortran standard requires a SAVE statement with no saved-entity-list to be the only SAVE in the scoping unit.
.PP
If a \*CSAVE\fR statement with an omitted \fIsaved_entity_list\fR occurs in a scoping unit,
no other explicit occurrences of the \*CSAVE\fR attribute or \*CSAVE\fR statement are
permitted in the same scoping unit.
.ME
$
$ Ansi : 0134
$msg  0134 Cray pointers are an extension to the Fortran standard.
$nexp 0134
Ansi : Cray pointers are an extension to the Fortran standard.
.PP
Cray pointers are nonstandard and are declared as follows:

     \*CPOINTER\fR(\*Vpointer\*C,\*Vpointee\fR)

Fortran pointers are declared as follows:

     \*CPOINTER [::] \fR\*Vobject-name\fR

The two kinds of pointers must not be mixed.
.ME
$
$ Error : 0135
$msg  0135 A FORMAT statement is required to have a statement label.
$nexp 0135
Error : A FORMAT statement is required to have a statement label.
.PP
The syntax of a \*CFORMAT\fR statement is:
.PP
\fIformat_stmt\fR is \*CFORMAT \fIformat_specification\fR
.PP
\fIformat_specification\fR   is \*C([\fIformat_item_list\*C])\fR
.PP
The \*CFORMAT\fR statement must have a statement label.
.ME
$
$ Internal : 0136
$msg  0136 The variant active in the attribute entry passed to %s is not valid.
$nexp 0136
Internal : The variant active in the attribute entry passed to %s is not valid.
.PP
The attribute table index passed to the named routine is not valid.  It has
the wrong active variant.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0137
$msg  0137 An EQUIVALENCE list needs at least two items in the list.
$nexp 0137
Error : An EQUIVALENCE list needs at least two items in the list.
.PP
There are less than two items in an \*CEQUIVALENCE\fR list.  An \*CEQUIVALENCE\fR list
needs at least two items.
.ME
$
$ Internal : 0138
$msg  0138 Table "%s" does not line up correctly on a word boundary for this machine.
$nexp 0138
Internal : Table "%s" does not line up correctly on a word boundary for this machine.
.PP
The listed table does not line up on a word boundary for this machine.  Check
to make sure that the table is divided up into 32 bit chunks and that the
\*CNUM_...._WDS\fR macro for the table is set to the correct number of words.
.PP
This message should never be generated.  This is a bad compiler or a bad
installation.  Please notify your product support organization with this
error message number and any supporting information.  This message does
not indicate a problem with your code.
.ME
$
$ Error : 0139
$msg  0139 This I/O control list specifier requires a keyword.
$nexp 0139
Error : This I/O control list specifier requires a keyword.
.PP
All arguments used in the I/O statements \*COPEN\fR, \*CCLOSE\fR, \*CBACKSPACE\fR, \*CENDFILE\fR, 
\*CREWIND\fR, and \*CINQUIRE\fR must be identified with a \fIkeyword=\fR preceding the
argument, except for the \*CUNIT\fR, \*CFMT\fR and \*CNML\fR specifiers.  If \*CUNIT\fR is specified
without a keyword, it must be the first item in the control list.  If the
\*CFMT\fR or \*CNML\fR specifier is specified without a keyword, it must be the second 
item in the list; the first item must be the \*CUNIT\fR specified without 
its keyword.
.ME
$
$ Error : 0140
$msg  0140 The derived type being defined is sequenced so any components which are derived types must also be sequenced.
$nexp 0140
Error : The derived type being defined is sequenced so any components which are derived types must also be sequenced.
.PP
If a \*CSEQUENCE\fR statement is present in the derived type being defined, 
all derived types specified in component definitions
must be sequence types.  The compiler detected a component which is a
derived type but is not a sequence type.
.ME
$
$ Internal : 0141
$msg  0141 The beginning token of this statement has led to a bad choice of statement type.
$nexp 0141
Internal : The beginning token of this statement has led to a bad choice of statement type.
.PP
The statement parse driver has called the 
\*Cparse_bad_stmt\fR routine.  Check the beginning token and the token to
parse routines table.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0142
$msg  0142 Label variable "%s" must be scalar and of type default integer.
$nexp 0142
Error : Label variable "%s" must be scalar and of type default integer.
.PP
An \*CASSIGN\fR statement or an \*Cassigned GO TO\fR statement has a label variable
(\fIscalar_int_variable\fR) that is not scalar and/or is not of type default integer.

The syntax of the \*CASSIGN\fR statement is:
.CS
  \*CASSIGN\fR \fIlabel \*CTO\fR \fIscalar_int_variable\fR
.CE

The syntax of the \*Cassigned GO TO\fR statement is:
.CS
  \*CGO TO\fR \fIscalar_int_variable\*C [ [\fR,\*C] (\fIlabel_list\*C) ]\fR
.CE

The \fIscalar_int_variable\fR must be an unqualified name; it cannot be a
structure component, array element, or substring designator.  The variable
must be of type default integer, and it must be scalar.  For these statements,
"type default integer" also means that the integer must be a full word.  This
message is produced if an option such as \*C-i 32\fR or \*C-s default32\fR is
specified and the \fIscalar_int_variable\fR is of type default integer because
these options reduce the bit length of default integers (a Cray T3E address
is longer than 32 bits).
.ME
$
$ Error : 0143
$msg  0143 Character object "%s" has nonconstant bounds.  It can only be declared in a function or subroutine program unit.
$nexp 0143
Error : Character object "%s" has nonconstant bounds.  It can only be declared in a function or subroutine program unit.
.PP
Objects that are typed as character with nonconstant lengths can only be
declared in subroutines, functions, and interface bodies (which describe
subroutines and functions).  The compiler detected a character object
with a nonconstant length, but the declaration is not contained in a subroutine, interface body, or
function.
.ME
$
$ Error : 0144
$msg  0144 Transfer of control to the nonexecutable statement at line %d is not allowed.
$nexp 0144
Error : Transfer of control to the nonexecutable statement at line %d is not allowed.
.PP
The statement is attempting to transfer control to a nonexecutable
statement.  Control can only be transferred to an executable branch target statement.  
(See the \fICFortran Language Reference Manual\fR, publication SR-3902, 
for the definitions of executable and nonexecutable statements.)
.ME
$
$ Error : 0145
$msg  0145 Transfer of control to the %s statement at line %d is not allowed.
$nexp 0145
Error : Transfer of control to the %s statement at line %d is not allowed.
.PP
The statement is attempting to transfer control to an executable 
statement that must not be used as a branch target.  All executable statements
are branch targets except for:  \*CCASE, ELSE, ELSE IF, ELSE WHERE,
END WHERE\fR and \*CIF-THEN\fR.
Transfer of control to some executable statements is allowed only
in limited contexts:
.BL
It is permissible to branch to an \*CEND SELECT\fR statement only from within its 
\*CCASE\fR construct.
.BL
Control should only be transferred to an \*CEND IF\fR statement from within 
its \*CIF\fR construct.  Transfer of control to an \*CEND IF\fR statement from outside its \*CIF\fR 
construct is obsolescent.
.BL
Control should only be transferred to a \*CDO\fR loop termination statement from 
within its \*CDO\fR construct.  For nested \*CDO\fR loops that share a common loop 
termination statement, control should only be transferred to the loop 
termination statement from within the innermost \*CDO\fR construct.
.PP
Violations of these specific cases are diagnosed by other messages.     
.ME
$
$ Error : 0146
$msg  0146 Statement label "%s" was previously defined at line %d.
$nexp 0146
Error : Statement label "%s" was previously defined at line %d.
.PP
A statement label must only be defined once within a scoping unit.   The compiler found another 
definition for the statement label at the specified line.
.ME
$
$ Error : 0147
$msg  0147 Transfer of control into the WHERE construct starting at line %d is not allowed.
$nexp 0147
Error : Transfer of control into the WHERE construct starting at line %d is not allowed.
.PP
The statement is attempting to transfer control to a statement in the
\*CWHERE\fR block or \*CELSEWHERE\fR block of a \*CWHERE\fR construct.  In a \*CWHERE\fR construct, 
only the \*CWHERE\fR construct statement itself can be a branch target.
.ME
$
$ Error : 0148
$msg  0148 Transfer of control into the CASE block starting at line %d is not allowed.
$nexp 0148
Error : Transfer of control into the CASE block starting at line %d is not allowed.
.PP
The statement in error is attempting to transfer control to a \*CCASE\fR block from 
outside the \*CCASE\fR construct or from another \*CCASE\fR block within the same
\*CCASE\fR construct.  Transfer of control to the interior of a \*CCASE\fR block
from outside the block is not permissible. 
.ME
$
$ Ansi : 0149
$msg  0149 Transfer of control to an END IF statement from outside the IF construct is obsolescent/deleted.
$nexp 0149
Ansi : Transfer of control to an END IF statement from outside the IF construct is obsolescent/deleted.
.PP
Instead of branching to the \*CEND IF\fR statement from outside its \*CIF\fR construct, 
branch to the statement following the \*CEND IF\fR.  This may require program logic
changes if the statement following the \*CEND IF\fR is not a valid branch target
statement. 
.PP
The Fortran 95 standard has deleted this feature. The compiler supports it as
an extension.
.ME
$
$ Error : 0150
$msg  0150 Transfer of control to an END DO statement from outside its block DO construct is not allowed.
$nexp 0150
Error : Transfer of control to an END DO statement from outside its block DO construct is not allowed.
.PP
The statement in error is attempting to transfer control to an \*CEND DO\fR statement
but the branching statement is not contained in the block \*CDO\fR construct 
terminated by the labeled \*CEND DO\fR.  It is permissible to branch to an \*CEND DO\fR
statement only from within its \*CDO\fR construct.
.ME
$
$ Error : 0151
$msg  0151 This use of derived type "%s" is not valid.
$nexp 0151
Error : This use of derived type "%s" is not valid.
.PP
A derived type name is in an executable statement, but is not being used as
a derived type constructor.
.ME
$
$ Error : 0152
$msg  0152 The assignment statement of a WHERE statement or in a WHERE construct must not be a defined assignment.
$nexp 0152
Error : The assignment statement of a WHERE statement or in a WHERE construct must not be a defined assignment.
.PP
This masked array assignment resolves to a defined assignment.
.ME
$
$ Error : 0153
$msg  0153 Transfer of control to an END SELECT statement from outside its CASE construct is not allowed.
$nexp 0153
Error : Transfer of control to an END SELECT statement from outside its CASE construct is not allowed.
.PP
The statement in error is attempting to transfer control to an \*CEND SELECT\fR 
statement but the branching statement is not contained in a \*CCASE\fR block of the
\*CCASE\fR construct terminated by the labeled \*CEND SELECT\fR.  It is permissible
to branch to an \*CEND SELECT\fR statement only from within its \*CCASE\fR 
construct.
.ME
$
$ Warning : 0154
$msg  0154 Transfer of control into the DO loop starting at line %d is not safe.
$nexp 0154
Warning : Transfer of control into the DO loop starting at line %d is not safe.
.PP
The statement is transferring control into the body of a \*CDO\fR loop or to the 
termination statement of a \*CDO\fR loop but the branching statement is not 
contained in the loop.  In nested loops with a common 
termination statement, control can only be transferred to the common
termination statement from the innermost loop.
.ME
$
$ Ansi : 0155
$msg  0155 Transfer of control into the DO loop starting at line %d is nonstandard.
$nexp 0155
Ansi : Transfer of control into the DO loop starting at line %d is nonstandard.
.PP
The Fortran standard does not allow transfer of control into the body of a \*CDO\fR
loop or to the termination statement of a \*CDO\fR loop from outside the loop.
.ME
$
$ Warning : 0156
$msg  0156 Transfer of control into the %s block starting at line %d is not safe.
$nexp 0156
Warning : Transfer of control into the %s block starting at line %d is not safe.
.PP
The statement is transferring control into a \*CTHEN\fR block, \*CELSE\fR block, or \*CELSE IF\fR
block from outside the \*CIF\fR construct or from another block within the \*CIF\fR
construct.  Transfer of control to the interior of a block from outside the 
block is not allowed.
.ME
$
$ Ansi : 0157
$msg  0157 Transfer of control into the %s block starting at line %d is nonstandard.
$nexp 0157
Ansi : Transfer of control into the %s block starting at line %d is nonstandard.
.PP
The Fortran standard does not allow transfer of control into a \*CTHEN\fR block, \*CELSE IF\fR
block, or \*CELSE\fR block from outside the \*CIF\fR construct or from another block within the
\*CIF\fR construct.
.ME
$
$ Error : 0158
$msg  0158 No name can be specified on the END BLOCK DATA statement for an unnamed block data program unit.
$nexp 0158
Error : No name can be specified on the END BLOCK DATA statement for an unnamed block data program unit.
.PP
An unamed block data program unit must not have a name specified on its \*CEND\fR
statement.  The compiler detected a name on the \*CEND BLOCK DATA\fR statement
for a block data program unit that is unnamed.
.ME
$
$ Error : 0159
$msg  0159 More than one CASE DEFAULT statement was found for this CASE construct.
$nexp 0159
Error : More than one CASE DEFAULT statement was found for this CASE construct.
.PP
The compiler detected more than one \*CCASE DEFAULT\fR statement for this 
\*CCASE\fR construct.  Only one \*CCASE DEFAULT\fR statement is allowed per 
\*CCASE\fR construct.
.ME
$
$ Internal : 0160
$msg  0160 There is a problem with the block stack at block stack index %d.
$nexp 0160
Internal : There is a problem with the block stack at block stack index %d.
.PP
One of the following errors has occurred:
.BL
The compiler has found an unknown block on the block stack at the given block index.  
The block stack should never have an unknown block on it.
.BL
The block stack has an \*CIf_Blk\fR without a \*CIF_THEN_BLK\fR, \*CIF_ELSE_IF_BLK\fR, 
or \*CIF_ELSE_BLK\fR immediately following it.
.BL
The \*Cblk_stk_idx\fR = \*CNULL_IDX\fR.  The block stack should always have the program 
unit block as the first entry.
.BL
The current block is an \*CIf_Then_Blk\fR, \*CIf_Else_If_Blk\fR, or \*CIf_Else_Blk\fR 
but the preceding block entry is not an \*CIf_Blk\fR.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0161
$msg  0161 A character literal used as a Hollerith constant is an extension to the Fortran standard.
$nexp 0161
Ansi : A character literal used as a Hollerith constant is an extension to the Fortran standard.
.PP
A character constant is being used in a context in which a character constant
is not allowed, but a Hollerith constant is allowed.  This is an extension to
the Fortran standard.  Hollerith constants are allowed in arithmetic and
logical expressions and in assignment statements where the left side of the
equal sign is an entity of type integer or real.  This message can also occur
with the use of a literal string as a file identifier in a control
information list on an I/O statement.
.ME
$
$ Error : 0162
$msg  0162 The %s statement is not allowed in an ELSE IF block of an IF construct.
$nexp 0162
Error : The %s statement is not allowed in an ELSE IF block of an IF construct.
.PP
The following statements are allowed following the \*CELSEIF\fR of an \*CIF\fR construct:
.PP
.nf
\*CALLOCATE               ASSIGN
BACKSPACE              BUFFER
CALL                   CLOSE
CONTINUE               DATA
DEALLOCATE             DECODE
DO                     ENCODE
ENDFILE                ENDIF
ELSE                   ELSEIF
FORMAT                 GOTO
IF                     INQUIRE
NAMELIST               NULLIFY
OPEN                   PAUSE
PRINT                  READ
RETURN                 REWIND
SELECT                 STOP
WHERE                  WRITE\fR
assignment
.fi
.PP
The following statements are allowed if the listed condition is met.
.BL
\*CCASE\fR, \*CEND SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE\fR, \*CEND WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE\fR, \*CEXIT\fR, \*CEND DO\fR in a \*CDO\fR construct
.ME
$
$ Error : 0163
$msg  0163 The %s statement is not allowed in an ELSE block of an IF construct.
$nexp 0163
Error : The %s statement is not allowed in an ELSE block of an IF construct.
.PP
The following statements are allowed in the \*CELSE\fR block of an \*CIF\fR construct:
.PP
.nf
\*CALLOCATE               ASSIGN
BACKSPACE              BUFFER
CALL                   CLOSE
CONTINUE               DATA
DEALLOCATE             DECODE
DO                     ENCODE
ENDFILE                ENDIF
ELSE                   ELSEIF
FORMAT                 GOTO
IF                     INQUIRE
NAMELIST               NULLIFY
OPEN                   PAUSE
PRINT                  READ
RETURN                 REWIND
SELECT                 STOP
WHERE                  WRITE\fR
assignment
.fi
.PP
The following statements are allowed if the listed condition is met.
.BL
\*CCASE\fR, \*CEND SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE\fR, \*CEND WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE\fR, \*CEXIT\fR, \*CEND DO\fR in a \*CDO\fR construct
.ME
$
$ Error : 0164
$msg  0164 The %s statement is not allowed in an internal procedure.
$nexp 0164
Error : The %s statement is not allowed in an internal procedure.
.PP
The following statements are not allowed in an internal procedure:
.CS
    \*CCONTAINS
    \*CTASK COMMON
    \*CPUBLIC
    \*CPRIVATE
.CE
.PP
The following statements must be inside an interface block, scoping unit, or construct 
to be in an internal subprogram.
.BL
\*CSEQUENCE, END TYPE\fR in a derived type definition
.BL
\*CMODULE PROCEDURE\fR in a generic interface block  
.BL
\*CELSE, ELSEIF, END IF\fR in an \*CIF\fR construct
.BL
\*CCASE, END SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE, END WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE, EXIT, END DO\fR in a \*CDO\fR construct
.BL
\*CFUNCTION, SUBROUTINE, END INTERFACE\fR  in an interface block
.ME
$
$ Error : 0165
$msg  0165 The %s statement is not allowed in a module procedure.
$nexp 0165
Error : The %s statement is not allowed in a module procedure.
.PP
The following statements are not allowed in a module procedure:
.CS
    \*CPUBLIC
    \*CPRIVATE
    \*CTASK COMMON
.CE
.PP
The following statements must be inside 
an interface block, scoping unit, or construct to be in a module procedure:
.BL
\*CSEQUENCE, END TYPE\fR in a derived type definition
.BL
\*CMODULE PROCEDURE\fR in a generic interface block
.BL
\*CELSE, ELSEIF, END IF\fR in an \*CIF\fR construct
.BL
\*CCASE, END SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE, END WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE, EXIT, END DO\fR in a \*CDO\fR construct
.BL
\*CFUNCTION, SUBROUTINE, END INTERFACE\fR  in an interface block
.ME
$
$ Error : 0166
$msg  0166 Extraneous data follows a format specification.
$nexp 0166
Error : Extraneous data follows a format specification.
.PP
This format specification has unrecognizable characters beyond 
the end of the format specification.  The following statement would cause this 
message to be issued:
.CS
  10 FORMAT(1X,A8) X6		\fR! Illegal
.CE
.ME
$
$ Warning : 0167
$msg  0167 Field width is too small in this usage.
$nexp 0167
Warning : Field width is too small in this usage.
.PP
An improper field width is used with an E, F, D, G, I, Z, or O
edit descriptor.  In the following edit descriptors, \fIw\fR must be greater than
or equal to \fId\fR:
.CS
  \*CE\fIw.d\*C  E\fIw.d\*CE\fIe\*C
  \*CF\fIw.d\*C
  \*CG\fIw.d\*C  G\fIw.d\*CE\fIe\*C
  \*CD\fIw.d
.CE
For the following edit descriptors, \fIw\fR must be greater than or equal to \fIm\fR.
.CS
  \*CI\fIw.m\*C
  \*CB\fIw.m\*C
  \*CO\fIw.m\*C
  \*CZ\fIw.m\fR
.CE
.ME
$
$ Ansi : 0168
$msg  0168 Empty parentheses in a FORMAT are an extension to the Fortran standard and are ignored.
$nexp 0168
Ansi : Empty parentheses in a FORMAT are an extension to the Fortran standard and are ignored.
.PP
An empty format specification appears in another format specification.  The
Fortran standard requires format specifications to be in the following 
format:
.CS
  ([\fIformat_item_list\*C])
.CE
.PP
\fIformat_item_list\fR is a list of items of the following form:
.CS
  [\fIr\*C] \fIdata_edit_desc\*C
  \fIcontrol_edit_desc\*C
  [\fIr\*C] \fIchar_string_edit_desc\*C
            \fI(format_item_list)
.CE
.PP
\fIr\fR
is a nonzero, unsigned integer constant.
.ME
$
$ Ansi : 0169
$msg  0169 A comma between these format fields is required by some versions of the Fortran standard.
$nexp 0169
Ansi : A comma between these format fields is required by some versions of the Fortran standard.
.PP
This format specification has two consecutive format descriptors with no comma
separating them.  The Fortran 90 standard allows the comma to
be omitted in the following places:
.BL
Between a P descriptor and an immediately following F, E, D, or G descriptor
.BL
Before or after a slash
.BL
Before or after a colon
.PP
In addition, the Fortran 2003 standard allows the comma to be omitted between
a P descriptor and a repeat specifier.
.ME
$
$ Ansi : 0170
$msg  0170 A comma preceding a right parenthesis is an extension to the Fortran standard.
$nexp 0170
Ansi : A comma preceding a right parenthesis is an extension to the Fortran standard.
.PP
This format specification has a comma followed by another comma, or a comma
followed by a right parenthesis.  The Fortran standard does not allow a
comma to precede the right parenthesis.
.ME
$
$ Error : 0171
$msg  0171 Construct name "%s" was previously declared at line %d.
$nexp 0171
Error : Construct name "%s" was previously declared at line %d.
.PP
A construct name must only be defined once in a scoping unit.  The compiler found 
a definition for this construct name at the specified line.
.ME
$
$ Error : 0172
$msg  0172 The assign variable name must be an unqualified name.
$nexp 0172
Error : The assign variable name must be an unqualified name.
.PP
The assign variable name in an \*CASSIGN\fR statement must be a simple variable name.
The name must not contain structure component qualifications nor can it be
qualified by a subscript list or a substring range.
.ME
$
$ Error : 0173
$msg  0173 The compiler expected a NAMELIST group name following the NML specifier.
$nexp 0173
Error : The compiler expected a NAMELIST group name following the NML specifier.
.PP
The compiler expected a namelist group name to follow the \*CNML\fR specifier.
.ME
$
$ Ansi : 0174
$msg  0174 A WRITE statement with no unit I/O specifier is an extension to the Fortran standard.
$nexp 0174
Ansi : A WRITE statement with no unit I/O specifier is an extension to the Fortran standard.
.PP
A \*CWRITE\fR statement of the following form was encountered:
.CS
  WRITE \fIf\*C [,\fIiolist\*C]
.CE
.PP
This form of the \*CWRITE\fR statement, with no control information list, 
is an extension to the Fortran standard.
.ME
$
$ Error : 0175
$msg  0175 The IMPLICIT range "%c-%c" is not in alphabetical order.
$nexp 0175
Error : The IMPLICIT range "%c-%c" is not in alphabetical order.
.PP
In an \*CIMPLICIT\fR statement, if the implicit specification list is: 
\fIletter1 - letter\fR2, \fIletter2\fR must follow \fIletter1\fR alphabetically.
.ME
$
$ Error : 0176
$msg  0176 IMPLICIT NONE is specified in this scope, therefore no other IMPLICIT statements are allowed.
$nexp 0176
Error : IMPLICIT NONE is specified in this scope, therefore no other IMPLICIT statements are allowed.
.PP
If \*CIMPLICT NONE\fR is specified within the scope of a procedure, no other
\*CIMPLICIT\fR statements are allowed.
.ME
$
$ Error : 0177
$msg  0177 The following letter(s) were specified in a previous IMPLICIT statement: "%s", so must not be specified again.
$nexp 0177
Error : The following letter(s) were specified in a previous IMPLICIT statement: "%s", so must not be specified again.
.PP
A letter must only be specified once in an \*CIMPLICIT\fR statement in a scoping unit.
For example:
.CS
   IMPLICIT INTEGER (A)
   IMPLICIT REAL (A,B)          \fR! Illegal
.CE
This is illegal, because \*CA\fR was specified in the previous \*CIMPLICIT\fR statement.
.ME
$
$ Internal : 0178
$msg  0178 Array class is Unknown_Array, but there is no declaration error for the dimension spec.
$nexp 0178
Internal : Array class is Unknown_Array, but there is no declaration error for the dimension spec.
.PP
The array class should only be \*CUnknown_Array\fR if there is a declaration error
for the dimension spec.  The problem is detected at the end of \*Cparse_array_spec\fR.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0179
$msg  0179 Chose DEFAULT case on case statement in routine %s.  Should never get here.
$nexp 0179
Internal : Chose DEFAULT case on case statement in routine %s.  Should never get here.
.PP
While processing a switch statement, a case was entered that should not be
entered.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0180
$msg  0180 Identifier "%s" was found in table %s, but should not have been found.
$nexp 0180
Internal : Identifier "%s" was found in table %s, but should not have been found.
.PP
The name being searched for in the table should not be found in the current
scope (examples are program unit name and dummy argument identifiers).
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0181
$msg  0181 The mask expression in a WHERE statement or WHERE construct must be an array-valued expression.
$nexp 0181
Error : The mask expression in a WHERE statement or WHERE construct must be an array-valued expression.
.PP
The compiler detected a masking expression in a \*CWHERE\fR statement that is
a scalar expression.   It must be an array-valued expression.
.ME
$
$ Ansi : 0182
$msg  0182 The use of a repetition count with the slash edit descriptor is an extension to the Fortran standard.
$nexp 0182
Ansi : The use of a repetition count with the slash edit descriptor is an extension to the Fortran standard.
.PP
A repetition count was found before the slash edit descriptor.  This use 
of the repetition count is an extension to the Fortran standard.
.ME
$
$ Error : 0183
$msg  0183 The %s statement is not allowed in a CASE block of a CASE construct.
$nexp 0183
Error : The %s statement is not allowed in a CASE block of a CASE construct.
.PP
The following statements are allowed in a \*CCASE\fR construct, following a 
\*CCASE\fR statement:
.PP
.nf
\*CALLOCATE               ASSIGN
BACKSPACE              BUFFER
CALL                   CLOSE
CONTINUE               DATA
DEALLOCATE             DECODE
DO                     ENCODE
ENDFILE                ENDIF
ELSE                   ELSEIF
FORMAT                 GOTO
IF                     INQUIRE
NAMELIST               NULLIFY
OPEN                   PAUSE
PRINT                  READ
RETURN                 REWIND
SELECT                 STOP
WHERE                  WRITE\fR
assignment
.fi
.PP
The following statements are allowed if the listed condition is met.
.BL
\*CCASE\fR, \*CEND SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE\fR, \*CEND WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE\fR, \*CEXIT\fR, \*CEND DO\fR in a \*CDO\fR construct
.ME
$
$ Caution : 0184
$msg  0184 Recursive function entry name "%s" must have a result name to be called recursively when declared an array.
$nexp 0184
Caution : Recursive function entry name "%s" must have a result name to be called recursively when declared an array.
.PP
If the result of a recursive function is an array, it must have a declared
result name in order to be called recursively.  If no result name is specified,
a reference to the function name is a reference to the result variable.
This makes it impossible to call this function recursively from within its
scope.  For example:
.CS
RECURSIVE FUNCTION IARRAY(I) RESULT(I_RESULT)
REAL, DIMENSION :: I_RESULT(100)
...
! The following reference to I_RESULT
! is a reference to the 10th element of
! the result variable.

X = I_RESULT(10)

! The following reference to IARRAY
! is a recursive reference to the function

Y = IARRAY(10) 
END FUNCTION
.CE
.ME
$
$ Error : 0185
$msg  0185 Function entry "%s" has a result name.  Use result name "%s" when typing the function result.
$nexp 0185
Error : Function entry "%s" has a result name.  Use result name "%s" when typing the function result.
.PP
If a function entry has a result name, the result name must be used when
typing or specifying attributes of the function result.
.ME
$
$ Error : 0186
$msg  0186 Unexpected syntax:  Expecting "%s" to follow the END keyword, but found "%s".
$nexp 0186
Error : Unexpected syntax:  Expecting "%s" to follow the END keyword, but found "%s".
.PP
The compiler is looking for one of the following strings after the \*CEND\fR keyword:  \*CBLOCK DATA,
MODULE, PROGRAM, SUBROUTINE, \*CFUNCTION, INTERFACE, TYPE, IF, DO, SELECT,
WHERE \fRor\*C "EOS"\fR.  The compiler did not find the appropriate string.
.ME
$
$ Error : 0187
$msg  0187 The "::" separator is required on a component definition statement, if the POINTER or DIMENSION attribute is specified.
$nexp 0187
Error : The "::" separator is required on a component definition statement, if the POINTER or DIMENSION attribute is specified.
.PP
The Fortran standard requires a \*C::\fR separator to follow the specification of 
the \*CPOINTER\fR and/or \*CDIMENSION\fR attributes on a component declaration statement.
For example:
.CS
    TYPE :: NEW_TYPE
      INTEGER, POINTER :: A     ! Legal
      REAL, DIMENSION(100)  B   ! Illegal
    END TYPE
.CE
.ME
$
$ Error : 0188
$msg  0188 "%s" is already used as a component name for this derived type.
$nexp 0188
Error : "%s" is already used as a component name for this derived type.
.PP
Each component of a derived type must have a unique name.  This name is 
already a component name in this derived type.
.ME
$
$ Error : 0189
$msg  0189 Component "%s" has the POINTER attribute, therefore the DIMENSION attribute must be a deferred-shape dimension.
$nexp 0189
Error : Component "%s" has the POINTER attribute, therefore the DIMENSION attribute must be a deferred-shape dimension.
.PP
If a component has the \*CPOINTER\fR attribute and the \*CDIMENSION\fR attribute, the
dimension must be a deferred-shape dimension.
.ME
$
$ Error : 0190
$msg  0190 Component "%s" does not have a POINTER attribute so its dimension must be an explicit-shape array with constant bounds.
$nexp 0190
Error : Component "%s" does not have a POINTER attribute so its dimension must be an explicit-shape array with constant bounds.
.PP
If a component has the \*CDIMENSION\fR attribute, but does not have the \*CPOINTER\fR
attribute, the \*CDIMENSION\fR must be an explicit-shape definition with constant
bounds.
.ME
$
$ Error : 0191
$msg  0191 A character length for a component declaration must be a constant expression.
$nexp 0191
Error : A character length for a component declaration must be a constant expression.
.PP
The character length for a component definition must be a constant expression.
.ME
$
$ Error : 0192
$msg  0192 The "* char-length" must only be specified for an object of type character.
$nexp 0192
Error : The "* char-length" must only be specified for an object of type character.
.PP
A "\*C*\fIchar_length\fR" is specified for a component or data object whose
type is not character.
.ME
$
$ Internal : 0193
$msg  0193 Unexpected value %d found in %s field for entry %d.
$nexp 0193
Internal : Unexpected value %d found in %s field for entry %d.
.PP
The value found in the symbol table field is not valid.  It is issued for:
.BL
Finding something beyond Structure in AT_TYPE.
.BL
Finding a function, with a NULL_IDX in ATP_RSLT_IDX.
.BL
If the count is nonzero for a derived type, ATO_CHAR_CPNT, ATO_POINTER_CPNT
or ATO_NUMERIC_CPNT must be set.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0194
$msg  0194 The DO variable must be the name of a variable.
$nexp 0194
Error : The DO variable must be the name of a variable.
.PP
An iterative \*CDO\fR statement has the form:
.CS
DO [\fIlabel\*C] [,] \fIdo_variable\*C = \fIscalar_numeric_expr\*C,
  \fIscalar_numeric_expr\*C [, \fIscalar_numeric_expr\*C]
.CE
The \*CDO\fR variable must be a named scalar variable;  for example, it must not be
a function name nor a named constant name.
.ME
$
$ Error : 0195
$msg  0195 In a masked array assignment, the mask expression and the variable being defined must be arrays of the same shape.
$nexp 0195
Error : In a masked array assignment, the mask expression and the variable being defined must be arrays of the same shape.
.PP
All masked assignment statements must match the shape of the mask expression.
.ME
$
$ Internal : 0196
$msg  0196 Function %s was called with a token whose length exceeds %d characters.
$nexp 0196
Internal : Function %s was called with a token whose length exceeds %d characters.
.PP
The symbol table search routines are optimized and have a limit on the size of
the item being searched.  This routine was called to search for an item
which exceeded the limit of the routine.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0197
$msg  0197 Unexpected syntax: "%s" was expected but found "%s".
$nexp 0197
Error : Unexpected syntax: "%s" was expected but found "%s".
.PP
The syntax of this statement is incorrect.  During parsing, the compiler
was looking for one thing, but found another.  This is a general message
used throughout the parser.
.ME
$
$ Error : 0198
$msg  0198 The "::" separator is illegal on the EXTERNAL and the INTRINSIC statements.
$nexp 0198
Error : The "::" separator is illegal on the EXTERNAL and the INTRINSIC statements.
.PP
The syntax for the \*CINTRINSIC\fR statement is:
.CS
  INTRINSIC \fIintrinsic_procedure-name_list
.CE
.PP
The syntax for the \*CEXTERNAL\fR statement is:
.CS
  EXTERNAL \fIexternal_name_list\fR
.CE
.ME
$
$ Error : 0199
$msg  0199 The DO variable must be an unqualified name.
$nexp 0199
Error : The DO variable must be an unqualified name.
.PP
The iterative \*CDO\fR statement has the form:
.CS
  DO [\fIlabel\*C] [,] \fIdo_variable\*C = \fIscalar_numeric_expr\*C,
      \fIscalar_numeric_expr\*C [, \fIscalar_numeric_expr\*C]
.CE
.PP
The \*CDATA\fR statement, some I/O statements, and an array constructor must contain
implied-\*CDO\fRs.  The forms of the implied-\*CDO\fRs are:
.CS
 (\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C = 
   \fIscalar_int_expr\*C, \fIscalar_int_expr\*C [, \fIscalar_int_expr\*C])

 (\fIio_implied_do_object_list\*C, \fIdo_variable\*C = 
   \fIscalar_numeric_expr\*C, \fIscalar_numeric_expr\*C 
     [, \fIscalar_numeric_expr\*C])

 (\fIac_value_list\*C, \fIac_do_variable\*C =
   \fIscalar_int_expr\*C, \fIscalar_int_expr\*C 
     [, \fIscalar_int_expr\*C])
.CE
The \*CDO\fR variable of the \*CDO\fR and I/O statements, the \fIdata_i_do_variable \fRof the 
\*CDATA\fR statement, and the \fIac_do_variable\fR of the array constructor are all 
called "\*CDO\fR variables".  In each case, the \*CDO\fR variable
must be a named variable; that is, it must be a simple, unqualified name.  For
example, it must not contain either a subscript list or the structure
component separator "%".
.ME
$
$ Ansi : 0200
$msg  0200 The use of edit descriptor "%c" is an extension to the Fortran standard.
$nexp 0200
Ansi : The use of edit descriptor "%c" is an extension to the Fortran standard.
.PP
A format specification contains an edit descriptor that is an extension to 
the Fortran standard.  The following nonstandard edit descriptors are
accepted by the compiler:
.TL 7
Zw
Hexadecimal integer
.TL
H...
Hollerith edit descriptors were deleted in the Fortran 95 standard, but the
compiler accepts them as an extension.
.TL
Rw
right-justified character
.TL
 $
suppress carriage control
.TL
[\fIn\fR]X
spacing, omitting \fIn\fR is nonstandard
.TL
\fIn\fR/
carriage control, \fIn\fR is nonstandard
.ME
$
$ Error : 0201
$msg  0201 An allocate object in an ALLOCATE statement must be either a pointer or an allocatable array.
$nexp 0201
Error : An allocate object in an ALLOCATE statement must be either a pointer or an allocatable array.
.PP
All arguments in an \*CALLOCATE\fR statement must be previously declared to be
either pointer or allocatable arrays.
.ME
$
$ Error : 0202
$msg  0202 The status variable for this ALLOCATE/DEALLOCATE statement must be scalar and integer, not constant or protected.
$nexp 0202
Error : The status variable for this ALLOCATE/DEALLOCATE statement must be scalar and integer, not constant or protected.
.PP
The variable used as the status variable, \*CSTAT = \fIstat_variable\fR, in an \*CALLOCATE\fR or \*CDEALLOCATE\fR
statement cannot be an array, must be of integer type, must not be a constant,
and must not be use-associated if it is protected.
.ME
$
$ Error : 0203
$msg  0203 The STAT= must follow all allocation items in an ALLOCATE statement.
$nexp 0203
Error : The STAT= must follow all allocation items in an ALLOCATE statement.
.PP
No allocation items in an \*CALLOCATE\fR statement must follow a status variable. 
\*CSTAT = \fIstat_variable\fR must be the last item in the list.
.ME
$
$ Error : 0204
$msg  0204 The number of subscripts is greater than the number of declared dimensions.
$nexp 0204
Error : The number of subscripts is greater than the number of declared dimensions.
.PP
An array reference of the form \fIa\*C(\fIs\*C[,\fIs\*C]...)\fR is being used.  The number of
subscripts in the reference should equal the number of dimensions
declared for the array in a \*CDIMENSION\fR, \*CCOMMON\fR, \*CPOINTER\fR or type statement.
As an extension to the Fortran standard, the compiler allows array references
to specify fewer subscripts than the declared number.  In this case,
the lower bounds of the remaining unspecified dimensions are used.
.ME
$
$ Error : 0205
$msg  0205 If an array is specified in an ALLOCATE statement, it must have an allocate shape specification list.
$nexp 0205
Error : If an array is specified in an ALLOCATE statement, it must have an allocate shape specification list.
.PP
An attempt was made to allocate an array in an \*CALLOCATE\fR statement without
supplying an allocate shape specification list.
The syntax of an allocate shape specification list is 
.CS
      [lower_bound :] upper_bound
.CE
.ME
$
$ Error : 0206
$msg  0206 The exponent in a constant initialization expression must be type integer.
$nexp 0206
Error : The exponent in a constant initialization expression must be type integer.
.PP
The Fortran standard requires that if exponentiation is used in a
constant initialization expression, it must have an integer exponent.
.ME
$
$ Internal : 0207
$msg  0207 Reset lex has attempted to reset source input to a line not in the source buffer.
$nexp 0207
Internal : Reset lex has attempted to reset source input to a line not in the source buffer.
.PP
The routine \*Creset_src_input\fR attempted to reset the source input index
to a line number that is no longer available in the source input buffer.
Source input should only be reset on the current line.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0208
$msg  0208 Using a Cray pointer as a DO variable is an extension to the Fortran standard.
$nexp 0208
Ansi : Using a Cray pointer as a DO variable is an extension to the Fortran standard.
.PP
A Cray pointer is being used as a \*CDO\fR
variable.  Support of Cray pointers is an extension to the Fortran standard.
.ME
$
$ Error : 0209
$msg  0209 There is no actual argument to correspond to dummy argument number %d.
$nexp 0209
Error : There is no actual argument to correspond to dummy argument number %d.
.PP
An alternate return dummy argument (\*C*\fR) does not have a matching label
actual argument.
.ME
$
$ Error : 0210
$msg  0210 "%s" has the %s attribute.  It must not be used in an initialization expression because it is not a constant.
$nexp 0210
Error : "%s" has the %s attribute.  It must not be used in an initialization expression because it is not a constant.
.PP
The compiler detected an illegal use of this object.  To be used in an
initialization expression, the object must be a constant.  The only attributes
that a constant may have are \*CPARAMETER\fR, \*CPRIVATE\fR or \*CPUBLIC\fR.
A constant may be given an explicit type and it may be declared to be an 
explicit-shape array.
.ME
$
$ Error : 0211
$msg  0211 Continuation is not allowed for this statement.
$nexp 0211
Error : Continuation is not allowed for this statement.
.PP
This continuation line in fixed source form does not follow a regular source 
line.  This error is issued when the first line of a program is a 
continuation line.
.ME
$
$ Error : 0212
$msg  0212 "%s" is typed as %s, therefore it must not have component references specified for it.
$nexp 0212
Error : "%s" is typed as %s, therefore it must not have component references specified for it.
.PP
The object in question is followed by a structure component name separator (%),
but the object has not been declared as a derived type.
.ME
$
$ Error : 0213
$msg  0213 "%s" is not a component of derived type "%s".
$nexp 0213
Error : "%s" is not a component of derived type "%s".
.PP
While parsing a component reference, the compiler 
detected a name that is not declared to be a component of the derived type.
.ME
$
$ Limit : 0214
$msg  0214 The maximum number, %d, of fatal errors has been exceeded.
$nexp 0214
Limit : The maximum number, %d, of fatal errors has been exceeded.
.PP
The compiler aborts when the maximum number of allowed
fatal errors is detected.  The maximum number is set to 100.  This can be
overridden with the \*C-dq\fR command-line option.
The \*C-dq\fR option allows for an unlimited number of fatal errors.
.ME
$
$ Error : 0215
$msg  0215 Dummy argument "%s" of statement function "%s" must have a character length that is an integer constant expression.
$nexp 0215
Error : Dummy argument "%s" of statement function "%s" must have a character length that is an integer constant expression.
.PP
If a dummy argument of a statement function is type character, its length 
must be an integer constant expression.  The compiler detected a 
statement function dummy argument whose type is character, but whose 
length is either assumed-length or variable length.
.ME
$
$ Error : 0216
$msg  0216 A character string must be less than %d characters when used as a dataset name or Boolean constant.
$nexp 0216
Error : A character string must be less than %d characters when used as a dataset name or Boolean constant.
.PP
The compiler detected a character string that will not fit in a 
machine word.  A dataset name or integer expression was expected.
A dataset name is an external file identifier in a control
information list in an I/O statement.
.ME
$
$ Error : 0217
$msg  0217 The DO loop expression must be type integer, default real, or double precision real.
$nexp 0217
Error : The DO loop expression must be type integer, default real, or double precision real.
.PP
Each expression in the \fIloop_control\fR portion of the \*CDO\fR statement must be 
numeric and of type integer, default real, or double precision real.
A \*CDO\fR loop expression of type default real or double precision real is an
obsolescent feature.  Type integer is the preferred choice.
.ME
$
$ Ansi : 0218
$msg  0218 A DO loop expression of type default real or double precision real is an obsolescent/deleted feature.
$nexp 0218
Ansi : A DO loop expression of type default real or double precision real is an obsolescent/deleted feature.
.PP
This feature was deleted in the Fortran 95 standard. The compiler supports it
as an extension.
.PP
An
expression of type integer should be used instead.
.ME
$
$ Error : 0219
$msg  0219 The DO variable must be type integer, default real, or double precision real.
$nexp 0219
Error : The DO variable must be type integer, default real, or double precision real.
.PP
The \*CDO\fR variable of the \*CDO\fR statement must be numeric and of type integer,
default real, or double precision real.  The use of a \*CDO\fR variable of
type default real or double precision real is an obsolescent feature.
Type integer is the preferred choice.
.ME
$
$ Ansi : 0220
$msg  0220 A DO variable of type default real or double precision real is an obsolescent/deleted feature.
$nexp 0220
Ansi : A DO variable of type default real or double precision real is an obsolescent/deleted feature.
.PP
This feature was deleted in the Fortran 95 standard. The compiler supports it
as an extension.
A \*CDO\fR variable of type
integer should be used instead.
.ME
$
$ Ansi : 0221
$msg  0221 Bound expressions other than integer are an extension to the Fortran standard.
$nexp 0221
Ansi : Bound expressions other than integer are an extension to the Fortran standard.
.PP
The Fortran standard requires all bound expressions to be type integer.
.ME
$
$ Error : 0222
$msg  0222 This DO statement expression must be scalar.
$nexp 0222
Error : This DO statement expression must be scalar.
.PP
In a \*CDO\fR statement of the form
.CS
   DO [\fIlabel\*C] [,] \fIdo_variable\*C = \fIscalar_numeric_expr\*C,
        \fIscalar_numeric_expr\*C [, \fIscalar_numeric_expr\*C]
.CE
.PP
each \fIscalar_numeric_expr\fR must be scalar.
.PP
In a \*CDO\fR statement of the form
.CS
   DO [\fIlabel\*C] [,] WHILE(\fIscalar_logical_expr\*C)
.CE
the \fIscalar_logical_expr\fR must be scalar.
.ME
$
$ Error : 0223
$msg  0223 The DO variable must be scalar.
$nexp 0223
Error : The DO variable must be scalar.
.PP
In a \*CDO\fR statement of the form
.CS
   DO [\fIlabel\*C] [,] \fIdo_variable\*C = \fIscalar_numeric_expr\*C,
        \fIscalar_numeric_expr\*C [, \fIscalar_numeric_expr\*C]
.CE
.PP
the \fIdo_variable\fR must be scalar.
.ME
$
$ Internal : 0224
$msg  0224 Semantic analysis of compiler generated DO loop expression failed.
$nexp 0224
Internal : Semantic analysis of compiler generated DO loop expression failed.
.PP
There are two expression trees that are generated by the compiler as part of
the representation of a \*CDO\fR statement:  the iteration count calculation and the 
calculation of the value of the \*CDO\fR variable.  Both involve only
already-established compiler temps.  Semantic analysis is only used to
propagate data types, and so on, up the expression tree therefore 
semantic analysis should not fail.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0225
$msg  0225 For [%s][%s], the error flag in table %s is TRUE (1), but the message number is 0.
$nexp 0225
Error : For [%s][%s], the error flag in table %s is TRUE (1), but the message number is 0.
.PP
This message is always followed by an internal message and compiler abort.
.PP
This message is issued by a debug routine that is called at main
initialization for debug compilations.  The routine goes through the semantic tables
and confirms that the flags and messages agree.  The tables involved are:
.TL 25
flag table
message table
.TL
\*Cobj_to_attr
attr_msg_num
.TL
obj_to_name
name_msg_num
.TL
obj_to_other
other_msg_num
.PP
Verify the entry in both tables and change one or the other so both 
agree.  If this message is issued, the combination is marked in error in the
table, but no error message is specified for the combination in the table.
.ME
$
$ Internal : 0226
$msg  0226 There are problems with the semantic tables.  See previous error messages.
$nexp 0226
Internal : There are problems with the semantic tables.  See previous error messages.
.PP
This internal error is issued if \*Cverify_semantic_tbls\fR has found any problems
in the semantic tables.  Fatal errors are issued for each problem.  This final
internal error is issued at the end to halt compilation.
.PP
This message should never be generated.  This is a bad compiler or a bad
installation.  Please notify your product support organization with this
error message number and any supporting information.  This message does
not indicate a problem with your code.
.ME
$
$ Error : 0227
$msg  0227 For [%s][%s], the error flag in table %s is FALSE (0), but the message number is %d.
$nexp 0227
Error : For [%s][%s], the error flag in table %s is FALSE (0), but the message number is %d.
.PP
This message is always followed by an internal message and compiler abort.
.PP
This message is issued by a debug routine that is called at main
initialization for debug compilations.  It goes through the semantic tables
and makes sure that the flags and messages agree.  The tables involved are:
.TL 25
flag table
message table
.TL
\*Cobj_to_attr
attr_msg_num
.TL
obj_to_name 
name_msg_num
.TL
obj_to_other
other_msg_num
.PP
Verify the entry in both tables and change one or the other so both
agree.  If this message is issued, the combination is legal, but the table has
an error message for this combination.  
.ME
$
$ Error : 0228
$msg  0228 The mode specifier for a BUFFER IN or BUFFER OUT statement must be type integer.
$nexp 0228
Error : The mode specifier for a BUFFER IN or BUFFER OUT statement must be type integer.
.PP
A \*CBUFFER IN\fR or \*CBUFFER OUT\fR statement contains an improper mode specifier.  In
the following statements, \fIm\fR, the mode specifier, must be an integer
expression:
.CS
      BUFFERIN (id,m) (bloc,eloc)
      BUFFEROUT (id,m) (bloc,eloc)
.CE
The mode specifier must not be an array expression.
.ME
$
$ Error : 0229
$msg  0229 The unit specifier or file identifier is not a valid data type or form.
$nexp 0229
Error : The unit specifier or file identifier is not a valid data type or form.
.PP
An I/O statement contains an improper unit or file identifier.  
.PP
A unit
identifier may be one of the following:
.BL
An integer expression with a value in the range 0 to 101.
.BL
An asterisk denoting the default unit.
.PP
A file identifier may be one of the following:
.BL
A character variable, array element, array, or substring specifying an internal file.
.BL
A string of up to 7 alphanumeric characters enclosed in apostrophes, specifying an external file name.
.ME
$
$ Error : 0230
$msg  0230 The mode specifier for the BUFFER IN or BUFFER OUT statement must be scalar.
$nexp 0230
Error : The mode specifier for the BUFFER IN or BUFFER OUT statement must be scalar.
.PP
The \*CBUFFER IN\fR or \*CBUFFER OUT\fR statement contains an improper mode specifier .  In
the following statements, \fIm\fR, the mode specifier, must be an integer
expression:
.CS
      BUFFERIN (\fIid\*C,\fIm\*C) (\fIbloc\*C,\fIeloc\*C)
      BUFFEROUT (\fIid\*C,\fIm\*C) (\fIbloc\*C,\fIeloc\*C)
.CE
.PP
The mode specifier must not be an array expression.
.ME
$
$ Error : 0231
$msg  0231 The character string exceeds the maximum dataset name size of %d characters.
$nexp 0231
Error : The character string exceeds the maximum dataset name size of %d characters.
.PP
The external file identifier in a control information list on an I/O
statement exceeds 7 characters.  File identifiers must consist of 1 to
7 alphanumeric characters on 64-bit architectures.  The limit is 4
characters on 32-bit architectures.
.ME
$
$ Error : 0232
$msg  0232 IMPLICIT NONE is specified in the local scope, therefore an explicit type must be specified for function "%s".
$nexp 0232
Error : IMPLICIT NONE is specified in the local scope, therefore an explicit type must be specified for function "%s".
.PP
When \*CIMPLICIT NONE\fR is set, all functions must have explicit types.
.ME
$
$ Error : 0233
$msg  0233 IMPLICIT NONE is specified in the host scope, therefore an explicit type must be specified for function "%s".
$nexp 0233
Error : IMPLICIT NONE is specified in the host scope, therefore an explicit type must be specified for function "%s".
.PP
When \*CIMPLICIT NONE\fR is set in a host scope, all functions must have explicit types,
including those in any contained scopes.
.ME
$
$ Error : 0234
$msg  0234 The DO WHILE expression must be type logical.
$nexp 0234
Error : The DO WHILE expression must be type logical.
.PP
In a \*CDO\fR statement of the form:
.CS
 DO [\fIlabel\*C] [,] WHILE (\fIscalar_logical_expr\*C)
.CE
.PP
the \fIscalar_logical_expr\fR must be type logical.
.ME
$
$ Error : 0235
$msg  0235 I/O list items of a derived type which have a pointer or allocatable component are not allowed.
$nexp 0235
Error : I/O list items of a derived type which have a pointer or allocatable component are not allowed.
.PP
If a derived type ultimately contains a pointer or allocatable component,
an object of this
type must not appear as an I/O input item nor as the result of the evaluation
of an I/O output list item.
.ME
$
$ Internal : 0236
$msg  0236 NULL_IDX encountered when completing a compiler generated CONTINUE statement.
$nexp 0236
Internal : NULL_IDX encountered when completing a compiler generated CONTINUE statement.
.PP
To complete a compiler generated \*CCONTINUE\fR statement, continue_stmt_semantics
searches for a statement header (SH) following the current SH that is not
compiler generated and that has a nonzero line number.  This internal error
message is issued when the end of the chain of statement headers was
encountered without finding a statement header that satisfies the above
criteria.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Limit : 0237
$msg  0237 Maximum table size has been exceeded for the "%s".
$nexp 0237
Limit : Maximum table size has been exceeded for the "%s".
.PP
An internal error condition has occured because an internal table has grown
too large for its index field size.  Generally this is caused because the
program is too large for the compiler to handle.  Splitting your code into
multiple compilation units may allow compilation to successfully complete.
.PP
Please notify your product support organization, so that we may verify that
a compiler limit has been reached.
.ME
$
$ Error : 0238
$msg  0238 "%s" is declared as a named constant.  The type is assumed to be %s.
$nexp 0238
Error : "%s" is declared as a named constant.  The type is assumed to be %s.
.PP
The compiler detected an attempt to retype a named constant via a
type declaration statement or an \*CIMPLICIT\fR statement. This is only legal 
if the type confirms the implicit type of the object.
.CS
     PARAMETER (A = 3.0)
     INTEGER A               \fR! Illegal\*C

     PARAMETER (I = 4)
     INTEGER I               \fR! Legal\*C

     PARAMETER (I = 4)
     IMPLICIT INTEGER (I)    \fR! Legal\*C

     PARAMETER (I = 4)
     IMPLICIT CHARACTER (I)  \fR! Illegal
.CE
.ME
$
$ Error : 0239
$msg  0239 "%s" is initialized in a DATA statement.  The type is assumed to be %s.
$nexp 0239
Error : "%s" is initialized in a DATA statement.  The type is assumed to be %s.
.PP
The compiler detected an attempt to retype an object that is already    
initialized.  This is only legal if the type confirms the implicit type 
of the object.
.CS
     DATA A /3/
     INTEGER A	\fR! This is illegal\*C

     DATA I /3/
     INTEGER I	\fR! Legal
.CE
.ME
$
$ Error : 0240
$msg  0240 External function "%s" is referenced in a bounds specification expression.  It must have a nonpointer scalar result.
$nexp 0240
Error : External function "%s" is referenced in a bounds specification expression.  It must have a nonpointer scalar result.
.PP
It is an extension to the Fortran standard to allow external function calls
in array dimension bound declarators or character length declarators.
These functions must not have array-valued or pointer-valued results.
.ME
$
$ Ansi : 0241
$msg  0241 The nonblock or shared-termination DO construct is an obsolescent feature.
$nexp 0241
Ansi : The nonblock or shared-termination DO construct is an obsolescent feature.
.PP
This feature was declared obsolescent in the Fortran 2003 standard.
If a \*CDO\fR statement contains a label and the loop
termination statement is a statement other than \*CEND DO\fR or \*CCONTINUE\fR, the loop
is defined to be a nonblock \*CDO\fR construct.  The \*CCONTINUE\fR or \*CEND DO\fR statement 
should be used to terminate a \*CDO\fR loop.  If multiple \*CDO\fR loops terminate with
the same statement, a separate \*CCONTINUE\fR or \*CEND DO\fR statement should be used to
terminate each nested \*CDO\fR loop.
.ME
$
$ Error : 0242
$msg  0242 The termination statement of a nonblock DO construct must not be an unconditional GO TO statement.
$nexp 0242
Error : The termination statement of a nonblock DO construct must not be an unconditional GO TO statement.
.PP
If a \*CDO\fR statement contains a label and the loop termination statement is a
statement other than \*CEND DO\fR or \*CCONTINUE\fR, the loop is defined to be a nonblock
\*CDO\fR construct.  An unconditional \*CGO TO\fR statement must not be used as the 
termination statement of a nonblock \*CDO\fR construct.
.ME
$
$ Error : 0243
$msg  0243 The termination statement of a nonblock DO construct must not be an assigned GO TO statement.
$nexp 0243
Error : The termination statement of a nonblock DO construct must not be an assigned GO TO statement.
.PP
If a \*CDO\fR statement contains a label and the loop termination statement is a
statement other than \*CEND DO\fR or \*CCONTINUE\fR, the loop is defined to be a nonblock
\*CDO\fR construct.  An assigned \*CGO TO\fR statement must not be used as the
termination statement of a nonblock \*CDO\fR construct.
.ME
$
$ Error : 0244
$msg  0244 The termination statement of a nonblock DO construct must not be a %s statement.
$nexp 0244
Error : The termination statement of a nonblock DO construct must not be a %s statement.
.PP
If a \*CDO\fR statement contains a label and the loop termination statement is an
\fIaction_stmt\fR other than \*CEND DO\fR or \*CCONTINUE\fR, the loop is defined to be a nonblock
\*CDO\fR construct.  The following \fIaction_stmt\fRs must not be used as the termination
statement of a nonblock \*CDO\fR construct:  \*CRETURN\fR, \*CSTOP\fR, \*CEXIT\fR, \*CCYCLE\fR, \*CEND FUNCTION\fR,
\*CEND SUBROUTINE\fR, \*CEND PROGRAM\fR, or arithmetic \*CIF\fR.
.ME
$
$ Internal : 0245
$msg  0245 The number of arguments in the call list is greater than the largest list expected.
$nexp 0245
Internal : The number of arguments in the call list is greater than the largest list expected.
.PP
The number of actual arguments is greater than the allocated internal table 
size.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0246
$msg  0246 The termination statement of a nonblock DO construct must not be an outmoded IF statement.
$nexp 0246
Error : The termination statement of a nonblock DO construct must not be an outmoded IF statement.
.PP
If a \*CDO\fR statement contains a label and the loop termination statement is a
statement other than \*CEND DO\fR or \*CCONTINUE\fR, the loop is defined to be a nonblock
\*CDO\fR construct.  An outmoded \*CIF\fR statement is an indirect logical \*CIF\fR statement or
a two-branch arithmetic \*CIF\fR statement.  These obsolete features have been 
carried forward from FORTRAN 77.  These statements have been replaced by 
alternatives that enhance the portability of Fortran programs.  The \*CIF\fR 
construct or logical \*CIF\fR should be used in place of both of these outmoded
forms.  
.ME
$
$ Error : 0247
$msg  0247 A subscript or substring expression in an EQUIVALENCE statement must be an integer constant expression.
$nexp 0247
Error : A subscript or substring expression in an EQUIVALENCE statement must be an integer constant expression.
.PP
Each subscript or substring expression in an equivalence item must be a scalar integer
constant expression.
.ME
$
$ Error : 0248
$msg  0248 The DO statement label is already defined.
$nexp 0248
Error : The DO statement label is already defined.
.PP
The termination statement label specified by the \*CDO\fR statement was defined
earlier in the scoping unit.  By definition, the loop termination
statement must follow the \*CDO\fR statement.  Therefore, the label must be on a 
statement following the \*CDO\fR statement.  
.ME
$
$ Internal : 0249
$msg  0249 Compiler internal error in fold_relationals.  Unexpected types of operands.
$nexp 0249
Internal : Compiler internal error in fold_relationals.  Unexpected types of operands.
.PP
The routine fold_relationals has found operand types that are not valid.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0250
$msg  0250 Array syntax is not allowed in an EQUIVALENCE statement.
$nexp 0250
Error : Array syntax is not allowed in an EQUIVALENCE statement.
.PP
Sectioned array references are not allowed in an \*CEQUIVALENCE\fR statement.
.ME
$
$ Internal : 0251
$msg  0251 Compiler internal error in fold_relationals.  Unexpected operator.
$nexp 0251
Internal : Compiler internal error in fold_relationals.  Unexpected operator.
.PP
The routine \*Cfold_relationals\fR was called to fold an operator that it was not
intended to see.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0252
$msg  0252 The operands in this array syntax operation are not conformable.
$nexp 0252
Error : The operands in this array syntax operation are not conformable.
.PP
Both operands of an array syntax operation must be shape conformant.
The two arrays that have constant subscripts are not shape conformant.
.ME
$
$ Error : 0253
$msg  0253 The left and right hand sides of this array syntax assignment must be conformable arrays.
$nexp 0253
Error : The left and right hand sides of this array syntax assignment must be conformable arrays.
.PP
When an assignment statement is array syntax, the left side and the right
side must be shape conformant.
.ME
$
$ Caution : 0254
$msg  0254 The values of the DO statement expressions prevent the loop from executing.
$nexp 0254
Caution : The values of the DO statement expressions prevent the loop from executing.
.PP
The iterative \*CDO\fR statement has the form:
.CS
    DO [\fIlabel\*C] [,] \fIdo_variable\*C = 
	\fIstart_expr\*C, \fIend_expr\*C [, \fIinc_expr]
.CE
.PP
The iteration count for the \*CDO\fR loop is calculated from:
.CS
    MAX( INT( (\fIend_expr\*C - \fIstart_expr\*C + \fIinc_expr\*C) / 
	\fIinc_expr\fR), 0)
.CE
.PP
The iteration count is zero for both of the following cases:
.CS
    \fIstart_expr\fR > \fIend_expr\fR  and  \fIinc_expr\fR > 0,  
             or
    \fIstart_expr\fR < \fIend_expr\fR  and  \fIinc_expr\fR < 0
.CE
.PP
If the iteration count is zero, the loop will not be executed.
.ME
$
$ Error : 0255
$msg  0255 The value of the increment expression must not be zero.
$nexp 0255
Error : The value of the increment expression must not be zero.
.PP
The \*CDO\fR statement contains an increment expression that has a zero value. 
It must be greater than zero or less than zero.
.ME
$
$ Error : 0256
$msg  0256 Dummy argument "%s" has the POINTER or ALLOCATABLE attribute, so the actual argument must have the same attribute.
$nexp 0256
Error : Dummy argument "%s" has the POINTER or ALLOCATABLE attribute, so the actual argument must have the same attribute.
.PP
If a dummy argument has the \*CPOINTER\fR attribute, the actual argument must
also have the \*CPOINTER\fR attribute.
If a dummy argument has the \*CALLOCATABLE\fR attribute, the actual argument
must be an entire array having the \*CALLOCATABLE\fR attribute.
.ME
$
$ Internal : 0257
$msg  0257 An illegal item "%d" is detected in field %s of the attribute table.
$nexp 0257
Internal : An illegal item "%d" is detected in field %s of the attribute table.
.PP
An unexpected value has been found in the symbol tables.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0258
$msg  0258 This actual argument is an assumed-size array, therefore it must not be associated with an assumed-shape dummy argument.
$nexp 0258
Error : This actual argument is an assumed-size array, therefore it must not be associated with an assumed-shape dummy argument.
.PP
An assumed-shape dummy argument cannot be associated with an assumed-size
actual argument.
.ME
$
$ Error : 0259
$msg  0259 Recursive reference to "%s", a %s, is illegal in a bounds specification expression.
$nexp 0259
Error : Recursive reference to "%s", a %s, is illegal in a bounds specification expression.
.PP
Some function references are allowed in bounds specification expressions as part
of the Fortran standard, and others are allowed as an extension to the Fortran
standard. However, recursive function references are not allowed in bounds 
specification expressions.  The compiler detected something similar to the 
following example:
.CS
      FUNCTION IFUNC()
      RECURSIVE IFUNC
      DIMENSION A(IFUNC())   
.CE
.PP
The reference to \*CIFUNC\fR is illegal because a bounds expression must be
computed at the entry point.
.ME
$
$ Internal : 0260
$msg  0260 Unexpected block stack order.
$nexp 0260
Internal : Unexpected block stack order.
.PP
If the current block type is greater than Interface_Body_Blk, procedure
cif_begin_scope_rec expects it to be because one of these block types was
the first statement in the main program.  Either the Block Stack has been
corrupted or cif_begin_scope_rec needs to be corrected because it is making 
an incorrect assumption.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0261
$msg  0261 The %s statement is not allowed in a function subprogram.
$nexp 0261
Error : The %s statement is not allowed in a function subprogram.
.PP
The \*CPRIVATE\fR and \*CPUBLIC\fR statements are not allowed in a function
subprogram.
.PP
The following statements must be inside an interface block, scoping unit, or construct 
to be in a function subprogram.
.BL
\*CSEQUENCE, END TYPE\fR in a derived type definition
.BL
\*CMODULE PROCEDURE\fR in a generic interface block
.BL
\*CELSE, ELSEIF, END IF\fR in an \*CIF\fR construct
.BL
\*CCASE, END SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE, END WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE, EXIT, END DO\fR in a \*CDO\fR construct
.BL
\*CFUNCTION, SUBROUTINE, END SUBROUTINE, END INTERFACE\fR in an 
interface block
.ME
$
$ Error : 0262
$msg  0262 The %s statement is not in the range of a matching DO construct.
$nexp 0262
Error : The %s statement is not in the range of a matching DO construct.
.PP
The \*CCYCLE\fR and \*CEXIT\fR statements must be specified in the range of a \*CDO\fR construct.
If the \*CCYCLE\fR or \*CEXIT\fR statement refers to a \*CDO\fR construct name, it must be within
the range of the \*CDO\fR construct with the same \*CDO\fR construct name.
.ME
$
$ Internal : 0263
$msg  0263 The semantics pass statement driver encountered an illegal or unknown statement type.
$nexp 0263
Internal : The semantics pass statement driver encountered an illegal or unknown statement type.
.PP
The driver that applies semantic processing to each statement in the semantics
pass selects the appropriate semantics routine from an array of function 
pointers.  The index into the array is not valid.  It must be a positive value,
but is probably zero or a negative value.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0264
$msg  0264 The %s statement is not allowed following a CONTAINS statement.  Expecting FUNCTION, SUBROUTINE or END statement.
$nexp 0264
Error : The %s statement is not allowed following a CONTAINS statement.  Expecting FUNCTION, SUBROUTINE or END statement.
.PP
The only statements allowed following a \*CCONTAINS\fR statement are \*CSUBROUTINE\fR,
\*CFUNCTION\fR, and \*CEND\fR.  \*CSUBROUTINE\fR and \*CFUNCTION\fR start a new internal or 
module subprogram.
.ME
$
$ Ansi : 0265
$msg  0265 Specifying the NAMELIST statement after the first executable statement is an extension to the Fortran standard.
$nexp 0265
Ansi : Specifying the NAMELIST statement after the first executable statement is an extension to the Fortran standard.
.PP
The Fortran standard requires all \*CNAMELIST\fR statements to be in the
specification part of a program unit.  It is an extension to the
Fortran standard to allow the \*CNAMELIST\fR statement to be interspersed with
executable statements.  However, all definitions of a namelist group must 
occur before any reference to the namelist group.
.ME
$
$ Ansi : 0266
$msg  0266 The use of edit descriptor -nX is an extension to the Fortran standard.
$nexp 0266
Ansi : The use of edit descriptor -nX is an extension to the Fortran standard.
.PP
The use of a negative value with the X edit descriptor is an extension to 
the Fortran standard.
.ME
$
$ Error : 0267
$msg  0267 The %s statement is not allowed in the THEN block of an IF construct.
$nexp 0267
Error : The %s statement is not allowed in the THEN block of an IF construct.
.PP
The following statements are allowed in an \*CIF\fR construct:
.PP
.nf
\*CALLOCATE               ASSIGN
BACKSPACE              BUFFER
CALL                   CLOSE
CONTINUE               DATA
DEALLOCATE             DECODE
DO                     ENCODE
ENDFILE                ENDIF
ELSE                   ELSEIF
FORMAT                 GOTO
IF                     INQUIRE
NAMELIST               NULLIFY
OPEN                   PAUSE
PRINT                  READ
RETURN                 REWIND
SELECT                 STOP
WHERE                  WRITE\fR
assignment
.fi
.PP
The following statements are allowed if the listed condition is met.
.BL
\*CCASE\fR, \*CEND SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE\fR, \*CEND WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE\fR, \*CEXIT\fR, \*CEND DO\fR in a \*CDO\fR construct
.ME
$
$ Error : 0268
$msg  0268 The %s statement is not allowed in a DO construct.
$nexp 0268
Error : The %s statement is not allowed in a DO construct.
.PP
The following statements are allowed in a \*CDO\fR construct:
.PP
.nf
\*CALLOCATE               ASSIGN
BACKSPACE              BUFFER
CALL                   CLOSE
CONTINUE               DATA
DEALLOCATE             DECODE
DO                     ENCODE
ENDFILE                ENDIF
ELSE                   ELSEIF
FORMAT                 GOTO
IF                     INQUIRE
NAMELIST               NULLIFY
OPEN                   PAUSE
PRINT                  READ
RETURN                 REWIND
SELECT                 STOP
WHERE                  WRITE\fR
assignment
.fi
.PP
The following statements are allowed in the listed constructs.
.BL
\*CCASE\fR, \*CEND SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSE\fR, \*CELSEIF\fR, \*CEND IF\fR in an \*CIF\fR construct
.BL
\*CELSEWHERE\fR, \*CEND WHERE\fR in a \*CWHERE\fR construct
.ME
$
$ Error : 0269
$msg  0269 The %s statement is not allowed following a SELECT CASE statement.
$nexp 0269
Error : The %s statement is not allowed following a SELECT CASE statement.
.PP
The \*CCASE\fR statement is the only statement that can follow a \*CSELECT CASE\fR
statement.  The compiler found another statement (not a \*CCASE\fR statement)
following the \*CSELECT CASE\fR statement.
.ME
$
$ Error : 0270
$msg  0270 The %s statement is not allowed in a WHERE construct.
$nexp 0270
Error : The %s statement is not allowed in a WHERE construct.
.PP
Only array assignment statements are allowed in the \*CWHERE\fR block or \*CELSEWHERE\fR
block of a \*CWHERE\fR construct.  The compiler found another statement (not
an array assignment statement) in a \*CWHERE\fR or \*CELSEWHERE\fR block.
.ME
$
$ Error : 0271
$msg  0271 The %s statement is not allowed in an interface body.
$nexp 0271
Error : The %s statement is not allowed in an interface body.
.PP
The following statements are allowed in an interface body.
.TL 30
\*CALLOCATABLE
COMMON\fR 
.TL
derived type \fRdefinitions
\*CDIMENSION\fR statement
.TL
\*CEND FUNCTION
END SUBROUTINE 
.TL
EQUIVALENCE 
EXTERNAL 
.TL
IMPLICIT 
\*CIMPLICIT NONE
.TL
INTENT 
INTRINSIC 
.TL
NAMELIST 
OPTIONAL 
.TL
PARAMETER 
POINTER
.TL
SAVE 
TARGET
.TL
\fRtype declaration\*C 
USE 
.PP
\fR The following statements are allowed if the listed condition is met:
.BL
\*CSEQUENCE, END TYPE\fR in a derived type definition
.BL
\*CPUBLIC\fR, \*CPRIVATE\fR in a module program unit
.ME
$
$ Error : 0272
$msg  0272 The %s statement is not allowed in a subroutine subprogram.
$nexp 0272
Error : The %s statement is not allowed in a subroutine subprogram.
.PP
The \*CPRIVATE\fR and \*CPUBLIC\fR statements are not allowed in a subroutine
subprogram.
.PP
\fR These statements must be inside an interface block, scoping unit, or a construct
to be in a subroutine subprogram.
.BL
\*CSEQUENCE, END TYPE\fR in a derived type definition
.BL
\*CMODULE PROCEDURE\fR in a generic interface block
.BL
\*CELSE, ELSEIF, END IF\fR in an \*CIF\fR construct
.BL
\*CCASE, END SELECT\fR in a \*CCASE\fR construct
.BL
\*CELSEWHERE, END WHERE\fR in a \*CWHERE\fR construct
.BL
\*CCYCLE, EXIT, END DO\fR in a \*CDO\fR construct
.BL
\*CFUNCTION, END FUNCTION, SUBROUTINE, END SUBROUTINE, END INTERFACE\fR in an
interface block
.ME
$
$ Error : 0273
$msg  0273 The %s attribute is specified more than once for the component declaration.
$nexp 0273
Error : The %s attribute is specified more than once for the component declaration.
.PP
An attribute must only be specified once for a component.  The \*CDIMENSION\fR or
the \*CPOINTER\fR attribute has been specified more than once for the component, as in the
following example:
.CS
  TYPE :: ABC
    REAL, POINTER, POINTER :: IJK ! illegal
  END TYPE ABC
.CE
.ME
$
$ Ansi : 0274
$msg  0274 Fortran requires all intrinsic procedure actual arguments to be type integer or character for restricted expressions.
$nexp 0274
Ansi : Fortran requires all intrinsic procedure actual arguments to be type integer or character for restricted expressions.
.PP
In the Fortran standard, restricted expressions allow elemental function
references.  Each argument to the intrinsic must be type integer or character.
The compiler allows arguments to be typed other than integer or character, 
if the result of the expression is type integer or character.
.ME
$
$ Error : 0275
$msg  0275 The PUBLIC and/or PRIVATE attribute is specified more than once for derived type "%s".
$nexp 0275
Error : The PUBLIC and/or PRIVATE attribute is specified more than once for derived type "%s".
.PP
The \*CPUBLIC\fR or \*CPRIVATE\fR attribute can only be declared once for the derived type.
.ME
$
$ Error : 0276
$msg  0276 "%s" is a %s.  It must be a constant to be used in an initialization expression.
$nexp 0276
Error : "%s" is a %s.  It must be a constant to be used in an initialization expression.
.PP
The compiler detected an illegal use of the object.
It must be a constant to be in an initialization expression.
.ME
$
$ Error : 0277
$msg  0277 "%s" is not valid as a keyword for this call to "%s".
$nexp 0277
Error : "%s" is not valid as a keyword for this call to "%s".
.PP
The compiler detected an actual argument keyword that does not match a
dummy argument name in the explicit interface for the called routine.
.ME
$
$ Internal : 0278
$msg  0278 No semantics routine exists for statement type %s.
$nexp 0278
Internal : No semantics routine exists for statement type %s.
.PP
The statement level semantics processing driver encountered a statement
header that contains a statement type value for a statement for which there is
no semantic routine.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0279
$msg  0279 The EXTERNAL attribute has been specified for "%s", the program unit being compiled.  This is nonstandard.
$nexp 0279
Ansi : The EXTERNAL attribute has been specified for "%s", the program unit being compiled.  This is nonstandard.
.PP
The compiler detected the following:   
.CS
    SUBROUTINE JOE()
    EXTERNAL JOE  ! This is nonstandard
    RETURN
    END
.CE
.ME
$
$ Ansi : 0280
$msg  0280 Fortran requires all intrinsic procedure actual arguments to be type integer for specification expressions.
$nexp 0280
Ansi : Fortran requires all intrinsic procedure actual arguments to be type integer for specification expressions.
.PP
In the Fortran standard, specification expressions allow elemental function 
references.  Each argument to the intrinsic must be type integer.  The compiler
allows arguments to be typed other than integer, as long as the result of the
expression is type integer.
.ME
$
$ Error : 0281
$msg  0281 The left hand side of an assignment statement must be a variable or a function result.
$nexp 0281
Error : The left hand side of an assignment statement must be a variable or a function result.
.PP
The left side of this assignment statement is not valid.  This could be
caused by assigning a value to a constant, external subprogram name,
namelist group name, or some other entity other than a variable or the
function result name of the current function.
.ME
$
$ Error : 0282
$msg  0282 Function "%s" is declared in an interface block, therefore it must not be typed assumed-length character.
$nexp 0282
Error : Function "%s" is declared in an interface block, therefore it must not be typed assumed-length character.
.PP
The only functions that can be typed as assumed-length character are external
functions.  If a function is declared inside an interface block, it must not
be typed as assumed-length character.  Interface blocks are only used for
explicitly declared external subprograms.
.ME
$
$ Error : 0283
$msg  0283 The name specified on the %s statement must match the %s name "%s".
$nexp 0283
Error : The name specified on the %s statement must match the %s name "%s".
.PP
\fRThe compiler detected that the name specified on the \*CEND\fR statement does
not match the name of the program unit or derived type.
.PP
The names must match for the following statements:
.nf
\*CPROGRAM/END PROGRAM \fIprogram_name\*C
MODULE/END MODULE  \fImodule_name\*C
BLOCKDATA/END BLOCK DATA \fIblock_data_name\*C
SUBROUTINE/END SUBROUTINE \fIsubroutine_name\*C
FUNCTION/END FUNCTION \fIfunction_name\*C
TYPE/END TYPE \fItype_name\fR
.fi
.ME
$
$ Error : 0284
$msg  0284 The %s construct has construct name "%s", therefore the %s statement must specify the same construct name.
$nexp 0284
Error : The %s construct has construct name "%s", therefore the %s statement must specify the same construct name.
.PP
If the \*CIF\fR, \*CDO\fR, or \*CCASE\fR construct has a construct name, the \*CEND IF\fR,
\*CEND DO\fR, or \*CEND SELECT\fR statement must specify the same construct name.  The
compiler detected a difference between the construct names or a construct
name is missing on the \*CEND\fR statement.
.ME
$
$ Error : 0285
$msg  0285 If the %s construct does not have a construct name, the %s statement must not have a construct name specified.
$nexp 0285
Error : If the %s construct does not have a construct name, the %s statement must not have a construct name specified.
.PP
If the \*CDO\fR, \*CIF\fR, or \*CCASE\fR construct does not have a construct name
specified, the corresponding \*CEND DO\fR, \*CEND IF\fR, or \*CEND SELECT\fR statement must not
have a construct name specified.
.ME
$
$ Error : 0286
$msg  0286 A derived type type-name must not be the same as the name of the intrinsic type %s.
$nexp 0286
Error : A derived type type-name must not be the same as the name of the intrinsic type %s.
.PP
The compiler detected one of the following:
.CS
     TYPE :: INTEGER
     TYPE :: REAL
     TYPE :: DOUBLE PRECISION
     TYPE :: COMPLEX
     TYPE :: CHARACTER
     TYPE :: LOGICAL
.CE
.PP
All of the above are illegal, because 
a derived type type-name must not be the
same as the name of any intrinsic type.
.ME
$
$ Warning : 0287
$msg  0287 The result of function name "%s" in the function subprogram is not defined.
$nexp 0287
Warning : The result of function name "%s" in the function subprogram is not defined.
.PP
The end of a function was reached, and nowhere in the function was 
the function return value defined or assigned.  The
function return value must be defined during execution of the function.
.ME
$
$ Error : 0288
$msg  0288 A termination statement is missing for this DO statement.
$nexp 0288
Error : A termination statement is missing for this DO statement.
.PP
The compiler detected that the \*CDO\fR statement has no corresponding
termination statement.  If the \*CDO\fR statement does not specify a label, the DO
loop must be terminated with an \*CEND DO\fR statement.  If the \*CDO\fR statement   
specifies a label, the \*CDO\fR loop must be terminated with an \*CEND DO\fR statement or 
any action statement other than the following statements:  
.CS
    \fRunconditional\*C GO TO
    \fRassigned\*C GO TO
    RETURN
    STOP
    EXIT
    CYCLE
    END FUNCTION
    END SUBROUTINE
    END PROGRAM
    \fRarithmetic \*CIF\fR
.ME
$
$ Error : 0289
$msg  0289 This %s statement has no matching %s statement.
$nexp 0289
Error : This %s statement has no matching %s statement.
.PP
The compiler cannot find the beginning statement for the block that this \*CEND\fR
statement is closing.  The following \*CEND\fR statements close the corresponding 
blocks:
.CS
 END              PROGRAM, MODULE, BLOCK DATA,
                     FUNCTION, SUBROUTINE
 END PROGRAM      PROGRAM
 END FUNCTION     FUNCTION
 END SUBROUTINE   SUBROUTINE
 END BLOCK DATA   BLOCK DATA
 END MODULE       MODULE
 END IF           IF
 END DO           DO
 END SELECT       SELECT CASE
 END WHERE        WHERE
 END INTERFACE    INTERFACE
 END TYPE         TYPE
.CE
.ME
$
$ Error : 0290
$msg  0290 Derived type "%s" must have at least one component declared for it.
$nexp 0290
Error : Derived type "%s" must have at least one component declared for it.
.PP
The compiler detected no components declared for the derived type ending
at this statement.  The syntax for a derived type definition requires at least
one component declaration and is as follows:
.CS
    derived_type_stmt
      [private_sequence_stmt]...
      component_def_stmt
      [component_def_stmt]...
    end_type_stmt
.CE
.ME
$
$ Error : 0291
$msg  0291 An END statement is missing for this %s statement.
$nexp 0291
Error : An END statement is missing for this %s statement.
.PP
The compiler detected that one of the following syntactic constructs is 
missing its \*CEND\fR statement:  a module, a block data subprogram, a subroutine
subprogram, a function subprogram, an \*CIF\fR construct, a \*CDO\fR construct, a \*CCASE\fR
construct, a \*CWHERE\fR construct, an interface block, an interface body, or
a derived type definition.  These are all required to have an \*CEND\fR statement.
.ME
$
$ Error : 0292
$msg  0292 "%s" is specified as the module name on a USE statement, but the compiler cannot find it.
$nexp 0292
Error : "%s" is specified as the module name on a USE statement, but the compiler cannot find it.
.PP
The compiler cannot locate the module name specified on the \*CUSE\fR statement.
The compiler searches through all modules specified before the current program
unit.  If it cannot find the module there, it then searchs all files specified
on the \*C-p\fR command-line option.
.ME
$
$ Error : 0293
$msg  0293 This unnamed main program unit is missing an END statement.
$nexp 0293
Error : This unnamed main program unit is missing an END statement.
.PP
The compiler detected a premature end of file.  A main program unit must be 
terminated by an \*CEND\fR statement.  An unnamed main program unit is a program
unit that has no \*CPROGRAM\fR, \*CSUBROUTINE\fR, \*CFUNCTION\fR, \*CMODULE\fR or \*CBLOCKDATA\fR statement
as its first statement.
.ME
$
$ Error : 0294
$msg  0294 Equivalence-object "%s" must be a sequence derived type.
$nexp 0294
Error : Equivalence-object "%s" must be a sequence derived type.
.PP
If an object appears in an \*CEQUIVALENCE\fR statement and is derived type,
it must be a sequence derived type.
.ME
$
$ Internal : 0295
$msg  0295 Routine %s expected LA_CH input to be %s.
$nexp 0295
Internal : Routine %s expected LA_CH input to be %s.
.PP
A routine has the built-in assumption that the lookahead character be the 
specified character.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0296
$msg  0296 PRINTMSG received a zero line number.  The message number to print is %d.  The column number is %d.
$nexp 0296
Internal : PRINTMSG received a zero line number.  The message number to print is %d.  The column number is %d.
.PP
All messages (except Log messages which are output to standard error) must
have a nonzero line number.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0297
$msg  0297 IMPLICIT NONE is specified in the host scope, therefore an explicit type must be specified for data object "%s".
$nexp 0297
Error : IMPLICIT NONE is specified in the host scope, therefore an explicit type must be specified for data object "%s".
.PP
When \*CIMPLICIT NONE\fR is specified in a host scope, all data objects must
have explicit types, including those in any contained scopes.
.ME
$
$ Error : 0298
$msg  0298 Only one IMPLICIT NONE statement is allowed in a scope.
$nexp 0298
Error : Only one IMPLICIT NONE statement is allowed in a scope.
.PP
When an \*CIMPLICIT NONE\fR statement is specified in a scoping unit, there must
be no other \*CIMPLICIT\fR statements in the scoping unit.
.ME
$
$ Error : 0299
$msg  0299 An assignment can not be made to a function name when a separate function result variable has been declared.
$nexp 0299
Error : An assignment can not be made to a function name when a separate function result variable has been declared.
.PP
An attempt was made to assign a value to the name of the
function (function result variable) when the function declaration 
specifies a separate function result
variable.  This result variable must be used instead.
.ME
$
$ Error : 0300
$msg  0300 Operators "=, =>, and %%" must not be used as defined operators.
$nexp 0300
Error : Operators "=, =>, and %%" must not be used as defined operators.
.PP
The compiler detected the operator =, =>, or % being used as a 
\fIdefined_operator\fR in \*COPERATOR(\fIdefined_operator\*C)\fR.  Valid 
\fIdefined_operator\fRs are:
.CS
**	*	/	+
-	//	.EQ.	.NE.
.LT.	.LE.	.GT.	.GE.
==	/=	<	<=
>	>=	.NOT.	.AND.
.OR.	.EQV.	.NEQV.	
\fIdefined-unary-op
defined-binary-op 
.CE
.PP
NOTE:  \fIdefined-unary-op\fR and \fIdefined-binary-op\fR are \*C.\fIletter\*C[\fIletter\*C]...\fR .
.ME
$
$ Warning : 0301
$msg  0301 Binary output must be requested for a module information file for module "%s" to be created.
$nexp 0301
Warning : Binary output must be requested for a module information file for module "%s" to be created.
.PP
A module information file will not be created because a binary output file
is not being created.  The module information file resides in the binary file,
therefore it cannot be written.  Specifying \*C-dB \fRon the command line or
generating an assembly language file disables generation of the binary file.
.ME
$
$ Error : 0302
$msg  0302 A rank %d operand and a rank %d operand are not conformant for "%s".
$nexp 0302
Error : A rank %d operand and a rank %d operand are not conformant for "%s".
.PP
A binary operator in an array syntax expression must have rank conformance.
This means that the ranks must be equal or one or both of the operands
must be scalar.
.ME
$
$ Error : 0303
$msg  0303 Data type %s is not allowed with %s for the operation "%s".
$nexp 0303
Error : Data type %s is not allowed with %s for the operation "%s".
.PP
An expression contains two operands of data types that are illegal for
the operator being used.
.ME
$
$ Error : 0304
$msg  0304 Missing left parenthesis in FORMAT specifier.
$nexp 0304
Error : Missing left parenthesis in FORMAT specifier.
.PP
This format specification has unbalanced parentheses.
.ME
$
$ Error : 0305
$msg  0305 Missing right parenthesis or unexpected end of FORMAT specifier.
$nexp 0305
Error : Missing right parenthesis or unexpected end of FORMAT specifier.
.PP
A format specification contains unbalanced parentheses.  There are more left
parentheses than there are right parentheses.
.ME
$
$ Error : 0306
$msg  0306 Integer constant expected where "%c" is present.
$nexp 0306
Error : Integer constant expected where "%c" is present.
.PP
An incomplete edit descriptor is used in a format specification.  The exact
form must be followed when specifying 
the following edit descriptors:
.CS
  \*CE\fIw.d\*C	E\fIw.d\*CE\fIe\*C
  \*CF\fIw.d\*C
  \*CG\fIw.d	\*CG\fIw.d\*CE\fIe\*C
  \*CD\fIw.d	\*CD\fIw.d\*CE\fIe\*C
  \*CI\fIw\*C	\*CI\fIw.m\*C
  \*CB\fIw\*C	\*CB\fIw.m\*C
  \*CO\fIw\*C	\*CO\fIw.m\*C
  \*CZ\fIw\*C	\*CZ\fIw.m\*C
  \*CR\fIw\*C
  \*CL\fIw\*C
  \fIk\*CP    -\fIk\*CP   +\fIk\*CP
  \*CT\fIc\*C
  \*CTL\fIc\*C
  \*CTR\fIc\*C
  \fI-n\*CX\*C
.CE
The values \fIw, d, m, k, n,\fR and \fIc\fR must not be omitted.
.ME
$
$ Error : 0307
$msg  0307 A period is expected where "%c" is present.
$nexp 0307
Error : A period is expected where "%c" is present.
.PP
The compiler expects a period here.  These edit descriptors must adhere to the
following forms:
.CS
  Ew.d	Ew.dEe
  Fw.d
  Gw.d	Gw.dEe
  Dw.d
.CE
.ME
$
$ Error : 0308
$msg  0308 Expecting -nP, -nX, or +nP, but found "%c".
$nexp 0308
Error : Expecting -nP, -nX, or +nP, but found "%c".
.PP
The compiler found -\fIn\fR (where \fIn\fR is an integer) and expected it to be followed 
by P or X; or the compiler found +\fIn\fR and expected it to be followed by P.
.ME
$
$ Error : 0309
$msg  0309 No repeat count is allowed for the "%c" edit descriptor.
$nexp 0309
Error : No repeat count is allowed for the "%c" edit descriptor.
.PP
A nonrepeatable edit descriptor is used with a repeat count.  The
following edit descriptors must not be repeated:
.CS
      kP    scale factor
      "     literal string
      '     literal string
      BN    blanks ignored
      BZ    blanks treated as zeros
      :     terminate format control
      Tn    Positioning
      TLn
      TRn
      nX    spacing
      $     carriage control
      SP    plus signs
      S     plus signs
      SS    plus signs
.CE
.ME
$
$ Error : 0310
$msg  0310 The repeat count value must be greater than 0.
$nexp 0310
Error : The repeat count value must be greater than 0.
.PP
The repeat count is not valid for this format specification.  Format 
specifications must be in the following format:
.CS
  ([\fIformat_item_list\*C])
.CE
.PP
\fIformat_item_list\fR is a list of items of the following form:
.CS
[\fIr\*C] \fIdata_edit_desc\*C
          \fIcontrol_edit_desc\*C
          \fIchar_string_edit_desc\*C
[\fIr\*C] \fI(format_item_list)
.CE
.PP
\fIr\fR
is a nonzero, unsigned integer constant.
.ME
$
$ Error : 0311
$msg  0311 Field width must not be zero.
$nexp 0311
Error : Field width must not be zero.
.PP
The compiler has found a zero field width or exponent width on an edit
descriptor.  In the following edit descriptors, the values \fIw\fR and \fIe\fR cannot
be zero:
.CS
  Ew.d  Ew.dEe
  Fw.d
  Gw.d  Gw.dEe
  Dw.d  Dw.dEe
  Iw    Iw.m
  Aw
  Ow    Ow.m
  Zw    Zw.m
  Rw
  Lw
.CE
.ME
$
$ Error : 0312
$msg  0312 Maximum size for field width, decimal field width, exponent field width, or repetition count exceeded.
$nexp 0312
Error : Maximum size for field width, decimal field width, exponent field width, or repetition count exceeded.
.PP
For repeatable edit descriptors, a maximum field size of 16,777,215 is 
allowed for total field width and decimal digit field width.  A maximum field
size of 63 is allowed for the exponent field width.  A maximum of 
2,147,483,647 is allowed for the repetition count.
.ME
$
$ Error : 0313
$msg  0313 Missing or zero length for the H edit descriptor.
$nexp 0313
Error : Missing or zero length for the H edit descriptor.
.PP
An \*CH\fR edit descriptor is being used with an improper value for the number of
characters.  The \*CH\fR edit descriptor, used to output Hollerith strings, must
adhere to the following form:
.CS
     \fIn\*CH
.CE
.PP
\fIn\fR must be a nonzero, positive integer.
.ME
$
$ Error : 0314
$msg  0314 Unknown edit descriptor "%c" has been detected.
$nexp 0314
Error : Unknown edit descriptor "%c" has been detected.
.PP
This format specification has an unknown edit descriptor.
.ME
$
$ Error : 0315
$msg  0315 Encountered end of data before completion of last edit descriptor processing.
$nexp 0315
Error : Encountered end of data before completion of last edit descriptor processing.
.PP
An \*CH\fR edit descriptor specifies a number of characters greater than the
length of the statement.  For example, the following statement would cause
this message to be issued:
.CS
  10    FORMAT(100HABCDEFGHIJ)
.CE
.ME
$
$ Error : 0316
$msg  0316 Hollerith, octal, hexadecimal and binary constants are not allowed as I/O list items.
$nexp 0316
Error : Hollerith, octal, hexadecimal and binary constants are not allowed as I/O list items.
.PP
Constants that are of type Boolean are not allowed as input or output
list items on I/O statements.  Boolean constants are either Hollerith
constants or hexadecimal, octal, or binary constants.  Some examples
include
.CS
	4habcd
	"abcd"R
	77b
	x"a77"
.CE
.ME
$
$ Ansi : 0317
$msg  0317 The use of ".%s." as a dot operator is an extension to the Fortran standard.
$nexp 0317
Ansi : The use of ".%s." as a dot operator is an extension to the Fortran standard.
.PP
The following dot operators are extensions to the Fortran standard.
.CS
  .A.    (a synonym for .AND.)
  .N.    (a synonym for .NOT.)
  .O.    (a synonym for .OR.)
  .X.    (a synonym for .NEQV.)
  .XOR.		
.CE
.PP
The extension dot operator is not allowed if it is being used as a defined
operator.
.ME
$
$ Error : 0318
$msg  0318 The operator "%s" has not been declared as a user defined operator.
$nexp 0318
Error : The operator "%s" has not been declared as a user defined operator.
.PP
The compiler detected a dot operator that is not declared as a defined
operator and is not an intrinsic dot operator.
.ME
$
$ Error : 0319
$msg  0319 A subscript must be a scalar integer expression.
$nexp 0319
Error : A subscript must be a scalar integer expression.
.PP
The compiler detected a subscript in an array reference or in a subscript 
triplet array reference that is not a scalar integer expression.
.ME
$
$ Error : 0320
$msg  0320 A vector subscript must be a rank 1 integer expression.
$nexp 0320
Error : A vector subscript must be a rank 1 integer expression.
.PP
The compiler detected a vector subscript for an array reference that has
a rank greater than 1.
.ME
$
$ Error : 0321
$msg  0321 The second subscript must not be omitted from a subscript triplet in the last dimension of an assumed-size array.
$nexp 0321
Error : The second subscript must not be omitted from a subscript triplet in the last dimension of an assumed-size array.
.PP
The second subscript must not be omitted from a subscript triplet in the last
dimension of an assumed-size array.
.ME
$
$ Error : 0322
$msg  0322 This use of a function or derived type "%s" is not valid.
$nexp 0322
Error : This use of a function or derived type "%s" is not valid.
.PP
A parenthesized list was expected but was not found.  The object in question
is either a derived type name or a forward reference to an internal function.
.ME
$
$ Error : 0323
$msg  0323 The expressions in a substring range must be scalar integer expressions.
$nexp 0323
Error : The expressions in a substring range must be scalar integer expressions.
.PP
The compiler detected a substring range that is not a scalar integer 
expression.
.ME
$
$ Error : 0324
$msg  0324 Assignment of a rank %d expression to a rank %d variable is not allowed.
$nexp 0324
Error : Assignment of a rank %d expression to a rank %d variable is not allowed.
.PP
Unless there is an extended assignment to allow it, the ranks of both sides
of an assignment statement must agree or the right side must be a rank
zero expression.
.ME
$
$ Internal : 0325
$msg  0325 The routine get_dummy_arg_type is called with a dummy argument that is not a data object.
$nexp 0325
Internal : The routine get_dummy_arg_type is called with a dummy argument that is not a data object.
.PP
The routine get_dummy_arg_type is called with an argument that is not valid.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0326
$msg  0326 The left hand side of this assignment statement is constant or protected.
$nexp 0326
Error : The left hand side of this assignment statement is constant or protected.
.PP
The left side of an assignment statement is either a named constant, a
a use-associated variable that is protected, or a subobject that is constant
or protected.
.ME
$
$ Ansi : 0327
$msg  0327 The actual argument to IACHAR and ICHAR must have length equal to one character.
$nexp 0327
Ansi : The actual argument to IACHAR and ICHAR must have length equal to one character.
.PP
The actual argument to \*CIACHAR\fR and \*CICHAR\fR must have length = 1.
.ME
$
$ Error : 0328
$msg  0328 Statement label %s is not a FORMAT statement label.
$nexp 0328
Error : Statement label %s is not a FORMAT statement label.
.PP
A statement label that is not defined on a \*CFORMAT\fR statement is being 
referenced in a context where a \*CFORMAT\fR statement label is required.
.ME
$
$ Error : 0329
$msg  0329 Intrinsic function "%s" is not allowed in an initialization expression. 
$nexp 0329
Error : Intrinsic function "%s" is not allowed in an initialization expression. 
.PP
This intrinsic function is not allowed in an initialization expression.
It must be an elemental intrinsic function  or one of the following transformational
intrinsic functions:
.CS
   REPEAT
   RESHAPE
   SELECTED_INT_KIND
   SELECTED_REAL_KIND
   TRANSFER
   TRIM
.CE
.ME
$
$ Error : 0330
$msg  0330 More than one actual argument has been specified for a dummy argument.
$nexp 0330
Error : More than one actual argument has been specified for a dummy argument.
.PP
The compiler recognized that more than one actual argument was
specified for a particular dummy argument.  This can result from two
identical argument keywords or an argument keyword and a
positional argument for the same dummy argument.
.ME
$
$ Error : 0331
$msg  0331 There is no corresponding dummy argument for actual argument number %d.
$nexp 0331
Error : There is no corresponding dummy argument for actual argument number %d.
.PP
The actual argument does not have a corresponding dummy argument.  This 
is caused by specifying more actual arguments than the number of 
dummy arguments.
.ME
$
$ Error : 0332
$msg  0332 There is no actual argument to correspond to dummy argument "%s".
$nexp 0332
Error : There is no actual argument to correspond to dummy argument "%s".
.PP
An explicit interface for the called routine was declared.  The compiler 
found that a nonoptional dummy argument (does not have the \*COPTIONAL\fR attribute) 
does not have a corresponding actual argument.
.ME
$
$ Error : 0333
$msg  0333 An actual argument keyword is being used when an explicit interface is not known.
$nexp 0333
Error : An actual argument keyword is being used when an explicit interface is not known.
.PP
An argument keyword can only be used if the interface to the called routine
is known at compile time.  This information can be supplied for external
subprograms by an interface block.  Internal and module subprograms always
have keyword information specified by definition.
.ME
$
$ Error : 0334
$msg  0334 The type of this actual argument does not match that of the dummy argument.
$nexp 0334
Error : The type of this actual argument does not match that of the dummy argument.
.PP
A difference was detected between the type of the actual argument and the
type of the dummy argument supplied in an explicit interface for the called
routine.
.ME
$
$ Error : 0335
$msg  0335 Function "%s" is an illegal reference in a CALL statement.
$nexp 0335
Error : Function "%s" is an illegal reference in a CALL statement.
.PP
This \*CCALL\fR statement is attempting to call a function.  Only subroutines can
be specified on \*CCALL\fR statements.
.ME
$
$ Error : 0336
$msg  0336 The kind of this actual argument does not match that of its associated dummy argument.
$nexp 0336
Error : The kind of this actual argument does not match that of its associated dummy argument.
.PP
A difference was detected between the kind type parameter of the actual argument and the
kind type parameter of the dummy argument supplied in an explicit interface for the called
routine.
.ME
$
$ Error : 0337
$msg  0337 The rank of this actual argument does not match that of its corresponding dummy argument.
$nexp 0337
Error : The rank of this actual argument does not match that of its corresponding dummy argument.
.PP
A difference was detected between the rank of the actual argument and the
rank of the dummy argument supplied in an explicit interface for the called
routine.
.ME
$
$ Error : 0338
$msg  0338 An alternate return dummy argument (*) requires a user label as its actual argument.
$nexp 0338
Error : An alternate return dummy argument (*) requires a user label as its actual argument.
.PP
An explicit interface defines this dummy argument as an alternate return
argument (*), but the call site does not supply a user label
as the corresponding actual argument. 
.ME
$
$ Error : 0339
$msg  0339 Unexpected syntax:  A label, a left parenthesis, or a variable name is expected but found "%s".
$nexp 0339
Error : Unexpected syntax:  A label, a left parenthesis, or a variable name is expected but found "%s".
.PP
There are three forms of the \*CGO TO\fR statement:
.BL
Unconditional:  \*CGO TO\fR label
.BL
Computed:  \*CGO TO (\fIlabel_list\*C) [,] \fIscalar_int_expr\fR
.BL
Assigned: \*CGO TO \fIscalar_int_variable\*C [ [,] (\fIlabel_list\*C) ]
.PP
The token following the keyword \*CTO\fR is expected to be a statement label, a left
parenthesis, or a variable name.
.ME
$
$ Error : 0340
$msg  0340 Variable "%s" does not appear in an ASSIGN statement in this scoping unit.
$nexp 0340
Error : Variable "%s" does not appear in an ASSIGN statement in this scoping unit.
.PP
The diagnosed variable was not assigned a statement label value by an
\*CASSIGN\fR statement in the current scoping unit.
When executing an assigned \*CGO TO\fR statement, the integer variable
must be defined with the value of a statement label of a branch target 
statement that appears in the same scoping unit.  The variable can be defined
with a statement label value only by an \*CASSIGN\fR statement in the same scoping
unit as the assigned \*CGO TO\fR statement.
.ME
$
$ Ansi : 0341
$msg  0341 The ASSIGN statement is an obsolescent/deleted feature.
$nexp 0341
Ansi : The ASSIGN statement is an obsolescent/deleted feature.
.PP
This feature was deleted in the Fortran 95 standard. The compiler supports
it as an extension.
The \*CASSIGN\fR statement allows 
a label to be dynamically assigned to an integer variable, and the assigned \*CGO
TO\fR statement allows "indirect branching" through this variable.  This hinders
the readability of the program flow, especially if the integer variable also is
used in arithmetic operations.  The two totally different usages of the integer
variable can be an obscure source of error.
.PP
These statements have commonly been used to simulate internal procedures 
that can now be coded directly.
.ME
$
$ Ansi : 0342
$msg  0342 The assigned GO TO statement is an obsolescent/deleted feature.
$nexp 0342
Ansi : The assigned GO TO statement is an obsolescent/deleted feature.
.PP
This feature was deleted in the Fortran 95 standard. The compiler supports
it as an extension.
The \*CASSIGN\fR statement allows
a label to be dynamically assigned to an integer variable, and the assigned \*CGO
TO\fR statement allows "indirect branching" through this variable.  This hinders
the readability of the program flow, especially if the integer variable also is
used in arithmetic operations.  The two totally different usages of the integer
variable can be an obscure source of error.
.PP
These statements have commonly been used to simulate internal procedures
that can now be coded directly.
.ME
$
$ Error : 0343
$msg  0343 A RECURSIVE keyword must be declared for a subprogram so that the subprogram can be called recursively.
$nexp 0343
Error : A RECURSIVE keyword must be declared for a subprogram so that the subprogram can be called recursively.
.PP
A function or subroutine is being called recursively, but the program unit
does not have the \*CRECURSIVE\fR keyword on its \*CFUNCTION\fR or
\*CSUBROUTINE\fR statement.
.ME
$
$ Ansi : 0344
$msg  0344 This subprogram has no result name, but is being called recursively.  This is an extension to the Fortran standard.
$nexp 0344
Ansi : This subprogram has no result name, but is being called recursively.  This is an extension to the Fortran standard.
.PP
If the function declaration does not contain a \*CRESULT\fR clause, the Fortran
standard states that any reference to the function name is a reference to the
result variable of the function, not a recursive call.  An extension has been
made to allow a reference to the function name to be a recursive reference,
provided the function result is not array-valued or a derived type.  It is
more explicit and safer to use a \*CRESULT\fR clause when a function is to be
called recursively.
.ME
$
$ Error : 0345
$msg  0345 Label %s is not defined on either an executable statement or a FORMAT statement.
$nexp 0345
Error : Label %s is not defined on either an executable statement or a FORMAT statement.
.PP
In an \*CASSIGN\fR statement, \fIlabel\fR must be the statement label of an executable
statement (and it must be a valid branch target statement) or it must be the
statement label of a \*CFORMAT\fR statement.  The executable or format statement must
also be defined in the same scoping unit as the \*CASSIGN\fR statement.
.ME
$
$ Error : 0346
$msg  0346 The %s statement at line %d is not a valid branch target statement.
$nexp 0346
Error : The %s statement at line %d is not a valid branch target statement.
.PP
In an \*CASSIGN\fR statement, if \fIlabel\fR is the statement label of an executable 
statement, the executable statement must be a valid branch target 
statement.  Examples of executable statements that are not valid branch target
statements are:  \*CELSE IF\fR, \*CELSE\fR, \*CCASE\fR, \*CELSEWHERE\fR, and \*CEND WHERE\fR. 
.ME
$
$ Warning : 0347
$msg  0347 Label %s is defined in the WHERE construct starting at line %d.
$nexp 0347
Warning : Label %s is defined in the WHERE construct starting at line %d.
.PP
The label in the \*CASSIGN\fR statement is defined on a statement contained in a
\*CWHERE\fR construct.  Transfer of control to the interior of a \*CWHERE\fR construct is
prohibited.
.ME
$
$ Warning : 0348
$msg  0348 Label %s is defined in the CASE block starting at line %d.
$nexp 0348
Warning : Label %s is defined in the CASE block starting at line %d.
.PP
The label in the \*CASSIGN\fR statement is defined on a statement contained in a \*CCASE\fR
block.  Transfer of control into a \*CCASE\fR block from outside of the block (even
from another \*CCASE\fR block of the same \*CCASE\fR construct) is prohibited.
.ME
$
$ Warning : 0349
$msg  0349 Label "%s" does not appear in an ASSIGN statement in this scoping unit.
$nexp 0349
Warning : Label "%s" does not appear in an ASSIGN statement in this scoping unit.
.PP
The label cited in the message is used in the
assigned \*CGO TO\fR statement being diagnosed but the label did not appear in any
\*CASSIGN\fR statement in the current scoping unit.
When executing an assigned \*CGO TO\fR statement, the integer variable
must be defined with the value of a statement label of a branch target statement
that appears in the same scoping unit.  The variable can be defined with a 
statement label value only by an \*CASSIGN\fR statement in the same scoping unit as 
the assigned \*CGO TO\fR statement.
.ME
$
$ Error : 0350
$msg  0350 "%s" is typed CHARACTER*(*), therefore it must be a dummy argument, a constant or a Cray pointee.
$nexp 0350
Error : "%s" is typed CHARACTER*(*), therefore it must be a dummy argument, a constant or a Cray pointee.
.PP
A data object that is declared to be assumed-length character
(\*CCHARACTER*(*)\fR), must be a constant,
dummy argument, or a Cray pointee.  A Cray pointee is nonstandard.
.ME
$
$ Error : 0351
$msg  0351 "%s" is an assumed-shape array, therefore it must be a nonpointer dummy argument.
$nexp 0351
Error : "%s" is an assumed-shape array, therefore it must be a nonpointer dummy argument.
.PP
By definition an assumed-shape array must be a nonpointer dummy argument.   
An assumed-shape array is declared by specifying 
.CS
   DIMENSION NEW_ARRAY(10:)
.CE
This declares a rank one array called \*CNEW_ARRAY\fR with a lower bound of 10.
\*CNEW_ARRAY\fR must not be declared with the \*CPOINTER\fR attribute.
.ME
$
$ Error : 0352
$msg  0352 "%s" has the %s attribute, therefore it must be a dummy argument.
$nexp 0352
Error : "%s" has the %s attribute, therefore it must be a dummy argument.
.PP
If an object is given the \*COPTIONAL\fR and/or \*CINTENT\fR attributes it must be 
declared as a dummy argument.
.ME
$
$ Error : 0353
$msg  0353 "%s" must have the POINTER or ALLOCATABLE attributes or be a dummy argument, because it is a deferred-shape array.
$nexp 0353
Error : "%s" must have the POINTER or ALLOCATABLE attributes or be a dummy argument, because it is a deferred-shape array.
.PP
A deferred-shape array must be a dummy argument, a pointer, or have the
\*CALLOCATABLE\fR attribute.  This item has none of these characteristics.
.ME
$
$ Error : 0354
$msg  0354 Equivalence-object "%s" is of a derived type that has an ultimate component that has the POINTER or ALLOCATABLE attribute.
$nexp 0354
Error : Equivalence-object "%s" is of a derived type that has an ultimate component that has the POINTER or ALLOCATABLE attribute.
.PP
An equivalence-object of a derived type has a 
component that has the pointer or allocatable attribute.  Derived types
with pointer or allocatable components cannot be equivalenced.
.ME
$
$ Error : 0355
$msg  0355 "%s" is used in an expression or specified in a namelist group, therefore the type is assumed to be %s.
$nexp 0355
Error : "%s" is used in an expression or specified in a namelist group, therefore the type is assumed to be %s.
.PP
When an object is used in an expression or specified in a namelist group, it is
implicitly typed if it is the first reference to this object.  The object
can subsequently be typed in a type declaration statement only if it
confirms the type.
.PP
Example:
.CS
     DIMENSION ARRAY(K)
     REAL K          \fR! Illegal 
.CE
.PP
\*CK\fR can only be typed integer, because that is what it is implicitly typed as in 
the \*CDIMENSION\fR 
statement.
.CS
     IMPLICIT INTEGER(A-Z)
     NAMELIST /GROUP/ R 
     REAL R           \fR! Illegal
.CE
.PP
\*CR\fR can only be typed integer, because that is what it is
implicitly typed as in the \*CNAMELIST\fR statement
.ME
$
$ Error : 0356
$msg  0356 Assignment of a %s expression to a %s variable is not allowed.
$nexp 0356
Error : Assignment of a %s expression to a %s variable is not allowed.
.PP
The combination of types in this assignment statement is not valid.  The
assignment of derived types is only allowed when the types are defined by
the same declaration or their declarations both contain \*CSEQUENCE\fR statements 
and are identical
in every respect.  "Identical" means that the type name, number of components,
component order, component names, and component type and attributes agree.
.ME
$
$ Error : 0357
$msg  0357 The number of components in this derived type constructor does not match the declared number.
$nexp 0357
Error : The number of components in this derived type constructor does not match the declared number.
.PP
This derived type constructor has an incorrect number of components.
.ME
$
$ Error : 0358
$msg  0358 This derived type constructor has a type mismatch error in component number %d.
$nexp 0358
Error : This derived type constructor has a type mismatch error in component number %d.
.PP
Each component of a derived type constructor must be the same type as the
corresponding component of the derived type definition.   The types of this constructor component and
the corresponding component of the derived type do not match.
.ME
$
$ Error : 0359
$msg  0359 This structure constructor item which corresponds to a pointer component is not an allowable target.
$nexp 0359
Error : This structure constructor item which corresponds to a pointer component is not an allowable target.
.PP
When a component in a derived type is a pointer, the corresponding structure
constructor expression must evaluate to an object that would be an
allowable target for such a pointer in a pointer assignment statement.
In the following example, both of the structure constructors are allowed.
.CS
   TYPE X
      INTEGER, POINTER :: IPTR
   END TYPE

   TYPE(X)          :: LEFT
   INTEGER, POINTER :: INT_PTR
   INTEGER, TARGET  :: INT_TARGET

   LEFT = X(INT_PTR)

   LEFT = X(INT_TARGET)
.CE
.ME
$
$ Error : 0360
$msg  0360 The rank of derived type constructor component number %d does not match the declared rank.
$nexp 0360
Error : The rank of derived type constructor component number %d does not match the declared rank.
.PP
All components of a derived type constructor must match the corresponding
declared component in type and shape.
.ME
$
$ Error : 0361
$msg  0361 Both actual arguments must be of type default real.
$nexp 0361
Error : Both actual arguments must be of type default real.
.PP
Both actual arguments to this intrinsic must be of type default real.
.ME
$
$ Warning : 0362
$msg  0362 This statement can not be reached.
$nexp 0362
Warning : This statement can not be reached.
.PP
The statement preceding the diagnosed statement is a \*CGO TO\fR statement.  The current statement has no 
label; therefore, control cannot reach the current statement.  For example:
.CS
   GO TO 20
   I = J \fR! There is no way to get to this statement.
.CE
.ME
$
$ Error : 0363
$msg  0363 All of the actual arguments to this intrinsic call are not conformable to each other.
$nexp 0363
Error : All of the actual arguments to this intrinsic call are not conformable to each other.
.PP
All of the actual arguments to an elemental intrinsic must be conformable.
.ME
$
$ Limit : 0364
$msg  0364 The number of compiler generated labels exceeds the compiler limit of %d.
$nexp 0364
Limit : The number of compiler generated labels exceeds the compiler limit of %d.
.PP
During the compilation process, the compiler must generate internal
labels.  The number of labels used by the compiler exceeds the indicated
limit.  The source file must be divided into smaller, separate files.
.ME
$
$ Error : 0365
$msg  0365 This statement must not be the action-stmt of a logical IF statement.
$nexp 0365
Error : This statement must not be the action-stmt of a logical IF statement.
.PP
The logical \*CIF\fR statement contains a statement that is not permitted as the 
\fIaction_stmt\fR portion of the logical \*CIF\fR statement.
.PP
The syntax of a logical \*CIF\fR statement is:
.CS
   IF (\fIscalar_logical_expr\*C) \fIaction_stmt
.CE
.PP
\fRThe \fIaction_stmt\fR must be an executable statement that is not:
.BL
Another logical \*CIF\fR statement
.BL
Any form of an \*CEND\fR statement
.BL
Any statement that is part of a construct (such as the \*CIF\fR, \*CELSE IF\fR, or 
\*CELSE\fR statement of an \*CIF\fR construct)
.ME
$
$ Internal : 0366
$msg  0366 Unexpected statement type when parsing the target statement of a logical IF.
$nexp 0366
Internal : Unexpected statement type when parsing the target statement of a logical IF.
.PP
The logical \*CIF\fR statement handler encountered a \fIstmt_type\fR value that it did
not expect.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0367
$msg  0367 Object "%s" is a module procedure or an internal function so it must not be typed as an assumed-length character.
$nexp 0367
Error : Object "%s" is a module procedure or an internal function so it must not be typed as an assumed-length character.
.PP
Internal and module procedures must not be typed as assumed-length character.
.ME
$
$ Error : 0368
$msg  0368 Module procedure "%s" must be defined in this scoping unit or associated from another scoping unit.
$nexp 0368
Error : Module procedure "%s" must be defined in this scoping unit or associated from another scoping unit.
.PP
All names listed on a \*CMODULE PROCEDURE\fR statement must be defined in that
scoping unit, or be accessible from another scoping unit.  The following
example shows a module procedure that has not been defined.
.CS
     MODULE Error

       INTERFACE Undefined
         MODULE PROCEDURE Not_Here
       END INTERFACE

     END MODULE Error
.CE
.PP
\*CNot_Here\fR is in error.  It does not exist in module \*CERROR\fR
and has not been made available by use association.
.ME
$
$ Error : 0369
$msg  0369 This expression must be an integer scalar expression.
$nexp 0369
Error : This expression must be an integer scalar expression.
.PP
The expression encountered in this context must be an integer scalar 
expression (for example, the expression which follows a \*CRETURN\fR statement
must be an integer scalar expression).
.ME
$
$ Error : 0370
$msg  0370 Alternate return specifiers are not allowed in function subprograms.
$nexp 0370
Error : Alternate return specifiers are not allowed in function subprograms.
.PP
If the user codes a \*CRETURN\fR statement in a function subprogram, the keyword
\*CRETURN\fR must stand alone.  Alternate return specifiers are not allowed in
function subprograms.
.ME
$
$ Ansi : 0371
$msg  0371 Alternate return specifiers are obsolescent.
$nexp 0371
Ansi : Alternate return specifiers are obsolescent.
.PP
This feature was declared obsolescent in Fortran 95.
.PP
An alternate return allows a called procedure to direct the execution of
the calling procedure upon return.  The same effect can be achieved by
returning an integer value where this integer value is used to control
a \*CCASE\fR construct upon return
to the calling procedure.
.ME
$
$ Error : 0372
$msg  0372 All dimension specifiers on a COMMON statement must be declared with constant bounds.
$nexp 0372
Error : All dimension specifiers on a COMMON statement must be declared with constant bounds.
.PP
The syntax for an object in a \fIcommon_block_object_list\fR is
.CS
   \fIvariable_name\*C [(\fIexplicit_shape_spec_list\*C)]
.CE
.PP
Each bound in an \fIexplicit_shape_spec\fR must be a constant specification 
expression.  To declare a pointer in a \fIcommon_block_object_list\fR, use
the \*CDIMENSION\fR statement to declare the array as a deferred-shape array; then
specify it in a \*CCOMMON\fR statement.
.ME
$
$ Error : 0373
$msg  0373 Object "%s" is in a common block and is derived-type "%s".  This derived-type must be a sequence type.
$nexp 0373
Error : Object "%s" is in a common block and is derived-type "%s".  This derived-type must be a sequence type.
.PP
If a \fIcommon_block_object\fR is of a derived type,
it must be a sequence type.
.ME
$
$ Error : 0374
$msg  0374 This numeric constant is out of range.
$nexp 0374
Error : This numeric constant is out of range.
.PP
A numeric constant was found to be out of range.  Either an
integer constant is too large or a real constant has an exponent which is too large.
.ME
$
$ Warning : 0375
$msg  0375 The number of subscripts is smaller than the number of declared dimensions.
$nexp 0375
Warning : The number of subscripts is smaller than the number of declared dimensions.
.PP
An array reference of the form \fIa\fR(\fIs\*C[,\fIs\*C]...)\fR is used.  The number of
subscripts in the reference should equal the number of dimensions
declared for the array.
An extension to the Fortran standard allows fewer subscripts than 
the declared number of dimensions.  The subscripts specified in the array
reference are used for the leftmost dimensions, and the lower bounds are used
for the rightmost subscripts that were omitted.
.ME
$
$ Ansi : 0376
$msg  0376 An array reference with fewer than the declared number of dimensions is an extension to the Fortran standard.
$nexp 0376
Ansi : An array reference with fewer than the declared number of dimensions is an extension to the Fortran standard.
.PP
The compiler allows arrays to be referenced with fewer than the declared
number of dimensions.  The unspecified dimensions are implied to be the lower
bound of that dimension.  This is an extension to the Fortran standard.
.ME
$
$ Error : 0377
$msg  0377 Unexpected syntax:  expected the keyword THEN, the beginning of an action-stmt, or a label. 
$nexp 0377
Error : Unexpected syntax:  expected the keyword THEN, the beginning of an action-stmt, or a label. 
.PP
If the statement is intended to be the \*CIF-THEN\fR statement of an \*CIF\fR construct, the
keyword \*CTHEN\fR must follow the closing parenthesis of the \*CIF\fR condition.  If the
statement is intended to be an \*CIF\fR statement, the beginning of an
\fIaction_stmt\fR must follow the closing parenthesis of the \*CIF\fR condition.  If the
statement is intended to be an arithmetic \*CIF\fR, an indirect logical \*CIF\fR, or a
two-branch arithmetic \*CIF\fR, a label must follow the closing parenthesis of
the \*CIF\fR condition.  
.PP
The arithmetic \*CIF\fR is an obsolescent feature and the indirect logical \*CIF\fR and two-branch 
arithmetic \*CIF\fR are outmoded extensions carried forward from FORTRAN 77.
.ME
$
$ Error : 0378
$msg  0378 This subprogram reference is illegal.
$nexp 0378
Error : This subprogram reference is illegal.
.PP
The compiler detected a subprogram reference where a data object or
function call was expected.  This may be the result of a function name 
without an actual argument list or a subroutine name not in a \*CCALL\fR statement.
.ME
$
$ Error : 0379
$msg  0379 Procedure "%s" must be EXTERNAL, a module procedure or declared in an interface block to be an actual argument.
$nexp 0379
Error : Procedure "%s" must be EXTERNAL, a module procedure or declared in an interface block to be an actual argument.
.PP
A procedure name is used as an actual argument to a function or
subroutine call, but the procedure name has not been given the \*CEXTERNAL\fR
attribute, is not a module procedure, or is not specified in an interface 
block.  NOTE:  Giving the \*CEXTERNAL\fR attribute to the name of the
\*CSUBROUTINE\fR being compiled is an extension to the standard.
.ME
$
$ Error : 0380
$msg  0380 No specific match to the defined generic operation "%s" can be found.
$nexp 0380
Error : No specific match to the defined generic operation "%s" can be found.
.PP
The type(s) of operand(s) to a defined operator or generic call cannot
be matched with any of the specific subprogram interfaces contained in the
interface block.  All actual arguments must match exactly by type, kind type,
and rank with the corresponding dummy argument in order for a match to occur.
Any dummy arguments that have no corresponding actual arguments must be
declared \*COPTIONAL\fR.
.ME
$
$ Ansi : 0381
$msg  0381 The PAUSE statement is obsolescent/deleted.
$nexp 0381
Ansi : The PAUSE statement is obsolescent/deleted.
.PP
This feature was deleted in the Fortran 95 standard. The compiler supports
it as an extension.
In most
cases, the functionality of a \*CPAUSE\fR statement can be achieved
in a portable manner with the use of a \*CREAD\fR statement that
awaits some input data.
.ME
$
$ Log_Error : 0382
$msg  0382 Cannot open Compiler Information File "%s".
$nexp 0382
Log_Error : Cannot open Compiler Information File "%s".
.PP
The compiler cannot open the Compiler Information File (CIF) named \fIinput_name.\*CT\fR
or a temporary CIF for writing.  Check the file permissions for the working
directory.
.ME
$
$ Error : 0383
$msg  0383 Cannot write to the Compiler Information File.
$nexp 0383
Error : Cannot write to the Compiler Information File.
.PP
The compiler cannot write a record to the Compiler Information File (CIF).
Compilation will continue but CIF processing is turned off.  No object file
will be created.
.ME
$
$ Internal : 0384
$msg  0384 The length of the keyword at index %d in a keyword table is %d, which is greater than the maximum of 31.
$nexp 0384
Internal : The length of the keyword at index %d in a keyword table is %d, which is greater than the maximum of 31.
.PP
All the items in the keyword table must be less than 31 characters, because of
token size limits.   Check the table in use at the time the message was
issued.
.PP
This message should never be generated and signifies a bad compiler or a bad
installation.  Please notify your product support organization with this
error message number and any supporting information.  This message does not
indicate a problem with your code.
.ME
$
$ Ansi : 0385
$msg  0385 The character variable/expression or the integer constant following the STOP/PAUSE statement is nonstandard.
$nexp 0385
Ansi : The character variable/expression or the integer constant following the STOP/PAUSE statement is nonstandard.
.PP
The Fortran standard allows for a scalar character literal constant or a 5 digit
integer literal constant (leading zeros do not count) following a \*CSTOP\fR or \*CPAUSE\fR.
Using a character variable, a character expression, or an integer constant longer than
5 digits is an extension to the Fortran standard.
.ME
$
$ Error : 0386
$msg  0386 The expression following a STOP/PAUSE must be a scalar character expression or an unsigned integer constant.
$nexp 0386
Error : The expression following a STOP/PAUSE must be a scalar character expression or an unsigned integer constant.
.PP
The Fortran standard allows for a 5-digit unsigned scalar integer constant
(leading zeros do not count) or a scalar character constant following a 
\*CSTOP\fR or \*CPAUSE\fR keyword.  The compiler allows an arbitrary length unsigned scalar
integer constant or a scalar character expression following the \*CSTOP\fR or \*CPAUSE\fR keyword.
.ME
$
$ Error : 0387
$msg  0387 The CONTAINS statement must be followed by a FUNCTION or SUBROUTINE statement.
$nexp 0387
Error : The CONTAINS statement must be followed by a FUNCTION or SUBROUTINE statement.
.PP
The compiler detected a \*CCONTAINS\fR statement that is not followed by a
\*CSUBROUTINE\fR or \*CFUNCTION\fR statement.  The syntax for the \*CCONTAINS\fR statement is as follows:
.PP
In a module:
.CS
  contains_stmt
         module_subprogram
        [module_subprogram]...
.CE
.PP
In an external procdure
.CS
  contains_stmt
        internal_subprogram
       [internal_subprogram]...
.CE
.ME
$
$ Log_Warning : 0388
$msg  0388 Assembly language listing (-rg) disables assembly language output (-eS or -S filename).  The listing is selected.
$nexp 0388
Log_Warning : Assembly language listing (-rg) disables assembly language output (-eS or -S filename).  The listing is selected.
.PP
The compiler cannot have an assembly language listing and an assembly
language output file at the same time.  The assembly language output file is
disabled.
.PP
Example:
.CS
-eS -rg file.f \fR(Warning message will be issued)
.CE
.ME
$
$ Error : 0389
$msg  0389 No specific match can be found for the generic subprogram call "%s".
$nexp 0389
Error : No specific match can be found for the generic subprogram call "%s".
.PP
A function or subroutine call which invokes the name of a generic interface
does not match any specific subprogram interfaces in the generic interface
block.  All dummy arguments that do not have the \*COPTIONAL\fR attribute
must match exactly all corresponding actual arguments in type, kind type, and rank.
.ME
$
$ Error : 0390
$msg  0390 Derived type "%s" is defined in the host scope and used in the local scope, therefore it must not be redefined.
$nexp 0390
Error : Derived type "%s" is defined in the host scope and used in the local scope, therefore it must not be redefined.
.PP
The compiler detected the following:
.CS
  TYPE :: NEW_TYPE
    INTEGER :: A
  END TYPE NEW_TYPE
  ...

  CONTAINS
    SUBROUTINE EXAMPLE
    TYPE(NEW_TYPE) :: VAR
       
    TYPE :: NEW_TYPE  \fR! This redefinition is illegal.\*C
      INTEGER :: B
    END TYPE NEW_TYPE
    ...
    END SUBROUTINE
  END
.CE
\fR
.ME
$
$ Warning : 0391
$msg  0391 Type %s*%d will be mapped to %s*%d.
$nexp 0391
Warning : Type %s*%d will be mapped to %s*%d.
.PP
The specified data type has been mapped to the new data type, because the
compiler does not currently support the specified data type.
.ME
$
$ Error : 0392
$msg  0392 Data type %s is not allowed for operator "%s".
$nexp 0392
Error : Data type %s is not allowed for operator "%s".
.PP
The data type of an operand of a unary operator is not valid.
.ME
$
$ Error : 0393
$msg  0393 An array reference with parentheses must have at least one subscript.
$nexp 0393
Error : An array reference with parentheses must have at least one subscript.
.PP
The compiler found an array reference with no subscripts,  but it is not
a whole array reference.  The following example demonstrates the problem:
.CS
   DIMENSION I(10)
   J = I()
.CE
.PP
If \*CJ\fR is a scalar reference, then to be correct a subscript must be specified in the
reference to \*CI\fR, such as \*CI(3)\fR.
.ME
$
$ Error : 0394
$msg  0394 This Hollerith constant is longer than one word.
$nexp 0394
Error : This Hollerith constant is longer than one word.
.PP
A Hollerith constant used as a numeric constant cannot be longer than one
word.
.ME
$
$ Ansi : 0395
$msg  0395 Masking expressions are an extension to the Fortran standard.
$nexp 0395
Ansi : Masking expressions are an extension to the Fortran standard.
.PP
A logical operator is used with operands that are of types integer,
real, Boolean and/or Cray pointer.  This is called a masking expression and is an
extension to the Fortran standard.
.ME
$
$ Error : 0396
$msg  0396 This generic interface has both subroutine and function specific interfaces.
$nexp 0396
Error : This generic interface has both subroutine and function specific interfaces.
.PP
A generic interface must have only all function specific interfaces or all
subroutine specific interfaces.  This generic interface has both subroutine
and function specific interfaces.
.ME
$
$ Error : 0397
$msg  0397 The generic interface "%s" cannot be called as a subroutine.
$nexp 0397
Error : The generic interface "%s" cannot be called as a subroutine.
.PP
A generic interface name is used in a \*CCALL\fR statement but the interface
contains only function specific interfaces.
.ME
$
$ Error : 0398
$msg  0398 The generic interface "%s" cannot be used as a function.
$nexp 0398
Error : The generic interface "%s" cannot be used as a function.
.PP
A generic interface name is used as a function name but the 
interface contains only subroutine specific interfaces.
.ME
$
$ Comment : 0399
$msg  0399 Generic interface call "%s" resolved to "%s".
$nexp 0399
Comment : Generic interface call "%s" resolved to "%s".
.PP
This comment tells what resolution occurred for a generic interface reference or overloaded operator.
.ME
$
$ Error : 0400
$msg  0400 The characters found in the label field are not valid.
$nexp 0400
Error : The characters found in the label field are not valid.
.PP
In fixed source form, the label field of a line (columns 1 to 5) must only
have spaces or digits.  An illegal character has been found in the label field on this line.
.ME
$
$ Error : 0401
$msg  0401 A stride specification in the array shape specification on the ALLOCATE statement is illegal.
$nexp 0401
Error : A stride specification in the array shape specification on the ALLOCATE statement is illegal.
.PP
An array shape specification has a stride specified.  Only the lower bound 
(which is optional) and upper bound can be specified.  The syntax 
for a \fIallocate_shape_spec\fR is   \*C[\fIlower_bound\*C:] \fIupper_bound\fR.
.ME
$
$ Error : 0402
$msg  0402 The number of extents specified for this allocate object does not match the declared rank.
$nexp 0402
Error : The number of extents specified for this allocate object does not match the declared rank.
.PP
When an \fIallocate_object\fR is an allocatable array or pointer array, the shape
specified in an \*CALLOCATE\fR statement must have the extent of every dimension
specified.
.ME
$
$ Error : 0403
$msg  0403 The upper or lower bound of a dimension in an allocate object must be a scalar integer expression.
$nexp 0403
Error : The upper or lower bound of a dimension in an allocate object must be a scalar integer expression.
.PP
In an \*CALLOCATE\fR statement, an \fIallocate_object\fR has its shape specified with
bounds that are not scalar integer expressions.
.ME
$
$ Error : 0404
$msg  0404 Only scalar objects can be allocated in an ALLOCATE statement.
$nexp 0404
Error : Only scalar objects can be allocated in an ALLOCATE statement.
.PP
A nonscalar object was encountered in an \fIallocation_list\fR of an \*CALLOCATE\fR
statement.  This is because a \fIpart_ref\fR in a derived type reference is a
whole array reference or an array section.
.ME
$
$ Error : 0405
$msg  0405 An allocate/deallocate object cannot be a substring reference.
$nexp 0405
Error : An allocate/deallocate object cannot be a substring reference.
.PP
An \fIallocate_object\fR in an \*CALLOCATE\fR or \*CDEALLOCATE\fR statement was referenced with a
substring qualifier.
.ME
$
$ Ansi : 0406
$msg  0406 The indirect logical IF and the two-branch arithmetic IF statements are both nonstandard and outmoded.
$nexp 0406
Ansi : The indirect logical IF and the two-branch arithmetic IF statements are both nonstandard and outmoded.
.PP
The indirect logical \*CIF\fR statement and the two-branch arithmetic \*CIF\fR statement 
are obsolete features that have been carried forward from CF77.  These 
outmoded features have been replaced by alternatives that enhance the 
portability of Fortran programs.  The \*CIF\fR construct or logical IF should be used
in place of both of these outmoded forms.  Do not
use these outmoded forms, especially in new code.
.ME
$
$ Error : 0407
$msg  0407 Labels must be in columns 1 through 5 in fixed source form.
$nexp 0407
Error : Labels must be in columns 1 through 5 in fixed source form.
.PP
This is fixed source form, so the label must be in columns 1-5.  An example
of this error follows:
.CS
      i = 1; 100 read *,i
.CE
.PP
\*C100\fR is in error.  It should be specified as follows:
.CS
      i=1
100   read *, i
.CE
.ME
$
$ Error : 0408
$msg  0408 This pointer is to the right of a part-ref with nonzero rank.
$nexp 0408
Error : This pointer is to the right of a part-ref with nonzero rank.
.PP
A \fIpart_ref\fR with a nonzero rank cannot have another \fIpart_ref\fR to the right
with the \*CPOINTER\fR attribute.
.ME
$
$ Error : 0409
$msg  0409 The conditional expression must be type integer, real, or double precision.
$nexp 0409
Error : The conditional expression must be type integer, real, or double precision.
.PP
The conditional expression of an arithmetic \*CIF\fR must be type integer,
real, or double precision.  
.ME
$
$ Error : 0410
$msg  0410 The conditional expression must be scalar.
$nexp 0410
Error : The conditional expression must be scalar.
.PP
The conditional expression of an arithmetic \*CIF\fR must have a scalar result and
must be type integer, real, or double precision.
.ME
$
$ Error : 0411
$msg  0411 A variable in an assignment statement must not be an assumed-size array.
$nexp 0411
Error : A variable in an assignment statement must not be an assumed-size array.
.PP
The left side of an assignment statement cannot be a whole array reference
of an assumed-size array.
.ME
$
$ Error : 0412
$msg  0412 This whole array reference of an assumed-size array is not allowed.
$nexp 0412
Error : This whole array reference of an assumed-size array is not allowed.
.PP
An assumed-size array cannot appear as a whole array reference except
when it is an actual argument.
.ME
$
$ Error : 0413
$msg  0413 The STAT variable must not be allocated within the ALLOCATE statement in which it appears.
$nexp 0413
Error : The STAT variable must not be allocated within the ALLOCATE statement in which it appears.
.PP
The \*CSTAT=\fR variable for this \*CALLOCATE\fR statement is also an \fIallocate_object\fR
in the same \*CALLOCATE\fR statement.
.ME
$
$ Error : 0414
$msg  0414 The conditional expression must be type logical, integer, real, or double precision.
$nexp 0414
Error : The conditional expression must be type logical, integer, real, or double precision.
.PP
If the two-branch \*CIF\fR is intended to be the indirect logical IF, the conditional
expression must be type logical.  If the two-branch \*CIF\fR is intended to be the
two-branch arithmetic \*CIF\fR, the conditional expression must be type integer, 
real, or double precision.
.PP
Both forms of two-branch \*CIF\fR statements are outmoded features from
CF77.  They should no longer be used. 
.ME
$
$ Error : 0415
$msg  0415 A blank is required before this lexical token in free source form.
$nexp 0415
Error : A blank is required before this lexical token in free source form.
.PP
The Fortran standard requires a blank to separate names, constants, or 
labels from adjacent keywords, names, constants or labels.
.ME
$
$ Error : 0416
$msg  0416 The conditional expression must be type logical.
$nexp 0416
Error : The conditional expression must be type logical.
.PP
The syntax of an \*CIF-THEN\fR statement is:
.CS
 [\fIif_construct_name\*C:] IF (\fIscalar_logical_expr\*C) THEN
.CE
.PP
The syntax of an \*CELSE IF\fR statement is:
.CS
 ELSE IF (\fIscalar_logical_expr\*C)\fR \*CTHEN\fR \*C[\fIif_construct_name\*C]
.CE
.PP
The syntax of an \*CIF\fR statement is:
.CS
  IF (\fIscalar_logical_expr\*C) \fIaction_stmt\fR
.CE
.PP
In all three cases, the conditional expression must be type logical and must
be scalar.
.ME
$
$ Error : 0417
$msg  0417 The pointer-object in a pointer assignment statement must have the POINTER attribute.
$nexp 0417
Error : The pointer-object in a pointer assignment statement must have the POINTER attribute.
.PP
The left side of a pointer assignment statement must have the \*CPOINTER\fR
attribute.
.ME
$
$ Error : 0418
$msg  0418 The right side of a pointer assignment must either have the POINTER attribute, or have the TARGET attribute and not be protected.
$nexp 0418
Error : The right side of a pointer assignment must either have the POINTER attribute, or have the TARGET attribute and not be protected.
.PP
The variable that is the right side of a pointer assignment statement may be a
pointer, or it may be a non-pointer variable. If the latter, it must have the
TARGET attribute, and it must not be a use-associated variable with the
PROTECTED attribute.
.ME
$
$ Error : 0419
$msg  0419 The target in a pointer assignment statement must have the same type parameters as the pointer.
$nexp 0419
Error : The target in a pointer assignment statement must have the same type parameters as the pointer.
.PP
To be valid, both sides of a pointer assignment statement must agree in type, kind type, and
rank.  This also applies to a structure constructor
expression that corresponds to a pointer component.
.ME
$
$ Error : 0420
$msg  0420 The target in a pointer assignment statement must not be an array section with a vector subscript.
$nexp 0420
Error : The target in a pointer assignment statement must not be an array section with a vector subscript.
.PP
The right side of a pointer assignment statement must not be an array
section with a vector valued subscript.  This also applies to an expression
within a structure constructor whose corresponding component is a pointer.
.ME
$
$ Error : 0421
$msg  0421 An expression used in a pointer assignment statement must deliver a pointer result.
$nexp 0421
Error : An expression used in a pointer assignment statement must deliver a pointer result.
.PP
Only pointer valued functions can be on the right side of a pointer
assignment statement.
.ME
$
$ Error : 0422
$msg  0422 Character '%c' is not valid in a binary constant.
$nexp 0422
Error : Character '%c' is not valid in a binary constant.
.PP
In a binary constant (\fIboz_literal_constant\fR), the only allowed digits
are 0 and 1.  The compiler detected a character outside this range.
.ME
$
$ Error : 0423
$msg  0423 Character '%c' is not valid in a hexadecimal constant.
$nexp 0423
Error : Character '%c' is not valid in a hexadecimal constant.
.PP
In a hexadecimal constant (either a BOZ or Boolean constant), the only allowed
digits are 0-9, and A-F (a-f is also legal).  The compiler detected a
character other than 0-9 or A-F.
.ME
$
$ Error : 0424
$msg  0424 Attribute %s appears more than once in this attribute list.
$nexp 0424
Error : Attribute %s appears more than once in this attribute list.
.PP
On a type declaration statement, it is illegal to specify the same attribute more
than once.  The compiler detected something like this example:
.CS
 REAL, ALLOCATABLE, DIMENSION(::), &
       ALLOCATABLE :: A
.CE
.PP
\*CALLOCATABLE\fR is in error.  It is specified twice.
.ME
$
$ Error : 0425
$msg  0425 Attributes %s and %s must not appear in the same attribute list.
$nexp 0425
Error : Attributes %s and %s must not appear in the same attribute list.
.PP
The specified attributes are mutually exclusive.  An object must not have
both attributes.  Following is a list of attributes, followed by conflicting attributes.
.PP
.TL 15
\*CALLOCATABLE
\*CEXTERNAL\fR,
\*CINTENT\fR,
\*CINTRINSIC\fR,
\*COPTIONAL\fR,
\*CPARAMETER\fR,
\*CPOINTER
.TL
DIMENSION
.TL
EXTERNAL
\*CALLOCATABLE\fR,
\*CINTENT\fR,
\*CINTRINSIC\fR,
\*CPARAMETER\fR,
\*CPOINTER\fR,
\*CSAVE\fR,
\*CTARGET
.TL
INTENT
\*CALLOCATABLE\fR,
\*CEXTERNAL\fR,
\*CINTRINSIC\fR,
\*CPARAMETER\fR,
\*CPOINTER\fR,
\*CSAVE
.TL
\*CINTRINSIC
ALLOCATABLE\fR,
\*CEXTERNAL\fR,
\*CINTENT\fR,
\*CPARAMETER\fR,
\*CPOINTER\fR,
\*CPRIVATE\fR,
\*CPUBLIC\fR,
\*CSAVE\fR,
\*CTARGET
.TL
OPTIONAL
ALLOCATABLE\fR,
\*CPARAMETER\fR,
\*CSAVE
.TL
PARAMETER
ALLOCATABLE\fR,
\*CEXTERNAL\fR,
\*CINTENT\fR,
\*CINTRINSIC\fR,
\*COPTIONAL\fR,
\*CPOINTER\fR,
\*CTARGET
.TL
POINTER
ALLOCATABLE\fR,
\*CEXTERNAL\fR,
\*CINTENT\fR,
\*CINTRINSIC\fR,
\*CPARAMETER\fR,
\*CTARGET
.TL
PRIVATE
INTRINSIC\fR,
\*CPUBLIC
.TL
PUBLIC
INTRINSIC\fR,\*C
PRIVATE
.TL
SAVE
EXTERNAL\fR,
\*CINTENT\fR,
\*CINTRINSIC\fR,
\*COPTIONAL
.TL
TARGET
EXTERNAL\fR,
\*CINTRINSIC\fR,
\*CPARAMETER\fR,
\*CPOINTER\fR
.ME
$
$ Error : 0426
$msg  0426 Each pointer-object in a NULLIFY statement must have the POINTER attribute.
$nexp 0426
Error : Each pointer-object in a NULLIFY statement must have the POINTER attribute.
.PP
Each object in a \*CNULLIFY\fR statement must be a variable name or structure
component that has the \*CPOINTER\fR attribute.
.ME
$
$ Error : 0427
$msg  0427 The STAT= variable must not be deallocated within the same DEALLOCATE statement.
$nexp 0427
Error : The STAT= variable must not be deallocated within the same DEALLOCATE statement.
.PP
The \*CSTAT=\fR variable in this \*CDEALLOCATE\fR statement is being deallocated in the
same statement.
.ME
$
$ Error : 0428
$msg  0428 An allocate object must be either a pointer or an allocatable array in a DEALLOCATE statement.
$nexp 0428
Error : An allocate object must be either a pointer or an allocatable array in a DEALLOCATE statement.
.PP
All arguments in an \*CALLOCATE\fR statement must be previously declared to be
either a pointer or an allocatable array.
.ME
$
$ Error : 0429
$msg  0429 Only scalar objects can be deallocated in a DEALLOCATE statement.
$nexp 0429
Error : Only scalar objects can be deallocated in a DEALLOCATE statement.
.PP
The \fIdeallocate_object_list\fR of a \*CDEALLOCATE\fR statement contains a nonscalar
object.  This is because a \fIpart_ref\fR in a derived type reference
is a whole array reference or an array section.
.ME
$
$ Error : 0430
$msg  0430 A deallocate object in a DEALLOCATE statement cannot be an array element or section.
$nexp 0430
Error : A deallocate object in a DEALLOCATE statement cannot be an array element or section.
.PP
An object in a \fIdeallocate_object_list\fR must be the name of a pointer or allocatable
array.  It can be a structure component but it cannot be an array element 
reference or an array section.
.ME
$
$ Error : 0431
$msg  0431 The target in a pointer assignment statement must have the same rank as the pointer.
$nexp 0431
Error : The target in a pointer assignment statement must have the same rank as the pointer.
.PP
To be valid, both sides of a pointer assignment statement must agree in type, kind type, and
rank in order to be valid. This also applies to a structure constructor
expression that corresponds to a pointer component.
.ME
$
$ Error : 0432
$msg  0432 Pointer assignment of a %s target or pointer to a %s pointer is not allowed.
$nexp 0432
Error : Pointer assignment of a %s target or pointer to a %s pointer is not allowed.
.PP
Both sides of a pointer assignment statement must agree in type, kind type, and
rank in order to be valid.  This also applies to a structure constructor
expression that corresponds to a pointer component.
.ME
$
$ Internal : 0433
$msg  0433 Attempting to split an I/O statement without creating a begin and end I/O statement.
$nexp 0433
Internal : Attempting to split an I/O statement without creating a begin and end I/O statement.
.PP
The compiler detected that the flag \*Cio_stmt_must_be_split\fR was false when
it was inside routines that split I/O statements into multiple statements.
This implies an internal error condition.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0434
$msg  0434 Illegal association of a scalar actual argument to an assumed-shape dummy argument "%s".
$nexp 0434
Error : Illegal association of a scalar actual argument to an assumed-shape dummy argument "%s".
.PP
An assumed-shape array dummy argument cannot have a scalar actual argument
associated with it.
.ME
$
$ Error : 0435
$msg  0435 Illegal association of a scalar actual argument with array dummy argument "%s".
$nexp 0435
Error : Illegal association of a scalar actual argument with array dummy argument "%s".
.PP
Unless a scalar actual argument is an array element reference, it cannot 
be passed to an array dummy argument.
.ME
$
$ Error : 0436
$msg  0436 Illegal association of an array-valued actual argument with a scalar dummy argument "%s".
$nexp 0436
Error : Illegal association of an array-valued actual argument with a scalar dummy argument "%s".
.PP
A scalar dummy argument requires a scalar actual argument.
.ME
$
$ Error : 0437
$msg  0437 "%s" has the %s attribute, therefore it must not be used in a bounds specification expression.
$nexp 0437
Error : "%s" has the %s attribute, therefore it must not be used in a bounds specification expression.
.PP
This object must not be used in a bounds specification expression because it
has the \*COPTIONAL\fR attribute.
.ME
$
$ Error : 0438
$msg  0438 Namelist group "%s" has the PUBLIC attribute so namelist group object "%s" cannot have the PRIVATE attribute.
$nexp 0438
Error : Namelist group "%s" has the PUBLIC attribute so namelist group object "%s" cannot have the PRIVATE attribute.
.PP
If a namelist group name has the \*CPUBLIC\fR attribute, no item in the namelist 
group object list can have the \*CPRIVATE\fR attribute. Also, no group object 
list item of derived type can have a component with the \*CPRIVATE\fR attribute.
.ME
$
$ Error : 0439
$msg  0439 The I/O control list for a %s statement must have a UNIT specifier.
$nexp 0439
Error : The I/O control list for a %s statement must have a UNIT specifier.
.PP
A \*CUNIT\fR specifier, for either an external or internal file, must be present
for this I/O statement.
.ME
$
$ Error : 0440
$msg  0440 The I/O control list for an INQUIRE statement must have either a UNIT or FILE specifier.
$nexp 0440
Error : The I/O control list for an INQUIRE statement must have either a UNIT or FILE specifier.
.PP
The \*CINQUIRE\fR statement must have either a \*CUNIT\fR or \*CFILE\fR specifier.  It cannot have both.
.ME
$
$ Error : 0441
$msg  0441 A type %s expression is not valid as an argument for the %s specifier of a %s statement.
$nexp 0441
Error : A type %s expression is not valid as an argument for the %s specifier of a %s statement.
.PP
The I/O control list specifier is not valid.
.ME
$
$ Error : 0442
$msg  0442 The INQUIRE statement must not have both the UNIT and FILE specifiers.
$nexp 0442
Error : The INQUIRE statement must not have both the UNIT and FILE specifiers.
.PP
The \*CINQUIRE\fR statement must have either a \*CUNIT\fR or \*CFILE\fR specifier.  It cannot have both.
.ME
$
$ Error : 0443
$msg  0443 The FMT and NML specifiers must not be specified in the same I/O control list.
$nexp 0443
Error : The FMT and NML specifiers must not be specified in the same I/O control list.
.PP
An I/O control list was encountered for a \*CWRITE\fR or a \*CREAD\fR statement that
had both the \*CFMT\fR and the \*CNML\fR specifiers.  The statement can either be a
formatted or a namelist I/O statement; it cannot be both.
.ME
$
$ Error : 0444
$msg  0444 A namelist group name must not be present if an I/O list is present.
$nexp 0444
Error : A namelist group name must not be present if an I/O list is present.
.PP
Namelist I/O cannot have an input or output list.
.ME
$
$ Error : 0445
$msg  0445 The %s specifier cannot be used in a WRITE statement control list.
$nexp 0445
Error : The %s specifier cannot be used in a WRITE statement control list.
.PP
The \*CEND=\fR, \*CEOR=\fR, and \*CSIZE=\fR specifiers cannot be used with a \*CWRITE\fR statement.
.ME
$
$ Error : 0446
$msg  0446 The NML= control list specifier requires a namelist group name as an argument.
$nexp 0446
Error : The NML= control list specifier requires a namelist group name as an argument.
.PP
The \*CNML=\fR specifier is in a \*CREAD\fR, \*CWRITE\fR or \*CPRINT\fR statement that has an
argument that is not a namelist group name.
.ME
$
$ Error : 0447
$msg  0447 The FMT= control list item must be a label, a character expression or an ASSIGN integer variable.
$nexp 0447
Error : The FMT= control list item must be a label, a character expression or an ASSIGN integer variable.
.PP
A format I/O control list specifier must either be a label or an integer 
variable.  The I/O control list specifier must have previously been defined
in an \*CASSIGN\fR statement, or it must be a character variable or a character
expression.
.ME
$
$ Error : 0448
$msg  0448 This I/O control list item must be a label.
$nexp 0448
Error : This I/O control list item must be a label.
.PP
I/O specifiers that specify branch targets, such as \*CEOR=\fR, \*CERR=\fR or
\*CEND\fR=, must have a label as an argument.
.ME
$
$ Error : 0449
$msg  0449 A rank %d expression is not valid for the %s control list specifier.
$nexp 0449
Error : A rank %d expression is not valid for the %s control list specifier.
.PP
An item in the I/O control list has a rank greater than zero.
.ME
$
$ Internal : 0450
$msg  0450 Procedure get_type_desc has been called with something that does not need a type descriptor.
$nexp 0450
Internal : Procedure get_type_desc has been called with something that does not need a type descriptor.
.PP
During the PDGCS interface, get_type_desc was called to find a type descriptor
for something that does not need a type.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0451
$msg  0451 This reference to function %s without an actual argument list is illegal.
$nexp 0451
Error : This reference to function %s without an actual argument list is illegal.
.PP
This call to a function has no parentheses following it.  If the actual
argument list is empty, the function name must be followed by parentheses when it is
being called.
.ME
$
$ Error : 0452
$msg  0452 This reference to subroutine %s is not in a CALL statement.
$nexp 0452
Error : This reference to subroutine %s is not in a CALL statement.
.PP
A reference to a subroutine is in an expression.  A subroutine subprogram 
must only be called with a \*CCALL\fR statement.
.ME
$
$ Error : 0453
$msg  0453 This reference to main program %s is illegal.
$nexp 0453
Error : This reference to main program %s is illegal.
.PP
A reference to a main program name is in an expression.  A main program name
must not be referenced.
.ME
$
$ Error : 0454
$msg  0454 This reference to block data %s is illegal.
$nexp 0454
Error : This reference to block data %s is illegal.
.PP
A reference to a block data name is in an expression.  A block data 
subprogram name must not be referenced.
.ME
$
$ Error : 0455
$msg  0455 This reference to module %s is illegal.
$nexp 0455
Error : This reference to module %s is illegal.
.PP
A reference to a module name is in an expression.  A module name must not be
specified in an expression.
.ME
$
$ Error : 0456
$msg  0456 Main program %s is an illegal reference in a CALL statement.
$nexp 0456
Error : Main program %s is an illegal reference in a CALL statement.
.PP
A main program name must not be specified in a \*CCALL\fR statement.
.ME
$
$ Error : 0457
$msg  0457 Blockdata "%s" is an illegal reference in a CALL statement.
$nexp 0457
Error : Blockdata "%s" is an illegal reference in a CALL statement.
.PP
A block data subprogram name must not be specified in a \*CCALL\fR statement.
.ME
$
$ Error : 0458
$msg  0458 Module %s is an illegal reference in a CALL statement.
$nexp 0458
Error : Module %s is an illegal reference in a CALL statement.
.PP
A module name must not be specified in a \*CCALL\fR statement.
.ME
$
$ Error : 0459
$msg  0459 A type %s variable is not valid as an argument for the %s specifier of a %s statement.
$nexp 0459
Error : A type %s variable is not valid as an argument for the %s specifier of a %s statement.
.PP
The type of the variable used as an I/O control list specifier is not valid.
.ME
$
$ Error : 0460
$msg  0460 The %s control list specifier must have a scalar %s variable, not constant or protected, as an argument for this %s statement.
$nexp 0460
Error : The %s control list specifier must have a scalar %s variable, not constant or protected, as an argument for this %s statement.
.PP
Some I/O control list specifiers require a variable name as an argument.  It
must be of the required type and must have default kind type. It must not be a
constant or a use-associated protected variable.
.ME
$
$ Error : 0461
$msg  0461 The %s I/O control list specifier requires an argument with default kind parameter for the %s statement.
$nexp 0461
Error : The %s I/O control list specifier requires an argument with default kind parameter for the %s statement.
.PP
The control list item does not have a default kind type.
.ME
$
$ Error : 0462
$msg  0462 If the FMT= specifier is an integer variable, it must be of default kind type.
$nexp 0462
Error : If the FMT= specifier is an integer variable, it must be of default kind type.
.PP
An integer variable used as a format specifier in a \*CREAD\fR, \*CWRITE\fR, or \*CPRINT\fR statement
must be of default integer type.
.ME
$
$ Error : 0463
$msg  0463 If REC= is present, an END= specifier must not appear in a %s statement.
$nexp 0463
Error : If REC= is present, an END= specifier must not appear in a %s statement.
.PP
An \*CEND=\fR specifier in a \*CREAD\fR or \*CWRITE\fR statement also has a \*CREC=\fR specifier.
.ME
$
$ Error : 0464
$msg  0464 If REC= is present, the format must not be list-directed in a %s statement.
$nexp 0464
Error : If REC= is present, the format must not be list-directed in a %s statement.
.PP
An asterisk (*) is the format specifier in a \*CREAD\fR or \*CWRITE\fR statement that also has
a \*CREC=\fR specifier.
.ME
$
$ Error : 0465
$msg  0465 If an EOR= specifier is present, an ADVANCE= specifier must also appear in a %s statement.
$nexp 0465
Error : If an EOR= specifier is present, an ADVANCE= specifier must also appear in a %s statement.
.PP
An \*CEOR=\fR specifier is in a \*CREAD\fR or \*CWRITE\fR statement that does not have an
\*CADVANCE=\fR specifier.
.ME
$
$ Error : 0466
$msg  0466 If REC= is present, a namelist group name must not appear in a %s statement.
$nexp 0466
Error : If REC= is present, a namelist group name must not appear in a %s statement.
.PP
A namelist group name is in a \*CREAD\fR or \*CWRITE\fR statement that has a \*CREC=\fR specifier.
.ME
$
$ Error : 0467
$msg  0467 A variable used as an internal file must not be an array section with a vector subscript.
$nexp 0467
Error : A variable used as an internal file must not be an array section with a vector subscript.
.PP
A character variable used as the \*CUNIT\fR specifier in a \*CREAD\fR or \*CWRITE\fR statement
has a vector subscript.
.ME
$
$ Error : 0468
$msg  0468 If an ADVANCE= specifier is present, the FMT= specifier must be present.
$nexp 0468
Error : If an ADVANCE= specifier is present, the FMT= specifier must be present.
.PP
An \*CADVANCE=\fR specifier can be present only in a formatted sequential I/O
statement with explicit format specification and no 
internal file unit specifier.
.ME
$
$ Error : 0469
$msg  0469 If an ADVANCE= specifier is present, the FMT= specifier must not be list-directed.
$nexp 0469
Error : If an ADVANCE= specifier is present, the FMT= specifier must not be list-directed.
.PP
An \*CADVANCE=\fR specifier can be present only in a formatted sequential I/O
statement with explicit format specification and no
internal file unit specifier.
.ME
$
$ Error : 0470
$msg  0470 If the ADVANCE= specifier is present, the UNIT= specifier must not specify an internal file.
$nexp 0470
Error : If the ADVANCE= specifier is present, the UNIT= specifier must not specify an internal file.
.PP
An \*CADVANCE=\fR specifier can be present only in a formatted sequential I/O
statement with explicit format specification and no
internal file unit specifier.
.ME
$
$ Error : 0471
$msg  0471 If the UNIT= specifier refers to an internal file, the REC= specifier must not be present.
$nexp 0471
Error : If the UNIT= specifier refers to an internal file, the REC= specifier must not be present.
.PP
If the unit specifier specifies an internal file, the \fIio_control_spec_list\fR
must not contain a \*CREC=\fR specifier or a namelist group name.
.ME
$
$ Error : 0472
$msg  0472 If the UNIT= specifier refers to an internal file, a namelist group name must not be present.
$nexp 0472
Error : If the UNIT= specifier refers to an internal file, a namelist group name must not be present.
.PP
If the unit specifier specifies an internal file, the \fIio_control_spec_list\fR
must not contain a \*CREC=\fR specifier or a namelist group name.
.ME
$
$ Error : 0473
$msg  0473 If the ADVANCE= specifier is present, the statement must be a sequential access I/O statement.
$nexp 0473
Error : If the ADVANCE= specifier is present, the statement must be a sequential access I/O statement.
.PP
An \*CADVANCE=\fR specifier can be present only in a formatted sequential I/O
statement with explicit format specification and no internal file unit
specifier.  The \*CREC=\fR specifier makes this a direct access I/O statement.
.ME
$
$ Error : 0474
$msg  0474 The DO variable of an implied-DO loop must be integer, default real, or double precision real.
$nexp 0474
Error : The DO variable of an implied-DO loop must be integer, default real, or double precision real.
.PP
The \*CDO\fR variable must be integer, real, or double precision real.  
.ME
$
$ Error : 0475
$msg  0475 Specific interface "%s" must be a subroutine, if it is inside a defined assignment interface block.
$nexp 0475
Error : Specific interface "%s" must be a subroutine, if it is inside a defined assignment interface block.
.PP
A specific interface is within a defined assignment interface block, but is
not a subroutine.  All specific interfaces in a defined assignment interface
block must be subroutines.
.ME
$
$ Error : 0476
$msg  0476 This implied-DO control expression must be scalar.
$nexp 0476
Error : This implied-DO control expression must be scalar.
.PP
The numeric expressions controlling an implied-\*CDO\fR loop in an I/O statement
I/O list must be scalar.  These expressions are the start value of the
implied-\*CDO\fR variable, the finish value, and the optional increment value.
.ME
$
$ Error : 0477
$msg  0477 This implied-DO control expression must be an integer, default real, or double precision real expression. 
$nexp 0477
Error : This implied-DO control expression must be an integer, default real, or double precision real expression. 
.PP
Each implied-\*CDO\fR control expression must be a scalar numeric expression of 
integer, default real, or double precision real type.
.ME
$
$ Error : 0478
$msg  0478 An expression cannot be used as an input item in a %s statement.
$nexp 0478
Error : An expression cannot be used as an input item in a %s statement.
.PP
An I/O input item is an expression.  Input items must be variables.
.ME
$
$ Error : 0479
$msg  0479 A constant or protected variable cannot be used as an input item in a %s statement.
$nexp 0479
Error : A constant or protected variable cannot be used as an input item in a %s statement.
.PP
An I/O input item must be a variable which is not use-associated and protected.
.ME
$
$ Warning : 0480
$msg  0480 Type %s*%d will be mapped to DOUBLE PRECISION.
$nexp 0480
Warning : Type %s*%d will be mapped to DOUBLE PRECISION.
.PP
Type DOUBLE PRECISION*16 has been mapped to DOUBLE PRECISION, because the
compiler does not currently support DOUBLE PRECISION*16.
.ME
$
$ Error : 0481
$msg  0481 This implied-DO control variable is not valid.
$nexp 0481
Error : This implied-DO control variable is not valid.
.PP
An expression, constant, or use-associated protected variable appears where an implied-\*CDO\fR variable is expected.
.ME
$
$ Error : 0482
$msg  0482 This implied-DO variable is not scalar.
$nexp 0482
Error : This implied-DO variable is not scalar.
.PP
An implied-\*CDO\fR variable has a rank greater than zero.
.ME
$
$ Error : 0483
$msg  0483 The IOLENGTH= specifier in an INQUIRE statement must be a scalar default integer variable, not constant or protected.
$nexp 0483
Error : The IOLENGTH= specifier in an INQUIRE statement must be a scalar default integer variable, not constant or protected.
.PP
In an \*CINQUIRE\fR statement, the \*CIOLENGTH=\fR specifier  requires that a
scalar integer variable of default kind type be specified.
.ME
$
$ Error : 0484
$msg  0484 "%s" has an ultimate component that has the POINTER or ALLOCATABLE attribute, therefore it must not be in a namelist group.
$nexp 0484
Error : "%s" has an ultimate component that has the POINTER or ALLOCATABLE attribute, therefore it must not be in a namelist group.
.PP
A namelist group object cannot have a derived type with a pointer or
allocatable component.
Items of derived type that have pointer or allocatable
components are not allowed in namelist groups.
.ME
$
$ Ansi : 0485
$msg  0485 A character constant file name used as a UNIT= specifier is an extension of the Fortran standard.
$nexp 0485
Ansi : A character constant file name used as a UNIT= specifier is an extension of the Fortran standard.
.PP
A character constant is specified where a unit number is expected.
The constant is interpreted as the name of a file and is an extension to 
the Fortran standard.
.ME
$
$ Error : 0486
$msg  0486 "%s" has been use associated from module "%s" and at least one more module.  It must not be referenced.
$nexp 0486
Error : "%s" has been use associated from module "%s" and at least one more module.  It must not be referenced.
.PP
If an entity is use associated from more than one module, it cannot
be referenced.  For example:
.CS
  MODULE one
    INTEGER two_uses
  END MODULE

  MODULE two
    INTEGER two_uses
  END MODULE

  PROGRAM show
    USE one
    USE two       \fR! It is legal to use\*C 
                  \fR! associate \*CTWO_USES\fR twice.\*C

    J = two_uses  \fR! This is illegal, because\*C 
                  \fR! the compiler cannot determine\*C
                  \fR! which \*CTWO_USES\fR is correct.
.CE
.ME
$
$ Error : 0487
$msg  0487 The specific interfaces for "%s" and "%s" make the %s interface "%s" ambiguous.
$nexp 0487
Error : The specific interfaces for "%s" and "%s" make the %s interface "%s" ambiguous.
.PP
Two specific interfaces in a generic or defined interface 
are ambiguous.  Within a scoping unit, two procedures in the same generic or
defined interface are differentiated by their nonoptional dummy arguments.
One way to differentiate the specific interfaces is by the number of dummy arguments.  If the specific interfaces have
the same number of dummy arguments, the dummy arguments must differ in type,
kind type or rank.  

If the IGNORE_TKR directive is specified for a dummy argument, that dummy
argument is considered ambigous with every other dummy argument in the
same position or name.
.ME
$
$ Error : 0488
$msg  0488 All bounds and kind selector expressions must be type integer, but this expression is type %s.
$nexp 0488
Error : All bounds and kind selector expressions must be type integer, but this expression is type %s.
.PP
The compiler detected a noninteger expression in a bounds expression
or in a kind selector expression.  Bounds expressions are used to declare
array dimension size and character length and must always be type integer.
Kind selector expressions must always be integer constants and are used to
declare the kind of a type.
.ME
$
$ Error : 0489
$msg  0489 The specific interface "%s" must have exactly two dummy arguments when inside a defined assignment interface block.
$nexp 0489
Error : The specific interface "%s" must have exactly two dummy arguments when inside a defined assignment interface block.
.PP
A defined assignment interface block must have only specific interfaces within
it that are subroutines with exactly two required dummy arguments.
.ME
$
$ Error : 0490
$msg  0490 Dummy argument "%s" must not have the OPTIONAL attribute within a defined operator or assignment interface block.
$nexp 0490
Error : Dummy argument "%s" must not have the OPTIONAL attribute within a defined operator or assignment interface block.
.PP
A dummy argument has the \*COPTIONAL\fR attribute, but the specific interface it
is declared in is a defined operator or defined assignment interface block.
.ME
$
$ Error : 0491
$msg  0491 Dummy argument "%s" must be specified with INTENT(%s) within a defined %s interface block.
$nexp 0491
Error : Dummy argument "%s" must be specified with INTENT(%s) within a defined %s interface block.
.PP
Within a defined operator or defined assignment interface block the intents
of dummy arguments must be specified with certain values.
For defined assignment, the first dummy argument must have \*CINTENT(OUT)\fR or 
\*CINTENT(INOUT)\fR.  The second dummy argument must have \*CINTENT(IN)\fR.  For defined
operators, the dummy arguments must have \*CINTENT(IN)\fR.
.ME
$
$ Error : 0492
$msg  0492 Specific interface "%s" must be a function within a defined operator interface block.
$nexp 0492
Error : Specific interface "%s" must be a function within a defined operator interface block.
.PP
All specific interfaces within a defined operator interface block must be 
functions with one or two dummy arguments.
.ME
$
$ Error : 0493
$msg  0493 The function result cannot be assumed-length character for "%s" because it is in a defined operator interface block.
$nexp 0493
Error : The function result cannot be assumed-length character for "%s" because it is in a defined operator interface block.
.PP
A function specific interface within a defined operator interface block cannot
have an assumed-length character result.
.ME
$
$ Error : 0494
$msg  0494 The specific interface "%s" must have exactly one dummy argument when inside a defined unary operator interface block.
$nexp 0494
Error : The specific interface "%s" must have exactly one dummy argument when inside a defined unary operator interface block.
.PP
All specific interfaces within this defined operator interface block are interpreted as 
unary operations and therefore must have only one argument.
.ME
$
$ Error : 0495
$msg  0495 This specific interface "%s" conflicts with the intrinsic use of "%s".
$nexp 0495
Error : This specific interface "%s" conflicts with the intrinsic use of "%s".
.PP
A specific interface in a defined operator or assignment interface block
has dummy arguments with types, kind types, and rank that are valid as 
an intrinsic use of the operator.  This conflict creates an
ambiguity and is not allowed.
.ME
$
$ Error : 0496
$msg  0496 The specific interface "%s" must have exactly two dummy arguments when inside a defined binary operator interface block.
$nexp 0496
Error : The specific interface "%s" must have exactly two dummy arguments when inside a defined binary operator interface block.
.PP
In a defined operator interface block, the number of dummy arguments
to a specific interface must match the intrinsic use of the operator.
A strictly binary operator, such as the asterisk, requires two dummy arguments.
.ME
$
$ Error : 0497
$msg  0497 The specific interface "%s" must have one or two dummy arguments when inside a defined operator interface block.
$nexp 0497
Error : The specific interface "%s" must have one or two dummy arguments when inside a defined operator interface block.
.PP
In a defined operator interface block, the number of dummy arguments to a
specific interface must match the intrinsic use of the operator.  Operators 
like \*C+\fR or \*C-\fR can be used as both unary or binary operators and therefore
the specific interfaces may have either one or two dummy arguments.
.ME
$
$ Error : 0498
$msg  0498 Dummy argument "%s" is a dummy procedure.  This is not allowed within a defined %s interface.
$nexp 0498
Error : Dummy argument "%s" is a dummy procedure.  This is not allowed within a defined %s interface.
.PP
Specific interfaces within a defined assignment or defined operator interface
block must have dummy arguments that are data objects.   Dummy procedures are
not allowed.
.ME
$
$ Error : 0499
$msg  0499 A defined operator must not be the same as a logical literal constant.
$nexp 0499
Error : A defined operator must not be the same as a logical literal constant.
.PP
A logical literal constant, \*C.TRUE.\fR or \*C.FALSE.\fR, is specified where an 
operator is expected.
.ME
$
$ Error : 0500
$msg  0500 Array "%s" is assumed-size, therefore it must be a dummy argument.
$nexp 0500
Error : Array "%s" is assumed-size, therefore it must be a dummy argument.
.PP
An array that is declared with the assumed-size specifier, must be a
dummy argument.  If it is type character it can also be a Cray character
pointee.
Cray pointers are an extension to the Fortran standard.
.ME
$
$ Error : 0501
$msg  0501 "%s" is an assumed-size array of type character.  It must be a dummy argument or a pointee of a Cray character pointer.
$nexp 0501
Error : "%s" is an assumed-size array of type character.  It must be a dummy argument or a pointee of a Cray character pointer.
.PP
A character array that is declared with the assumed-length specifier must be a
dummy argument or the pointee of a Cray character pointer.
Cray pointers are an extension to the Fortran standard.
.ME
$
$ Error : 0502
$msg  0502 This actual argument is not a program unit.  Dummy argument "%s" is a dummy procedure.
$nexp 0502
Error : This actual argument is not a program unit.  Dummy argument "%s" is a dummy procedure.
.PP
The subprogram being called has an explicit interface.  This explicit interface
allows the actual argument to be compared with the dummy argument.  This
check has revealed a mismatch between the actual argument and the dummy
argument.  The dummy argument is a dummy procedure and the actual argument is
not a program unit.
.ME
$
$ Error : 0503
$msg  0503 Argument mismatch:  Actual argument "%s" is a "%s".  Dummy argument "%s" is a "%s".
$nexp 0503
Error : Argument mismatch:  Actual argument "%s" is a "%s".  Dummy argument "%s" is a "%s".
.PP
The subprogram being called has an explicit interface.  This explicit interface
allows the actual argument to be compared with the dummy argument.  This
check has revealed a mismatch between the actual argument and the dummy
argument. 
.ME
$
$ Error : 0504
$msg  0504 Actual argument "%s" is a label but dummy argument "%s" is not an alternate return specifier.
$nexp 0504
Error : Actual argument "%s" is a label but dummy argument "%s" is not an alternate return specifier.
.PP
Labels must only be passed to dummy arguments that are "*" alternate return
specifiers.
.ME
$
$ Error : 0505
$msg  0505 Continuation of character context in free source form requires an "&" as the first nonblank character of the next line.
$nexp 0505
Error : Continuation of character context in free source form requires an "&" as the first nonblank character of the next line.
.PP
A character context continuation in free source form must have an \*C&\fR as the
first nonblank character in the next line.
.ME
$
$ Error : 0506
$msg  0506 Function "%s" is recursive, therefore it must not be typed as assumed-length character.
$nexp 0506
Error : Function "%s" is recursive, therefore it must not be typed as assumed-length character.
.PP
The Fortran standard prohibits the typing of a recursive function as 
assumed-length character.
.PP
A function name must not be declared with an asterisk character length if
the function is an internal or module function, array-valued, pointer-valued,
or is recursive.
.ME
$
$ Error : 0507
$msg  0507 Function "%s" is array-valued and/or pointer-valued, therefore it must not be typed as assumed-length character.
$nexp 0507
Error : Function "%s" is array-valued and/or pointer-valued, therefore it must not be typed as assumed-length character.
.PP
The Fortran standard prohibits typing a function whose result is an array
or a pointer as assumed-length character.
.PP
A function name must not be declared with an asterisk character
length if the function is an internal or module function, 
array-valued, pointer-valued, or is recursive.
.ME
$
$ Error : 0508
$msg  0508 The parent-string of a substring reference must be of type character.
$nexp 0508
Error : The parent-string of a substring reference must be of type character.
.PP
A substring can only be formed from a character variable or a character
constant.
.ME
$
$ Error : 0509
$msg  0509 "%s" is a %s, therefore it must not be used in a bounds specification expression.
$nexp 0509
Error : "%s" is a %s, therefore it must not be used in a bounds specification expression.
.PP
The compiler has detected a conflict between a declaration and a use of this
object.  The object must not be used in a bounds specification expression
because it has been declared to be one of the following:
.nf
        Cray pointer
        Cray pointee
        function result
        module procedure
        internal procedure
        derived-type
        generic interface
        namelist group
        statement function
        construct
        module
        block data
        program
        subroutine
.fi
.ME
$
$ Ansi : 0510
$msg  0510 The use of ".%s." as a logical literal constant is an extension to the Fortran standard.
$nexp 0510
Ansi : The use of ".%s." as a logical literal constant is an extension to the Fortran standard.
.PP
These are extensions to the Fortran standard.
.CS
  .F.    \fR(for \*C.FALSE.\fR)\*C
  .T.    \fR(for \*C.TRUE.\fR)\*C
.CE
.PP
If either of these extension forms are declared as defined operators, then
the extension is not allowed.
.ME
$
$ Error : 0511
$msg  0511 "%s" is scalar, but it is being used as an array or function reference.
$nexp 0511
Error : "%s" is scalar, but it is being used as an array or function reference.
.PP
A name is followed by a parenthesized list, but it is not an array or a function name.
.ME
$
$ Error : 0512
$msg  0512 "%s" is the name of a namelist group.  This is an illegal usage.
$nexp 0512
Error : "%s" is the name of a namelist group.  This is an illegal usage.
.PP
A namelist group name must only be used as a control list item for a \*CREAD\fR,
\*CWRITE\fR, or \*CPRINT\fR statement to designate namelist I/O.
.ME
$
$ Error : 0513
$msg  0513 Unexpected syntax:  A comma, identifier, WHILE, or EOS was expected but found "%c".
$nexp 0513
Error : Unexpected syntax:  A comma, identifier, WHILE, or EOS was expected but found "%c".
.PP
The format of a \*CDO\fR statement is:
.CS
   [\fIdo_construct_name\*C:] DO [\fIlabel\*C] [\fIloop_control\*C]
.CE
.PP
The format of \fIloop_control\fR is:
.CS
     [,] \fIdo_variable\*C = \fIscalar_numeric_expr\*C,
	\fIscalar_numeric_expr\*C [, \fIscalar_numeric_expr\*C]

                     \fRor\*C
     
     [,] WHILE (\fIscalar_logical_expr\*C)
.CE
.PP
The compiler found the keyword \*CDO\fR followed by a label.  It was expecting the
label to be followed by a comma, an identifier, the keyword \*CWHILE\fR, or the end
of the statement but it found something else.
.ME
$
$ Internal : 0514
$msg  0514 malloc_check has found a problem with the malloc'd tables.  See previous message.
$nexp 0514
Internal : malloc_check has found a problem with the malloc'd tables.  See previous message.
.PP
In debug mode, malloc_check is called before every malloc, realloc and free.
This time malloc_check found a problem.  malloc_check will print a message,
describing the problem.  The message will be output before this internal
message.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0515
$msg  0515 Unexpected syntax:  A label, comma, identifier, WHILE, or EOS was expected but found "%c".
$nexp 0515
Error : Unexpected syntax:  A label, comma, identifier, WHILE, or EOS was expected but found "%c".
.PP
The format of a \*CDO\fR statement is:
.CS
   [\fIdo_construct_name\*C:] DO [\fIlabel\*C] [\fIloop_control\*C]
.CE
.PP
The format of \fIloop_control\fR is:
.CS
     [,] \fIdo_variable\*C = \fIscalar_numeric_expr\*C,
        \fIscalar_numeric_expr\*C [, \fIscalar_numeric_expr\*C]
 
                     \fRor\*C
 
     [,] WHILE (\fIscalar_logical_expr\*C)
.CE
.PP
\fRThe compiler found the keyword \*CDO\fR and was expecting it to be followed by a
statement label, a comma, an identifier, the keyword \*CWHILE\fR, or the end of the
statement.
.ME
$
$ Internal : 0516
$msg  0516 For "%s", LN_NAME_IDX (%d) does not match AT_NAME_IDX(%d).
$nexp 0516
Internal : For "%s", LN_NAME_IDX (%d) does not match AT_NAME_IDX(%d).
.PP
A symbol table entry needs to share the same name pool entry for the same name.
The local name table does not use the same name pool entry as the attribute
table.  This can cause bad index problems in module and interface
compression.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0517
$msg  0517 This DO variable is already being used as the DO variable of an outer loop.
$nexp 0517
Error : This DO variable is already being used as the DO variable of an outer loop.
.PP
An active \*CDO\fR variable can only have its value altered by its \*CDO\fR statement.  Its
value cannot be altered by any statement contained in the loop.  This means
that if a variable is being used as a \*CDO\fR variable, it cannot be used as the
\*CDO\fR variable of an inner loop.
.ME
$
$ Error : 0518
$msg  0518 "%s" is used as a subroutine, therefore it must not be used in a bounds specification expression.
$nexp 0518
Error : "%s" is used as a subroutine, therefore it must not be used in a bounds specification expression.
.PP
The compiler detected a conflict between uses of this object.  The object is
used as a subroutine, which prohibits it from being used in an expression.
.ME
$
$ Error : 0519
$msg  0519 Dummy argument "%s" has the INTENT(OUT) attribute, therefore it must not be used in a bounds specification expression.
$nexp 0519
Error : Dummy argument "%s" has the INTENT(OUT) attribute, therefore it must not be used in a bounds specification expression.
.PP
A dummy argument with \*CINTENT(OUT)\fR cannot be used in a bounds specification
expression.
.ME
$
$ Ansi : 0520
$msg  0520 Using external function "%s" in a bounds specification expression is nonstandard.  It should be PURE.
$nexp 0520
Ansi : Using external function "%s" in a bounds specification expression is nonstandard.  It should be PURE.
.PP
The Fortran standard allows specification functions be to specified
in array dimension bound declarators or character length declarators.
   
However, these functions must not have array-valued or pointer-valued results.
They must not be recursive and they must not have any arguments that are
procedures.   Internal functions are also not allowed.   The standard requires
these functions to be PURE.  This compiler allows functions without the PURE
attribute to be specified as an extension to the standard.  However PURE
functions are the safest to use in specification expressions.
.ME
$
$ Error : 0521
$msg  0521 Local variable "%s" must be a dummy argument or in common to be used in a bounds specification expression.
$nexp 0521
Error : Local variable "%s" must be a dummy argument or in common to be used in a bounds specification expression.
.PP
Each primary of a specification expression must be a constant, a dummy
argument, a common block member, use associated or host associated.  The compiler 
detected a variable that is not one of these things.
.ME
$
$ Ansi : 0522
$msg  0522 It is an extension to the Fortran standard to allow character and noncharacter to be equivalenced to each other.
$nexp 0522
Ansi : It is an extension to the Fortran standard to allow character and noncharacter to be equivalenced to each other.
.PP
If one object in an equivalence list is character or character sequence type,
then all of the objects in the list must be of character or character 
sequence type.  The compiler has relaxed this restriction.  Character and
noncharacter can be equivalenced to each other.  However, if a noncharacter
item does not align on a word boundary because of such an equivalence, a 
fatal error is issued.
.ME
$
$ Error : 0523
$msg  0523 The type of equivalence object "%s" is not identical to the type of the other equivalence objects.
$nexp 0523
Error : The type of equivalence object "%s" is not identical to the type of the other equivalence objects.
.PP
If an \fIequivalence_object\fR is of a derived type that is not a numeric sequence
or character sequence type, all objects in the equivalence group must be of
these types.  Or, if an \fIequivalence_object\fR is of an intrinsic type other than
default integer, default real, double precision real, default complex,
default logical, or character, all objects in the equivalence set must be
of the same type with the same kind type parameter value.
.ME
$
$ Error : 0524
$msg  0524 More than 499 continuation lines in fixed source form is not allowed.
$nexp 0524
Error : More than 499 continuation lines in fixed source form is not allowed.
.PP
The continuation line limits for the compiler are 499 for both fixed source 
form and free source form.
.ME
$
$ Error : 0525
$msg  0525 More than 499 continuation lines in free source form is not allowed.
$nexp 0525
Error : More than 499 continuation lines in free source form is not allowed.
.PP
The continuation line limits for the compiler are 499 for both fixed source 
form and free source form.
.ME
$
$ Error : 0526
$msg  0526 Common block "%s" has been extended past its start by equivalencing "%s".
$nexp 0526
Error : Common block "%s" has been extended past its start by equivalencing "%s".
.PP
A common block was extended past its starting address by equivalencing
a noncommon block variable to this common block.  Extending a common block
in this direction is not allowed.
.ME
$
$ Error : 0527
$msg  0527 Object "%s" does not start on a word boundary.  This is caused by equivalence alignment.
$nexp 0527
Error : Object "%s" does not start on a word boundary.  This is caused by equivalence alignment.
.PP
Equivalence alignment problems can be caused by the following:

A noncharacter object was equivalenced to a character object which 
caused the noncharacter object to not align on a word boundary.

An array whose elements are of a type that is smaller than the target
machine word size is equivalenced to a type that is of a machine word size.
.ME
$
$ Error : 0528
$msg  0528 Object "%s" is equivalenced in two different places.
$nexp 0528
Error : Object "%s" is equivalenced in two different places.
.PP
A variable was equivalenced so two different locations within
the same variable are overlayed.  For example:
.CS
  EQUIVALENCE (A(1), A(3))  ! This is illegal
.CE
.ME
$
$ Error : 0529
$msg  0529 Object "%s" has been previously used in an executable statement, therefore it must not be a dummy argument.
$nexp 0529
Error : Object "%s" has been previously used in an executable statement, therefore it must not be a dummy argument.
.PP
Dummy arguments in an \*CENTRY\fR statement must not be referenced in an executable
statement before they are declared.  They can be used in bounds specification
expressions.
.ME
$
$ Error : 0530
$msg  0530 An implied-DO variable must not be a variable subobject.
$nexp 0530
Error : An implied-DO variable must not be a variable subobject.
.PP
An implied-\*CDO\fR variable must be a named scalar variable of type integer,
default real or double precision real.
The name cannot be qualified by either component references or subscript lists.
.ME
$
$ Error : 0531
$msg  0531 Compiler directive %s must appear before the first executable statement.
$nexp 0531
Error : Compiler directive %s must appear before the first executable statement.
.PP
The following compiler directives must be specified in the declaration part
of the program unit.
.CS  
   !DIR$ AUXILIARY
   !DIR$ NAME
   !DIR$ NOSIDE EFFECTS
   !DIR$ SYMMETRIC
   !DIR$ TASK COMMON
   !DIR$ VFUNCTION

   !*$* ALIGN_SYMBOL
   !*$* FILL_SYMBOL

   !$OMP THREADPRIVATE
.CE
.ME
$
$ Error : 0532
$msg  0532 An input item must not be the implied-DO variable of any implied-DO loop that contains the input item.
$nexp 0532
Error : An input item must not be the implied-DO variable of any implied-DO loop that contains the input item.
.PP
An I/O input item was encountered within an implied-\*CDO\fR loop that was the
\*CDO\fR variable for that loop.
.ME
$
$ Error : 0533
$msg  0533 Reuse of "%s" as an implied-DO variable in a nested implied-DO is not allowed.
$nexp 0533
Error : Reuse of "%s" as an implied-DO variable in a nested implied-DO is not allowed.
.PP
The name of an implied-\*CDO\fR variable in a \*CDATA\fR statement appears more than
once in the implied-\*CDO\fR list or in an array constructor.  Examples of
statements that cause this message to be issued:
.CS
    DATA ((A(I,J), I = 1,5), I = 1,5)

    IARRY = (/ ((I + I, I = 1, 3), I = 1, 3) /)
.CE
.ME
$
$ Error : 0534
$msg  0534 "%s" is in blank common, therefore it must not be given the AUXILIARY attribute via a compiler directive statement.
$nexp 0534
Error : "%s" is in blank common, therefore it must not be given the AUXILIARY attribute via a compiler directive statement.
.PP
Arrays or variables that are in blank common are not allowed to be in 
auxiliary storage.
.ME
$
$ Error : 0535
$msg  0535 "%s" is typed as character, therefore it must not be given the AUXILIARY attribute via a compiler directive statement.
$nexp 0535
Error : "%s" is typed as character, therefore it must not be given the AUXILIARY attribute via a compiler directive statement.
.PP
Variables and arrays that are in auxiliary storage must not be typed as
character.
.ME
$
$ Error : 0536
$msg  0536 "%s" is type "%s" which has a character, pointer, or allocatable component, therefore it must not be in auxiliary storage.
$nexp 0536
Error : "%s" is type "%s" which has a character, pointer, or allocatable component, therefore it must not be in auxiliary storage.
.PP
If an item is in auxiliary storage and is typed as a derived type, no 
components of that derived type can be characters, pointers, or allocatable.
.ME
$
$ Error : 0537
$msg  0537 "%s" is in TASK COMMON block "%s".  It must not be given the AUXILIARY attribute via a compiler directive statement.
$nexp 0537
Error : "%s" is in TASK COMMON block "%s".  It must not be given the AUXILIARY attribute via a compiler directive statement.
.PP
A variable or an array in a \*CTASK COMMON\fR block must not be given the \*CAUXILIARY\fR attribute.
.ME
$
$ Error : 0538
$msg  0538 A negative base of type real cannot be raised to a real power.
$nexp 0538
Error : A negative base of type real cannot be raised to a real power.
.PP
The following is an example of an exponentiation operation that is mathematically undefined.
.CS
  (-1.0)**3.5
.CE
.PP
\fRSuch undefined expressions are not allowed.
.ME
$
$ Error : 0539
$msg  0539 A continuation line is expected but this is not a continuation line.
$nexp 0539
Error : A continuation line is expected but this is not a continuation line.
.PP
In free source form, if an \*C&\fR is encountered at the end of a line, it
signals that the line will continue onto the next noncomment line.
There is no noncomment line following this line.
.ME
$
$ Error : 0540
$msg  0540 The value specified for DIM is invalid.
$nexp 0540
Error : The value specified for DIM is invalid.
.PP
The value specified for DIM is larger than the rank of ARRAY or less
than 1.
.ME
$
$ Error : 0541
$msg  0541 Implementation is deferred for this Fortran statement, type, expression or constructor.
$nexp 0541
Error : Implementation is deferred for this Fortran statement, type, expression or constructor.
.PP
On IRIX machines, implementation for the following items is deferred:

   Cray character pointers

On Linux machines, implementation for the following items is deferred:

   Quad precision
.ME
$
$ Error : 0542
$msg  0542 The repeat factor must not be signed.
$nexp 0542
Error : The repeat factor must not be signed.
.PP
The \*CDATA\fR statement repeat factor (\fIdata_stmt_repeat\fR) must be an unsigned scalar
integer constant (\fIscalar-int-constant\fR).  The integer constant can be a literal
constant or a named constant; it cannot be signed.
.ME
$
$ Warning : 0543
$msg  0543 Kind type parameter value %d will be mapped to %d.
$nexp 0543
Warning : Kind type parameter value %d will be mapped to %d.
.PP
The specified kind type has been mapped to the new kind type, because the
compiler does not currently support the specified kind type.
.ME
$
$ Error : 0544
$msg  0544 The termination statement of a nonblock DO construct must be an executable statement.
$nexp 0544
Error : The termination statement of a nonblock DO construct must be an executable statement.
.PP
The termination statement of a nonblock \*CDO\fR construct must be an executable 
statement such as a \*CCONTINUE\fR or an assignment statement.  It must not be a 
nonexecutable statement such as a \*CDATA\fR or a \*CFORMAT\fR statement.
.ME
$
$ Internal : 0545
$msg  0545 Two operator nodes were marked IR_ARRAY_NODE in a reference tree.
$nexp 0545
Internal : Two operator nodes were marked IR_ARRAY_NODE in a reference tree.
.PP
Internal compiler error from make_base_subtree.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0546
$msg  0546 Nonarray used with subscript_opr in expr_semantics.
$nexp 0546
Internal : Nonarray used with subscript_opr in expr_semantics.
.PP
Internal compiler error from expr_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0547
$msg  0547 "%s" is a named constant and is also a common block name.  This is an extension to the Fortran standard.
$nexp 0547
Ansi : "%s" is a named constant and is also a common block name.  This is an extension to the Fortran standard.
.PP
The Fortran standard prohibits using the same name for a named 
constant and a common block name.
.ME
$
$ Error : 0548
$msg  0548 "%s" has been used as a variable, therefore it must not be used as a derived-type name.
$nexp 0548
Error : "%s" has been used as a variable, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict in uses of this object.  The object is used
as a variable, which prohibits it from being used as a derived-type name.
.ME
$
$ Error : 0549
$msg  0549 A %s statement is not allowed within a parallel region.
$nexp 0549
Error : A %s statement is not allowed within a parallel region.
.PP
This tasking implementation does not allow branches in or out of
a parallel region.  A parallel region is either a \*CDOALL\fR loop or a 
region of code delimited by a \*CPARALLEL\fR/\*CENDPARALLEL\fR pair.  A return
statement is not allowed within this kind of region as it is an
improper exit out of the region.  Also, an \*CENTRY\fR statement is not allowed
since it is an improper entry into the region.
.ME
$
$ Error : 0550
$msg  0550 "%s" has the %s attribute, therefore it must not be declared with the %s attribute (identifier first appeared at line %d)
$nexp 0550
Error : "%s" has the %s attribute, therefore it must not be declared with the %s attribute (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.  
This object must not have both of these attributes.
.ME
$
$ Error : 0551
$msg  0551 "%s" is a %s, therefore it must not be declared with the %s attribute (identifier first appeared at line %d)
$nexp 0551
Error : "%s" is a %s, therefore it must not be declared with the %s attribute (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.
This object must not be given the specified attribute.
.ME
$
$ Error : 0552
$msg  0552 "%s" has the %s attribute, therefore it must not be declared as a %s (identifier first appeared at line %d)
$nexp 0552
Error : "%s" has the %s attribute, therefore it must not be declared as a %s (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.  
Because the object has the given attribute, it must not be declared to be the
new item.
.ME
$
$ Error : 0553
$msg  0553 "%s" is a %s, therefore it must not be declared as a %s (identifier first appeared at line %d)
$nexp 0553
Error : "%s" is a %s, therefore it must not be declared as a %s (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.  
This object is already declared as the given item, therefore it must not be
declared to be the new item.
.ME
$
$ Error : 0554
$msg  0554 "%s" has the %s attribute.  It must not be given the %s attribute again (identifier first appeared at line %d)
$nexp 0554
Error : "%s" has the %s attribute.  It must not be given the %s attribute again (identifier first appeared at line %d)
.PP
An entity must not be explicitly given any attribute more than once in a 
scoping unit.
.ME
$
$ Internal : 0555
$msg  0555 Cannot write to the temporary message file.
$nexp 0555
Internal : Cannot write to the temporary message file.
.PP
The compiler can not write any (more) records to the temporary message file. 
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Log_Error : 0556
$msg  0556 Cannot open the temporary message file.
$nexp 0556
Log_Error : Cannot open the temporary message file.
.PP
The compiler cannot open the temporary message file.  This file is required to
buffer messages until the end of the compilation, at which time they are 
output in source line order.  Check the file permissions for the working
directory.
.ME
$
$ Error : 0557
$msg  0557 "%s" has been used as a variable, therefore it must not be declared or used as a procedure.
$nexp 0557
Error : "%s" has been used as a variable, therefore it must not be declared or used as a procedure.
.PP
Once an object is referenced or defined as a variable, it must not be 
redeclared as a procedure or referenced as a procedure.
.ME
$
$ Error : 0558
$msg  0558 "%s" has been used as a variable, therefore it must not be declared as a %s.
$nexp 0558
Error : "%s" has been used as a variable, therefore it must not be declared as a %s.
.PP
The object being declared is used as a variable, which prohibits it from
being declared as any of the following items:
.PP
.nf
	Cray pointer
	Cray pointee
	function result
	derived type
	generic interface
	namelist group
	statement function
	construct name
	function
	subroutine
.fi
.ME
$
$ Error : 0559
$msg  0559 "%s" has been used as a variable, therefore it must not be declared with the %s attribute.
$nexp 0559
Error : "%s" has been used as a variable, therefore it must not be declared with the %s attribute.
.PP
The object being declared is used as a variable, which prohibits
it from being given any of the following attributes:
.PP
.nf
	\*CDIMENSION\fR
	\*CALLOCATABLE\fR
	\*CPARAMETER\fR
	\*CINTRINSIC\fR
	\*CVFUNCTION\fR
	\*CNOSIDE EFFECTS\fR
.fi
.ME
$
$ Error : 0560
$msg  0560 "%s" is typed as variable length character, therefore it must not be declared with the %s attribute.
$nexp 0560
Error : "%s" is typed as variable length character, therefore it must not be declared with the %s attribute.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is typed as a variable length character entity, which prohibits
it from being given any of the following attributes:
.PP
.nf
	\*CAUXILIARY\fR
	\*CPARAMETER\fR
	\*CSAVE\fR
	\*CEXTERNAL\fR
	\*CINTRINSIC\fR
	\*CVFUNCTION\fR
	\*CNOSIDE EFFECTS\fR
.fi
.PP
An object typed as variable length character must not be given an explicit type
more than once.  It must not be equivalenced or data initialized.
.ME
$
$ Error : 0561
$msg  0561 "%s" is typed as variable length character, therefore it must not be declared as a %s.
$nexp 0561
Error : "%s" is typed as variable length character, therefore it must not be declared as a %s.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is typed as a variable length character entity, which prohibits
it from being declared as any of the following items:
.PP
.nf
	Cray pointee
	dummy argument
	derived type
	generic interface
	namelist group
	statement function
	construct name
	function
	subroutine
.fi
.ME
$
$ Error : 0562
$msg  0562 "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be declared with the %s attribute.
$nexp 0562
Error : "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be declared with the %s attribute.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is an explicit-shape array with nonconstant bounds, 
which prohibits it from being given any of the following attributes:
.PP
.nf
	\*CALLOCATABLE\fR
	\*CDIMENSION\fR
	\*CPARAMETER\fR
	\*CSAVE\fR
	\*CPOINTER\fR
	\*CEXTERNAL\fR
	\*CINTRINSIC\fR
	\*CVFUNCTION\fR
	\*CNOSIDE EFFECTS\fR
.fi
.PP
It must not be equivalenced or data initialized.
.ME
$
$ Error : 0563
$msg  0563 "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be declared as a %s.
$nexp 0563
Error : "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be declared as a %s.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is an explicit-shape array with nonconstant bounds, 
which prohibits it from being declared as any of the following items:
.PP
.nf
	Cray pointer
	Cray pointee
	derived type
	generic interface
	namelist group
	statement function
	construct name
	subroutine
	internal procedure
	module procedure
.fi
.ME
$
$ Error : 0564
$msg  0564 "%s" is in a common block, therefore it must not be declared with the %s attribute.
$nexp 0564
Error : "%s" is in a common block, therefore it must not be declared with the %s attribute.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is in a common block, which prohibits
it from being given any of the following attributes:
.PP
.nf
	\*CALLOCATABLE\fR
	\*CPARAMETER\fR
	\*CINTENT\fR
	\*COPTIONAL\fR
	\*CSAVE\fR
	\*CEXTERNAL\fR
	\*CINTRINSIC\fR
	\*CVFUNCTION\fR
	\*CNOSIDE EFFECTS\fR
.fi
.PP
It must not be typed as an assumed-length character or declared as an
assumed-size or assumed-shape array.
.ME
$
$ Error : 0565
$msg  0565 "%s" is in a common block, therefore it must not be declared as a %s.
$nexp 0565
Error : "%s" is in a common block, therefore it must not be declared as a %s.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is in a common block, which prohibits it from being
declared as any of the following items:
.PP
.nf
	Cray pointee
	function result
	dummy argument
	derived type
	generic interface
	namelist group
	statement function
	construct name
	function
	subroutine
.fi
.ME
$
$ Error : 0566
$msg  0566 "%s" is defined in an explicit interface, therefore it must not be declared with the %s attribute.
$nexp 0566
Error : "%s" is defined in an explicit interface, therefore it must not be declared with the %s attribute.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0567
$msg  0567 "%s" is defined in an explicit interface, therefore it must not be declared as a %s.
$nexp 0567
Error : "%s" is defined in an explicit interface, therefore it must not be declared as a %s.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0568
$msg  0568 "%s" is not a valid reference in a subroutine call.
$nexp 0568
Error : "%s" is not a valid reference in a subroutine call.
.PP
Only a subroutine can be referenced in a \*CCALL\fR statement.
.ME
$
$ Error : 0569
$msg  0569 Label variable "%s" must be a variable, not a named constant.
$nexp 0569
Error : Label variable "%s" must be a variable, not a named constant.
.PP
An \*CASSIGN\fR statement or an assigned \*CGO TO\fR statement has a named constant where
the label variable (\fIscalar_int_variable\fR) should appear.
.PP
The syntax of the \*CASSIGN\fR statement is:
.CS
  ASSIGN \fIlabel\*C TO \fIscalar_int_variable
.CE
.PP
The syntax of the assigned \*CGO TO\fR statement is:
.CS
  GO TO \fIscalar_int_variable\*C [ [,] (\fIlabel_list\*C) ]
.CE
.PP
The \fIscalar_int_variable\fR must be an unqualified name of a variable; that is, it
cannot be a structure component, array element, or substring designator.  The
label must be of type default integer, and it must be scalar.
.ME
$
$ Error : 0570
$msg  0570 "%s" has the ALLOCATABLE attribute, therefore it must be specified as a deferred-shape array.
$nexp 0570
Error : "%s" has the ALLOCATABLE attribute, therefore it must be specified as a deferred-shape array.
.PP
If an object is declared to be an allocatable object, it must also be declared 
to be a deferred-shape array.  
The following are two correct ways of declaring \*CA\fR to be allocatable.
.CS
    ALLOCATABLE :: A(:)

    REAL, ALLOCATABLE :: A
    DIMENSION A(:)
.CE
.ME
$
$ Error : 0571
$msg  0571 Function result "%s" is a deferred-shape array, therefore it must have the POINTER attribute.
$nexp 0571
Error : Function result "%s" is a deferred-shape array, therefore it must have the POINTER attribute.
.PP
A function result that is 
a deferred-shape array must have the \*CPOINTER\fR attribute.
Likewise, a function name that has the \*CPOINTER\fR attribute
and is an array must be declared with a \fIdeferred_shape_spec_list\fR.
.PP
Example:
.CS
    FUNCTION FCN()
    REAL, DIMENSION(:) :: FCN
    POINTER :: FCN
.CE               
.ME
$
$ Error : 0572
$msg  0572 "%s" has been used as a function, therefore it must not be declared with the %s attribute.
$nexp 0572
Error : "%s" has been used as a function, therefore it must not be declared with the %s attribute.
.PP
The object being declared has already been used as a function, so no further
declarations may be made for this object.
.ME
$
$ Error : 0573
$msg  0573 "%s" has been used as a function, therefore it must not be declared as a %s.
$nexp 0573
Error : "%s" has been used as a function, therefore it must not be declared as a %s.
.PP
The object being declared has already been used as a function, so no further
declarations may be made for this object.
.ME
$
$ Error : 0574
$msg  0574 "%s" has been used as a subroutine, therefore it must not be declared with the %s attribute.
$nexp 0574
Error : "%s" has been used as a subroutine, therefore it must not be declared with the %s attribute.
.PP
The object being declared has already been used as a subroutine, so no further
declarations may be made for this object.
.ME
$
$ Error : 0575
$msg  0575 "%s" has been used as a subroutine, therefore it must not be declared as a %s.
$nexp 0575
Error : "%s" has been used as a subroutine, therefore it must not be declared as a %s.
.PP
The object being declared has already been used as a subroutine, so no further
declarations may be made for this object.
.ME
$
$ Error : 0576
$msg  0576 "%s" has the %s attribute, therefore it must not be typed as variable length character.
$nexp 0576
Error : "%s" has the %s attribute, therefore it must not be typed as variable length character.
.PP
The object must not be typed as variable length character if the object 
has been typed in a previous type statement, initialized in a \*CDATA\fR 
statement or has the following attributes:  \*CPARAMETER, SAVE, POINTER,
VFUNCTION, AUXILIARY, NOSIDE EFFECTS, EXTERNAL \fRor \*CINTRINSIC\fR.
.ME
$
$ Error : 0577
$msg  0577 "%s" is a %s, therefore it must not be typed as variable length character.
$nexp 0577
Error : "%s" is a %s, therefore it must not be typed as variable length character.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be typed as variable length character
because it has been declared to be one of the following:
.PP
.nf
        Cray pointer
        Cray pointee
        module procedure
        derived type
        generic interface
        namelist group
        statement function
        construct
        module
        block data
        program
        subroutine
.fi
.ME
$
$ Error : 0578
$msg  0578 "%s" is in a common block, therefore it must not be typed as variable length character.
$nexp 0578
Error : "%s" is in a common block, therefore it must not be typed as variable length character.
.PP
The character length of an object in a common block must be known at
compile time.
.ME
$
$ Error : 0579
$msg  0579 "%s" is defined in an explicit interface.  All information about this procedure must be specified in the interface.
$nexp 0579
Error : "%s" is defined in an explicit interface.  All information about this procedure must be specified in the interface.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0580
$msg  0580 The data type of object "%s" is %s and is incompatible with data type %s in this PARAMETER assignment.
$nexp 0580
Error : The data type of object "%s" is %s and is incompatible with data type %s in this PARAMETER assignment.
.PP
The named constant becomes defined with the value determined from the 
initialization expression.  This must meet the rules of intrinsic
assignment as defined in the Fortran standard.  The type of the specified 
named constant and the type of the value do not meet the rules of intrinsic
assignment.
.ME
$
$ Error : 0581
$msg  0581 "%s" is a subroutine, therefore it must not be given an explicit type.
$nexp 0581
Error : "%s" is a subroutine, therefore it must not be given an explicit type.
.PP
This object is a subroutine, so it may not be given an explicit type.
.ME
$
$ Error : 0582
$msg  0582 "%s" has the %s attribute, therefore it must not be declared as an explicit-shape array with nonconstant bounds.
$nexp 0582
Error : "%s" has the %s attribute, therefore it must not be declared as an explicit-shape array with nonconstant bounds.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be declared as an explicit-shape array with nonconstant bounds
because it is equivalenced, data initialized, typed as an assumed-length
character and/or has one or more of the following attributes:
.PP
.nf
        \*CALLOCATABLE\fR
        \*CDIMENSION\fR
        \*CPARAMETER\fR
        \*CSAVE\fR
        \*CPRIVATE\fR
        \*CPUBLIC\fR
        \*CPOINTER\fR
        \*CEXTERNAL\fR
        \*CINTRINSIC\fR
        \*CVFUNCTION\fR
        \*CNOSIDE EFFECTS\fR
.fi
.ME
$
$ Error : 0583
$msg  0583 "%s" is a %s, therefore it must not be declared as an explicit-shape array with nonconstant bounds.
$nexp 0583
Error : "%s" is a %s, therefore it must not be declared as an explicit-shape array with nonconstant bounds.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be declared as an explicit-shape array with nonconstant bounds
because it has been declared to be one of the following:
.PP
.nf
        Cray pointer
        module procedure
        derived type
        generic interface
        namelist group
        statement function
        construct
        module
        block data
        program
.fi
.ME
$
$ Log_Error : 0584
$msg  0584 Machine characteristics system call "%s" failed.
$nexp 0584
Log_Error : Machine characteristics system call "%s" failed.
.PP
The call to the machine characteristics system call failed, because it was
given an invalid machine name.
.ME
$
$ Error : 0585
$msg  0585 "%s" is in a common block, therefore it must not be declared as an explicit-shape array with nonconstant bounds.
$nexp 0585
Error : "%s" is in a common block, therefore it must not be declared as an explicit-shape array with nonconstant bounds.
.PP
The length of an array in a common block must be known at compile time.
.ME
$
$ Warning : 0586
$msg  0586 The -dp option does not affect REAL(KIND=16) or COMPLEX(KIND=16).  These will remain double precision.
$nexp 0586
Warning : The -dp option does not affect REAL(KIND=16) or COMPLEX(KIND=16).  These will remain double precision.
.PP
\*CREAL(KIND=16)\fR and \*CCOMPLEX(KIND=16)\fR are not affected by the \*C-dp\fR command-line 
option.
.ME
$
$ Error : 0587
$msg  0587 The initialization expression must be a constant to be used with PARAMETER assignment for object "%s".
$nexp 0587
Error : The initialization expression must be a constant to be used with PARAMETER assignment for object "%s".
.PP
The Fortran standard requires the initialization expression to be a 
constant, if the type declaration statement has the \*CPARAMETER\fR attribute, or 
if the initialization expression is specified in a \*CPARAMETER\fR statement.
.ME
$
$ Error : 0588
$msg  0588 "%s" is a subroutine, therefore it must not be declared with the DIMENSION attribute.
$nexp 0588
Error : "%s" is a subroutine, therefore it must not be declared with the DIMENSION attribute.
.PP
A subroutine may not have the \*CDIMENSION\fR attribute.
.ME
$
$ Error : 0589
$msg  0589 "%s" has the %s attribute, therefore it must not be in a common block.
$nexp 0589
Error : "%s" has the %s attribute, therefore it must not be in a common block.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be in a common block because:
.PP
.BL
It is typed as \*CCHARACTER\fR*(*),
.BL
It is an assumed-size or assumed-shape array, or
.BL
It has one or more of the following attributes:
.nf
        \*CALLOCATABLE\fR
        \*CPARAMETER\fR
        \*CINTENT\fR
        \*COPTIONAL\fR
        \*CSAVE\fR
        \*CEXTERNAL\fR
        \*CINTRINSIC\fR
        \*CVFUNCTION\fR
        \*CNOSIDE EFFECTS\fR
.fi
.ME
$
$ Error : 0590
$msg  0590 "%s" is a %s, therefore it must not be in a common block.
$nexp 0590
Error : "%s" is a %s, therefore it must not be in a common block.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be in a common block because it has been declared
to be one of the following:
.PP
.nf
        Cray pointee
        function result
        dummy argument
        derived type
        generic interface
        namelist group
        statement function
        construct name
        procedure
        module
        block data
        program
.fi
.ME
$
$ Error : 0591
$msg  0591 "%s" is typed as variable length character, therefore it must not be in a common block.
$nexp 0591
Error : "%s" is typed as variable length character, therefore it must not be in a common block.
.PP
The length of a character variable in a common block must be known at compile
time.
.ME
$
$ Error : 0592
$msg  0592 "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be in a common block.
$nexp 0592
Error : "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be in a common block.
.PP
The length of an array in a common block must be known at compile time.
.ME
$
$ Error : 0593
$msg  0593 "%s" already appears in common block "%s".  It must only be specified once in a common block.
$nexp 0593
Error : "%s" already appears in common block "%s".  It must only be specified once in a common block.
.PP
A variable is only allowed to appear once in a common block and a variable
must only appear in one common block.  The compiler detected the same
variable specified more than once in a common block or the compiler 
detected the same variable in two different common blocks.
.ME
$
$ Error : 0594
$msg  0594 "%s" is a procedure name, therefore it must not be in a common block.
$nexp 0594
Error : "%s" is a procedure name, therefore it must not be in a common block.
.PP
Only variables are allowed in common blocks.
.ME
$
$ Error : 0595
$msg  0595 The %s attribute on the type declaration statement is not allowed in a %s program unit.
$nexp 0595
Error : The %s attribute on the type declaration statement is not allowed in a %s program unit.
.PP
Although the type declaration statement must be allowed in this program unit,
the specific attribute is not allowed in this program unit.  Following are
context restrictions for the different attributes:
.BL   
\*CALLOCATABLE\fR: Not allowed in a block data program unit.
.BL
\*CDIMENSION\fR: Allowed where a type declaration statement is allowed.
.BL
\*CEXTERNAL\fR: Not allowed in a block data program unit.
.BL
\*CINTENT\fR: Allowed only in subroutines, functions, and interface bodies.
.BL
\*CINTRINSIC\fR: Allowed where a type declaration statement is allowed.
.BL
\*COPTIONAL\fR: Allowed only in subroutines, functions, and interface bodies.
.BL
\*CPARAMETER\fR: Allowed where a type declaration statement is allowed.
.BL
\*CPOINTER\fR: Allowed where a type declaration statement is allowed.
.BL
\*CPRIVATE\fR: Allowed only in modules.
.BL
\*CPUBLIC\fR: Allowed only in modules.
.BL
\*CSAVE\fR: Allowed where a type declaration statement is allowed.
.BL
\*CTARGET\fR: Allowed where a type declaration statement is allowed.
.ME
$
$ Error : 0596
$msg  0596 The %s attribute must only be specified if the derived type statement is in the specification part of a module.
$nexp 0596
Error : The %s attribute must only be specified if the derived type statement is in the specification part of a module.
.PP
Although the derived type declaration statement can be allowed in this context,
the \*CPUBLIC\fR and \*CPRIVATE\fR attributes are only allowed if this derived type
declaration statement is in a module program unit.
.ME
$
$ Limit : 0597
$msg  0597 Compiler internal development command line option caused the compiler to abort on the first ANSI message.
$nexp 0597
Limit : Compiler internal development command line option caused the compiler to abort on the first ANSI message.
.PP
There is a development command-line option that causes the compiler to abort
after the first ANSI message.
.ME
$
$ Error : 0598
$msg  0598 "%s" must not have the PUBLIC attribute, because it is typed as private type "%s".
$nexp 0598
Error : "%s" must not have the PUBLIC attribute, because it is typed as private type "%s".
.PP
If an object is typed as a private type, it must not be given the \*CPUBLIC\fR
attribute, either by default or actual declaration.
.ME
$
$ Error : 0599
$msg  0599 "%s" has the %s attribute, therefore it must not be in a namelist group.
$nexp 0599
Error : "%s" has the %s attribute, therefore it must not be in a namelist group.
.PP
The object must not be in a namelist group because it is typed 
\*CCHARACTER\fR*(*), it is an assumed-size, assumed-shape or deferred-shape
array or it has one or more of the following attributes:
.PP
.nf
        \*CALLOCATABLE\fR
        \*CAUXILIARY\fR
        \*CPARAMETER\fR
        \*CPOINTER\fR
        \*CEXTERNAL\fR
        \*CINTRINSIC\fR
        \*CVFUNCTION\fR
        \*CNOSIDE EFFECTS\fR
.fi
.ME
$
$ Error : 0600
$msg  0600 "%s" is a %s, therefore it must not be in a namelist group.
$nexp 0600
Error : "%s" is a %s, therefore it must not be in a namelist group.
.PP
The object must not be in a namelist group because it is one of the following:
.PP
.nf
        Cray pointee
        derived type
        generic interface
        namelist group
        statement function
        construct
        module
        block data
        program
        function
        subroutine
.fi
.PP
An object in a namelist group must be a variable.
.ME
$
$ Error : 0601
$msg  0601 "%s" is typed as variable length character, therefore it must not be in a namelist group.
$nexp 0601
Error : "%s" is typed as variable length character, therefore it must not be in a namelist group.
.PP
The length of namelist group objects must be known at compile time.
.ME
$
$ Error : 0602
$msg  0602 "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be in a namelist group.
$nexp 0602
Error : "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be in a namelist group.
.PP
The length of namelist group objects must be known at compile time.
.ME
$
$ Error : 0603
$msg  0603 "%s" is a procedure name, therefore it must not be in a namelist group.
$nexp 0603
Error : "%s" is a procedure name, therefore it must not be in a namelist group.
.PP
All objects in a namelist group must be variables.
.ME
$
$ Log_Warning : 0604
$msg  0604 -%c %s is an unsupported compiler directive.
$nexp 0604
Log_Warning : -%c %s is an unsupported compiler directive.
.PP
The specified compiler directive is unsupported on this hardware or it is
deferred until a future release.
.ME
$
$ Error : 0605
$msg  0605 "%s" must be a constant to be used in an initialization expression.
$nexp 0605
Error : "%s" must be a constant to be used in an initialization expression.
.PP
To be used in an initialization expression, the object must be a constant.
The compiler detected one of the following:
.BL
The object is type character or an array with nonconstant bounds.
.BL
The object is in common, therefore it is a variable.
.BL
The object is a procedure.  It has an explicit interface and/or it is used
as a function or a subroutine.
.BL
The object has been used as a variable.
.ME
$
$ Internal : 0606
$msg  0606 Internal Error with I/O control list table.
$nexp 0606
Internal : Internal Error with I/O control list table.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0607
$msg  0607 Object "%s" is in auxiliary storage.  It must not be host associated.
$nexp 0607
Error : Object "%s" is in auxiliary storage.  It must not be host associated.
.PP
Objects in auxiliary storage must not be host associated.
Auxiliary storage is an extension to the Fortran standard.
.ME
$
$ Error : 0608
$msg  0608 "%s" has the %s attribute, therefore it must not be a procedure in an interface block.
$nexp 0608
Error : "%s" has the %s attribute, therefore it must not be a procedure in an interface block.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0609
$msg  0609 "%s" is a %s, therefore it must not be a function in an interface block.
$nexp 0609
Error : "%s" is a %s, therefore it must not be a function in an interface block.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0610
$msg  0610 "%s" is typed as variable length character, therefore it must not be a procedure in an interface block.
$nexp 0610
Error : "%s" is typed as variable length character, therefore it must not be a procedure in an interface block.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0611
$msg  0611 "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be a procedure in an interface block.
$nexp 0611
Error : "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be a procedure in an interface block.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Error : 0612
$msg  0612 "%s" is in a common block, therefore it must not be a procedure or be used as a procedure.
$nexp 0612
Error : "%s" is in a common block, therefore it must not be a procedure or be used as a procedure.
.PP
All objects in a common block are variables.  The compiler has detected an
attempt to use a variable as a procedure or to declare a variable as a
procedure.
.ME
$
$ Error : 0613
$msg  0613 "%s" is defined in an explicit interface.  It must not be defined with more than one explicit interface.
$nexp 0613
Error : "%s" is defined in an explicit interface.  It must not be defined with more than one explicit interface.
.PP
A procedure must only be defined in one explicit interface.  An explicit
interface is defined for an external procedure in an interface block.  An
explicit interface is defined for a module or internal procedure when
the procedure is defined.
.ME
$
$ Error : 0614
$msg  0614 The storage size needed for "%s" exceeds %d words, the maximum storage size available.
$nexp 0614
Error : The storage size needed for "%s" exceeds %d words, the maximum storage size available.
.PP
The storage needed for this item exceeds the memory size (in words) of this
architecture.
.ME
$
$ Error : 0615
$msg  0615 The storage size needed for this expression exceeds %d, the maximum storage size available.
$nexp 0615
Error : The storage size needed for this expression exceeds %d, the maximum storage size available.
.PP
The storage needed for this expression exceeds the memory size (in words) of this
architecture.  The expression could contain array constructors or be the result
of a function call.
.ME
$
$ Error : 0616
$msg  0616 "%s" has been used as a function, therefore it cannot be declared in an explicit interface block.
$nexp 0616
Error : "%s" has been used as a function, therefore it cannot be declared in an explicit interface block.
.PP
All definitions of a function must be before any uses of that function, with
the exception of internal functions.  They may be used before they are defined.
.ME
$
$ Error : 0617
$msg  0617 "%s" has been used as a subroutine, therefore it cannot be declared in an explicit interface block.
$nexp 0617
Error : "%s" has been used as a subroutine, therefore it cannot be declared in an explicit interface block.
.PP
All definitions of a subroutine must be before any uses of that subroutine, with
the exception of internal subroutines.  They may be used before they are
defined.
.ME
$
$ Error : 0618
$msg  0618 Precompiled procedure "%s" must have the same double precision (-ep/-dp) option specified as this compilation.
$nexp 0618
Error : Precompiled procedure "%s" must have the same double precision (-ep/-dp) option specified as this compilation.
.PP
If the current compilation unit is being compiled with the \*C-dp\fR option, 
each module it uses or precompiled procedure it attempts to inline must be
compiled with the \*C-dp\fR option.  If the current compilation unit is being 
compiled with the \*C-ep\fR option, each module it uses or precompiled
procedure it inlines must be compiled with the \*C-ep\fR option.
.ME
$
$ Error : 0619
$msg  0619 "%s" is a %s, therefore it must not be a subroutine in an interface block.
$nexp 0619
Error : "%s" is a %s, therefore it must not be a subroutine in an interface block.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.
.ME
$
$ Warning : 0620
$msg  0620 Dummy argument "%s" is not an auxiliary array but this actual argument is.
$nexp 0620
Warning : Dummy argument "%s" is not an auxiliary array but this actual argument is.
.PP
When an actual argument is an auxiliary array, the address passed to 
the subprogram will be an auxiliary storage address.  If the associated
dummy argument is not an auxilary array, the address will be interpreted 
incorrectly.

Auxiliary arrays are an extension to the Fortran standard.
.ME
$
$ Error : 0621
$msg  0621 The kind parameter "%s" is not valid.  It must be a scalar integer constant.
$nexp 0621
Error : The kind parameter "%s" is not valid.  It must be a scalar integer constant.
.PP
The syntax for a kind parameter is \fI _kind-param\fR
.PP
\fIkind_param\fR is  \fIdigit_string\fR or \fIscalar_int_constant_name\fR
.PP
Examples of valid kind parameters are:
.nf
 4
 8
 \*CINTEGER, PARAMETER :: KIND_PARM=4\fR 
.fi
.ME
$
$ Error : 0622
$msg  0622 Dummy argument "%s" has the TARGET attribute.  It requires an actual argument with the TARGET or POINTER attribute.
$nexp 0622
Error : Dummy argument "%s" has the TARGET attribute.  It requires an actual argument with the TARGET or POINTER attribute.
.PP
A dummy argument that has the \*CTARGET\fR attribute can only be associated with
an actual argument that has either the \*CTARGET\fR attribute or the \*CPOINTER\fR
attribute.
.ME
$
$ Warning : 0623
$msg  0623 Default integer kind size for precompiled procedure "%s" does not match the default integer kind size for this compilation.
$nexp 0623
Error : Default integer kind size for precompiled procedure "%s" does not match the default integer kind size for this compilation.
.PP
A module was compiled with a different default integer kind size than a
program unit which contains a "use" statement for that module. Thus, for
example, if the program unit calls a subroutine in the module and passes
an actual argument of type "integer" to a formal argument of type "integer",
a compilation error will result. You can avoid the problem by using specific
kind sizes such as "integer*4" or "integer(kind=8)"
.PP
$ For modules, both the module and the using compilation unit must be compiled 
$ with the same default integer kind type.  They both must be compiled with the 
$ same \*C-i\fR command-line option or the same \*C!DIR$ INTEGER=\fR option. 
$ Following are some examples.
$ .nf
$  module          compilation unit
$  default         using the module\*C
$  -i64             -i64            \fR! Legal\*C
$  -i32             -i64            \fR! Illegal\*C
$  !DIR INTEGER=64  -i32            \fR! Illegal\*C
$  !DIR INTEGER=64  !DIR INTEGER=64 \fR! Legal
$ .fi
$ 
$ The same goes for precompiled inlinable procedures.  Both the caller and 
$ callee must be compiled the same.
.ME
$
$ Internal : 0624
$msg  0624 Bad left operand to ptr_assign_from_target.
$nexp 0624
Internal : Bad left operand to ptr_assign_from_target.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0625
$msg  0625 "%s" is a %s.  To be a Cray character pointee, it must be declared %s prior to the POINTER statement.
$nexp 0625
Error : "%s" is a %s.  To be a Cray character pointee, it must be declared %s prior to the POINTER statement.
.PP
When declaring a Cray character pointer, the type of the pointee must be
declared  \*CCHARACTER*(*)\fR before the \*CPOINTER\fR statement, as in the following examples.
.CS
  CHARACTER*(*)  EE
  POINTER(PTR, EE)   \fR! legal\*C

  POINTER(PTR, EE)
  CHARACTER*(*)  EE  \fR! illegal\*C
\fR
.ME
$
$ Internal : 0626
$msg  0626 Expected %s in %s.
$nexp 0626
Internal : Expected %s in %s.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Warning : 0627
$msg  0627 Dummy argument "%s" is an auxiliary array and the actual argument is not.
$nexp 0627
Warning : Dummy argument "%s" is an auxiliary array and the actual argument is not.
.PP
When an interface to a subprogram is known and a dummy argument is
an auxiliary array, the subprogram expects that the address it
receives will be an auxiliary storage address.  This will not be 
the case when the actual argument associated with the auxiliary
array dummy argument is an expression, an array that is not auxiliary,
or an array section.  An array section of an auxiliary array is still
invalid because the section is copied into a temporary array that
will not be in auxiliary storage.

Auxiliary storage is an extension to the Fortran standard.
.ME
$
$ Error : 0628
$msg  0628 "%s" has the %s attribute, therefore it must not be used as an external function name.
$nexp 0628
Error : "%s" has the %s attribute, therefore it must not be used as an external function name.
.PP
The compiler detected a conflict between a declaration and a use of this
object.  The object must not be used as an external function name because 
it is typed as assumed-length character, it is an assumed-size or assumed-shape
array, it is equivalenced or data initialialized or it has one or more of
the following attributes:
.PP
.nf
        \*CALLOCATABLE\fR
        \*CAUXILIARY\fR
        \*CPARAMETER\fR
        \*CINTENT\fR
        \*CTARGET\fR
        \*CSAVE\fR
        \*CPOINTER\fR
        \*CINTRINSIC\fR
.fi
.ME
$
$ Error : 0629
$msg  0629 "%s" is a %s, therefore it must not be used as an external function name.
$nexp 0629
Error : "%s" is a %s, therefore it must not be used as an external function name.
.PP
The compiler detected a conflict in a declaration and a use of this object.
The object must not be used as an external function name because it has been
declared to be one of the following:
.PP
.nf
        Cray pointer
        Cray pointee
        function result
        derived type
        namelist group
        statement function
        construct
        variable
        module
        block data
        program
        subroutine
        internal procedure
.fi
.ME
$
$ Internal : 0630
$msg  0630 Non constant character in namelist_static_dv_whole_def.
$nexp 0630
Internal : Non constant character in namelist_static_dv_whole_def.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Log_Error : 0631
$msg  0631 This compiler is not licensed on this hardware.  Please contact craysoft.
$nexp 0631
Log_Error : This compiler is not licensed on this hardware.  Please contact craysoft.
.PP
A license is needed to run this compiler on this hardware.
.ME
$
$ Error : 0632
$msg  0632 "%s" has been used as a subroutine, therefore it must not be used as a function.
$nexp 0632
Error : "%s" has been used as a subroutine, therefore it must not be used as a function.
.PP
The object is a subroutine, so it must not be used as a function.
.ME
$
$ Error : 0633
$msg  0633 "%s" has the %s attribute, therefore it must not be used as a subroutine name in a CALL statement.
$nexp 0633
Error : "%s" has the %s attribute, therefore it must not be used as a subroutine name in a CALL statement.
.PP
The only attributes that a subroutine can have are:
.PP
.nf
        \*COPTIONAL\fR
        \*CPUBLIC\fR
        \*CPRIVATE\fR
        \*CEXTERNAL\fR
        \*CINTRINSIC\fR
        \*CNOSIDE EFFECTS\fR
.fi
.ME
$
$ Error : 0634
$msg  0634 "%s" is a %s, therefore it must not be used as an external subroutine name in a CALL statement.
$nexp 0634
Error : "%s" is a %s, therefore it must not be used as an external subroutine name in a CALL statement.
.PP
The compiler detected a conflict between a declaration and a use of this
object.  The object must not be used as an external subroutine name in a
\*CCALL\fR statement because it has been declared to be one of the following:
.PP
.nf
        Cray pointer
        Cray pointee
        function result
        derived type
        namelist group
        statement function
        construct
        variable
        module
        block data
        program
        function
.fi
.ME
$
$ Error : 0635
$msg  0635 "%s" is typed as character, therefore it must not be used as a subroutine.
$nexp 0635
Error : "%s" is typed as character, therefore it must not be used as a subroutine.
.PP
A subroutine may not have an explicit type.
.ME
$
$ Error : 0636
$msg  0636 "%s" has the DIMENSION attribute, therefore it must not be used as a subroutine.
$nexp 0636
Error : "%s" has the DIMENSION attribute, therefore it must not be used as a subroutine.
.PP
A subroutine cannot have the \*CDIMENSION\fR attribute.
.ME
$
$ Internal : 0637
$msg  0637 Something other than list opnd in io_list_semantics.
$nexp 0637
Internal : Something other than list opnd in io_list_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0638
$msg  0638 Cray character pointee "%s" must be an assumed-length character variable.
$nexp 0638
Error : Cray character pointee "%s" must be an assumed-length character variable.
.PP
To be a Cray character pointee, the pointee must be declared \*CCHARACTER*(*)\fR, as
in the following examples:
.CS
     CHARACTER*(*)  EE
     POINTER(PT, EE)    \fR! legal\*C

     CHARACTER*(I)  EE
     POINTER(PT,EE)     \fR! illegal\*C

     CHARACTER*(6)  EE
     POINTER(PT,EE)     \fR! illegal
.CE
.PP
The Cray pointer data type is an extension to the Fortran standard.
.ME
$
$ Error : 0639
$msg  0639 "%s" is used as a function, therefore it must not be used as a subroutine.
$nexp 0639
Error : "%s" is used as a function, therefore it must not be used as a subroutine.
.PP
A function must not be referenced as if it is a subroutine.
.ME
$
$ Error : 0640
$msg  0640 This actual argument must not be scalar.
$nexp 0640
Error : This actual argument must not be scalar.
.PP
This particular argument must not be a scalar entity.
.ME
$
$ Error : 0641
$msg  0641 "%s" is a %s, therefore it must not be used in an expression.
$nexp 0641
Error : "%s" is a %s, therefore it must not be used in an expression.
.PP
The compiler detected a conflict between a declaration and a use of this
name.  The name must not be used in an expression because it is a
derived-type name, a namelist group name, a construct name, a module name,
a block data program unit name or a main program name.
.ME
$
$ Error : 0642
$msg  0642 "%s" is already a %s, therefore it must not be declared a %s.
$nexp 0642
Error : "%s" is already a %s, therefore it must not be declared a %s.
.PP
A Cray pointer cannot also be a Cray character pointer.
A Cray character pointer cannot also be a Cray pointer.
The Cray pointer and character pointer data types are extensions to
the Fortran standard.
.ME
$
$ Error : 0643
$msg  0643 "%s" has been used as a subroutine, therefore it must not be referenced in an expression.
$nexp 0643
Error : "%s" has been used as a subroutine, therefore it must not be referenced in an expression.
.PP
A subroutine can only be used in a \*CCALL\fR statement.
.ME
$
$ Error : 0644
$msg  0644 "%s" has the %s attribute, therefore it must not be used as a derived-type name.
$nexp 0644
Error : "%s" has the %s attribute, therefore it must not be used as a derived-type name.
.PP
This object must be a derived-type to be used as a derived-type.
The only attributes that a derived-type name can have are \*CPUBLIC\fR or
\*CPRIVATE\fR.
.ME
$
$ Error : 0645
$msg  0645 "%s" is a %s, therefore it must not be used as a derived-type name.
$nexp 0645
Error : "%s" is a %s, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict between a declaration and a use of this
object.  The object must not be used as a derived-type name it is not a
derived-type name.
.ME
$
$ Error : 0646
$msg  0646 "%s" is typed as character, therefore it must not be used as a derived-type name.
$nexp 0646
Error : "%s" is typed as character, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict between a declaration for this object and a
use of the object.  The object used is typed as character,
which prohibits it from being used as a derived-type name.
.ME
$
$ Error : 0647
$msg  0647 "%s" has the DIMENSION attribute, therefore it must not be used as a derived-type name.
$nexp 0647
Error : "%s" has the DIMENSION attribute, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict in declarations for this object.
The only attributes that a derived-type name can have are \*CPUBLIC\fR or
\*CPRIVATE\fR.
.ME
$
$ Error : 0648
$msg  0648 "%s" is in a common block which makes it a variable, therefore it must not be used as a derived-type name.
$nexp 0648
Error : "%s" is in a common block which makes it a variable, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict between a declaration and a use of this
object.  The object is a variable, because it is in a common block.  A variable
cannot be used as a derived-type name.
.ME
$
$ Error : 0649
$msg  0649 "%s" is a procedure, therefore it must not be used as a derived-type name.
$nexp 0649
Error : "%s" is a procedure, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict between a declaration and a use of this 
object.  The object is a procedure, so it must not be used as a derived-type
name.
.ME
$
$ Error : 0650
$msg  0650 "%s" is a Cray pointee.  It must not be typed as a derived type.
$nexp 0650
Error : "%s" is a Cray pointee.  It must not be typed as a derived type.
.PP
A Cray pointee must not be a derived type.
The Cray pointer data type (and its associated pointee) is an extension to the Fortran standard.
.ME
$
$ Error : 0651
$msg  0651 "%s" is typed as a derived type, therefore it must not be declared as a Cray pointee.
$nexp 0651
Error : "%s" is typed as a derived type, therefore it must not be declared as a Cray pointee.
.PP
A Cray pointee must not be a derived type.
The Cray pointer data type (and its associated pointee) is an extension to the Fortran standard.
.ME
$
$ Error : 0652
$msg  0652 "%s" has been used as a function, therefore it must not be used as a derived-type name.
$nexp 0652
Error : "%s" has been used as a function, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict between uses of this object. 
The object being declared is used as a function, which prohibits it from
being used as a derived-type name.
.ME
$
$ Error : 0653
$msg  0653 "%s" has been used as a subroutine, therefore it must not be used as a derived-type name.
$nexp 0653
Error : "%s" has been used as a subroutine, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict in uses of this object.  The
object being declared is used as a subroutine, which prohibits
it from being used as a derived-type name.
.ME
$
$ Error : 0654
$msg  0654 This actual argument does not have a legal rank for this intrinsic procedure.
$nexp 0654
Error : This actual argument does not have a legal rank for this intrinsic procedure.
.PP
This actual argument does not have a legal rank for the
intrinsic procedure in question.
.ME
$
$ Internal : 0655
$msg  0655 fnd_semantic_err is detecting error(s) that the calling routine, %s, is not.
$nexp 0655
Internal : fnd_semantic_err is detecting error(s) that the calling routine, %s, is not.
.PP
Many routines do their own error checking and only call fnd_semantic_err
when they have a problem.  If something gets changed in the semantic tables,
the calling routines need to be changed as well.  The problem can be found
by checking the error previous to this internal error.  That is the error
that the calling routine needs to detect.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0656
$msg  0656 A PUBLIC/PRIVATE statement with no access list must only be specified once in the scoping unit of module "%s".
$nexp 0656
Error : A PUBLIC/PRIVATE statement with no access list must only be specified once in the scoping unit of module "%s".
.PP
Multiple \*CPRIVATE\fR and \*CPUBLIC\fR statements without an \fIaccess_id_list\fR are illegal.
The compiler detected something like the following example:
.CS
   MODULE A
   PUBLIC
   PRIVATE  \fR!  Illegal - \*CPUBLIC\fR is already specified
.CE
.ME
$
$ Error : 0657
$msg  0657 Function result "%s" cannot be in a namelist group, because it is not the result of an active function.
$nexp 0657
Error : Function result "%s" cannot be in a namelist group, because it is not the result of an active function.
.PP
A function result is allowed in a namelist group if it is in the containing
scope of the namelist statement, as in this example:
.CS
 MODULE ABC
 CONTAINS
   FUNCTION XYZ()
     NAMELIST /GRP/ XYZ, RST  \fR! \*CRST\fR is illegal\*C
   END FUNCTION

   FUNCTION RST()
   END FUNCTION
 END MODULE
.CE
.PP
\*CRST\fR is illegal in the \*CNAMELIST\fR statement, because the \*CNAMELIST\fR statement is
not in the scope of \*CRST\fR.  \*CXYZ\fR is a legal namelist group member.
.ME
$
$ Error : 0658
$msg  0658 "%s" must be an integer constant or the DO variable of a containing implied-DO.
$nexp 0658
Error : "%s" must be an integer constant or the DO variable of a containing implied-DO.
.PP
Each operand of the start, end, or increment expression of a \*CDATA\fR implied-\*CDO\fR
must be an integer constant (literal or named), or it must be a \*CDO\fR variable
of a containing implied-\*CDO\fR.
.ME
$
$ Error : 0659
$msg  0659 All dummy arguments used in the length expression for object "%s" must be specified at the same entry point.
$nexp 0659
Error : All dummy arguments used in the length expression for object "%s" must be specified at the same entry point.
.PP
If a variable length character declaration uses dummy arguments to determine the length
expression, all the dummy arguments must be specified at the same entry
point.  The compiler detected a length expression, where one dummy
argument is at one entry point and another dummy argument used in the same 
length expression is not at the same entry point.
The following example demonstrates this:
.CS
   SUBROUTINE SUBCHAR(IDX1)
   CHARACTER*(IDX1 + IDX2)  SUN_CHAR
   ...
   ENTRY SUBLATER(IDX2)
   ...
   END SUBROUTINE
.CE
.PP
This program would receive an error for the length expression for \*CSUN_CHAR\fR.
\*CIDX1\fR and \*CIDX2\fR have to be specified together in at least one entry point to
make this program legal.
.ME
$
$ Error : 0660
$msg  0660 All dummy arguments used in the bounds expressions for array "%s" must be specified at the same entry point.
$nexp 0660
Error : All dummy arguments used in the bounds expressions for array "%s" must be specified at the same entry point.
.PP
If a variable length array declaration uses dummy arguments to determine any of its
bounds, all the dummy arguments must be specified at the same entry
point.  The compiler detected an array declaration where one dummy
argument is at one entry point and another dummy argument used in a
bound expression for the same array declaration is not at the same
entry point.  The following example demonstrates this:
.CS
   SUBROUTINE SUBDIM(IDX1)
   REAL, DIMENSION (IDX1,IDX2) ::  AN_ARRAY
   ...
   ENTRY SUBLATER(IDX2)
   ...
   END SUBROUTINE
.CE
.PP
This program would get an error for the declaration of \*CAN_ARRAY\fR.
\*CIDX1\fR and \*CIDX2\fR have to be specified together in at least one entry point to make
this program legal.
.ME
$
$ Error : 0661
$msg  0661 All dummy arguments used in specification expressions to declare "%s" must be specified at the same entry point.
$nexp 0661
Error : All dummy arguments used in specification expressions to declare "%s" must be specified at the same entry point.
.PP
The compiler detected a character array declaration, with dummy arguments used in 
specification expressions to declare character length and array bounds.
All dummy arguments used in specification expressions for the declaration
of this object must be specified in at least one common entry point.
The following example demonstrates this:
.CS
   SUBROUTINE SUBCHAR(IDX1)
   CHARACTER*(IDX1)  CHAR_ARRAY(IDX2)
   ...
   ENTRY SUBLATER(IDX2)
   ...
   END SUBROUTINE
.CE
.PP
This program would get an error for the \*CCHAR_ARRAY\fR declaration.
\*CIDX1\fR and \*CIDX2\fR have to be specified together in at least one entry point to
make this program legal.
.ME
$
$ Error : 0662
$msg  0662 All dummy arguments used in expressions to declare "%s" must be specified at the same entry point as the object.
$nexp 0662
Error : All dummy arguments used in expressions to declare "%s" must be specified at the same entry point as the object.
.PP
The compiler detected a dummy argument declaration, with dummy arguments used in 
specification expressions to declare character length and/or array bounds.
All dummy arguments used in specification expressions for the declaration of
this object must be specified in the same entry point as the dummy argument.
The following example demonstrates this:
.CS
   SUBROUTINE SUBCHAR(IDX1, CHAR_ARRAY)
   CHARACTER*(IDX1)  CHAR_ARRAY(IDX2)
   ...
   ENTRY SUBLATER(IDX2)
   ...
   END SUBROUTINE
.CE
.PP
This program would get an error for \*CCHAR_ARRAY\fR declaration.  \*CIDX1\fR, \*CIDX2\fR, and
\*CCHAR_ARRAY\fR must be specified together in at least one entry point to make
this program legal.
.ME
$
$ Error : 0663
$msg  0663 "%s" belongs to common block "%s" that is in auxiliary storage so it must not be a namelist group object.
$nexp 0663
Error : "%s" belongs to common block "%s" that is in auxiliary storage so it must not be a namelist group object.
.PP
Namelist group objects must not be in auxiliary storage.  

Auxiliary storage is an extension to the Fortran standard.
.ME
$
$ Internal : 0664
$msg  0664 Expression semantics missed detection of an error for a constant specification expression.
$nexp 0664
Internal : Expression semantics missed detection of an error for a constant specification expression.
.PP
If the statement type is component declaration statement, the expression parser
should catch all objects in the expression that are not constant expressions.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0665
$msg  0665 Unexpected basic type from create_dv_type_code.
$nexp 0665
Internal : Unexpected basic type from create_dv_type_code.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0666
$msg  0666 "%s" has been used as a variable or a function in the character length, therefore it must not be the function name.
$nexp 0666
Error : "%s" has been used as a variable or a function in the character length, therefore it must not be the function name.
.PP
The compiler detected the following:
.CS 
    CHARACTER*(IFUN)  FUNCTION IFUN()
.CE
.PP
or
.CS
    CHARACTER*(IFUN(1))  FUNCTION IFUN(I)
.CE
.PP
These are both illegal.
.ME
$
$ Error : 0667
$msg  0667 The number of entities to be initialized exceeds the number of values.
$nexp 0667
Error : The number of entities to be initialized exceeds the number of values.
.PP
The \*CDATA\fR statement is specifying more entities to be initialized than there are
values available in the value list.  The \*CDATA\fR statement has the following form:
.CS
  DATA \fIdata_stmt_set\*C [ [,] \fIdata_stmt_set\*C ]
.CE
.PP
where each \fIdata_stmt_set\fR consists of  
.CS
  \fIdata_stmt_object_list \*C/\fIdata_stmt_value_list\*C/
.CE
.PP
The \fIdata_stmt_object_list\fR is expanded to form a sequence of scalar variables
and the \fIdata_stmt_value_list\fR is expanded to form a sequence of scalar constant
values.  The number of entities in the expanded \fIdata_stmt_object_list\fR must be
the same as the number of constant values in the expanded \fIdata_stmt_value_list\fR.
.ME
$
$ Error : 0668
$msg  0668 The number of values exceeds the number of entities to be initialized.
$nexp 0668
Error : The number of values exceeds the number of entities to be initialized.
.PP
The \*CDATA\fR statement is specifying more values in the value list than there are
entities to be initialized.  The \*CDATA\fR statement has the following form:
.CS
  DATA \fIdata_stmt_set\*C [ [,] \fIdata_stmt_set\*C ]
.CE
.PP
where each \fIdata_stmt_set\fR consists of
.CS
  \fIdata_stmt_object_list \*C/\fIdata_stmt_value_list\*C/
.CE
.PP
The \fIdata_stmt_object_list\fR is expanded to form a sequence of scalar variables
and the \fIdata_stmt_value_list\fR is expanded to form a sequence of scalar constant
values.  The number of entities in the expanded \fIdata_stmt_object_list\fR must be
the same as the number of constant values in the expanded \fIdata_stmt_value_list\fR.
.ME
$
$ Error : 0669
$msg  0669 The matching DO statement has a construct name, therefore this statement must be an END DO with the same construct name.
$nexp 0669
Error : The matching DO statement has a construct name, therefore this statement must be an END DO with the same construct name.
.PP
If the \*CDO\fR statement of a block \*CDO\fR construct is identified by a construct name,
the \*CDO\fR construct's termination statement must be an \*CEND DO\fR statement and the 
\*CEND DO\fR must specify the same construct name.
.ME
$
$ Internal : 0670
$msg  0670 Number of list items is greater than list count value.
$nexp 0670
Internal : Number of list items is greater than list count value.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0671
$msg  0671 Procedure "%s" is already in interface block "%s".  It must not be specified multiple times.
$nexp 0671
Error : Procedure "%s" is already in interface block "%s".  It must not be specified multiple times.
.PP
A procedure must not be specified in the same interface block
multiple times.  Following are examples using module procedures:
.CS   
   PROGRAM TEST1
    USE FOOS
    INTERFACE INT_1
      MODULE PROCEDURE FOO,FOO ! FOO is illegal
      MODULE PROCEDURE FOO1
      MODULE PROCEDURE FOO1    ! FOO1 is illegal
    END INTERFACE
          
    INTERFACE INT_2
      MODULE PROCEDURE FOO2B
    END INTERFACE
          
    INTERFACE INT_2
      MODULE PROCEDURE FOO2b   ! FOO2B is illegal
    END INTERFACE
    END
.CE 
.PP
However, the following is legal for module procedures:
.CS   
    MODULE TEST2
    USE FOOS
    INTERFACE INT_2
      MODULE PROCEDURE FOO2B
    END INTERFACE
    END MODULE
   
    MODULE TEST3
    USE FOOS
    INTERFACE INT_2
      MODULE PROCEDURE FOO2B
    END INTERFACE
    END MODULE
   
    PROGRAM TEST4
    USE TEST2
    USE TEST3   ! This is legal, because
                ! FOO2B is coming in from
                ! two separate modules
    END
.CE
.ME
$
$ Error : 0672
$msg  0672 "%s" has been used as a function, therefore it must not be declared an explicit-shape array with nonconstant bounds.
$nexp 0672
Error : "%s" has been used as a function, therefore it must not be declared an explicit-shape array with nonconstant bounds.
.PP
The object being declared is used as a function, which prohibits
it from being declared as an explicit-shape array with nonconstant bounds.
All declarations must precede all uses of an entity.
.ME
$
$ Error : 0673
$msg  0673 The dimension attributes for entry points "%s" and "%s" conflict.
$nexp 0673
Error : The dimension attributes for entry points "%s" and "%s" conflict.
.PP
If the result of any entry point of a function with one or more \*CENTRY\fR 
statements has the \*CDIMENSION\fR attribute, then all entry points in that function
must return a result with the same \*CDIMENSION\fR attribute.  If the function is
array-valued, all entry points must return results of the same rank, and 
if the function is not assumed-shape, the shape of all entry point results must
agree. 
.ME
$
$ Error : 0674
$msg  0674 Entry points "%s" and "%s" must both have the POINTER attribute.
$nexp 0674
Error : Entry points "%s" and "%s" must both have the POINTER attribute.
.PP
If the result of any entry point of a function with one or more \*CENTRY\fR 
statements has the \*CPOINTER\fR attribute, then all entry points in that function 
must return a result with the \*CPOINTER\fR attribute.
.ME
$
$ Error : 0675
$msg  0675 An implied-DO variable must be the name of a variable of type integer.
$nexp 0675
Error : An implied-DO variable must be the name of a variable of type integer.
.PP
An implied-\*CDO\fR list in a \*CDATA\fR statement or in an array constructor contains an
implied-\*CDO\fR loop control variable that is not a variable of type integer.
.PP
The \*CDATA\fR statement implied DO has the form:
.CS
   (\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C =
        \fIscalar_int_expr\*C, \fIscalar_int_expr\*C 
	[, \fIscalar_int_expr\*C])
.CE
.PP
The \fIdata_i_do_variable\fR must be the name of an integer variable.
.PP
The array constructor implied-\*CDO\fR has the form:
.CS 
   (\fIac_value_list\*C, \fIac_do_variable\*C =
        \fI scalar_int_expr\*C, \fIscalar_int_expr\*C 
	[, \fIscalar_int_expr\*C])
.CE
.PP
The \fIac_do_variable\fR must be the name of an integer variable.
.PP
A correction to the Fortran standard as a response to an interpretation 
request expands on the rules for implied-\*CDO\fR loop control variables that are
statement entities (the I/O implied-\*CDO\fR variable is not a statement entity).
Essentially, it states that a statement entity can have the same name as a 
common block name or an integer scalar variable in the scoping unit containing
the \*CDATA\fR statement or array constructor.  Therefore, a
statement entity cannot have the same name as an external procedure, an
internal procedure, a module procedure, a named constant, a construct name,
a generic name, a derived type name, and so on.  Also, because it must be type
integer, it cannot have the same name as an entity declared to be of a type
other than integer.
.PP
The interpretation response also states that the implied-\*CDO\fR variable must be
the name of a scalar variable, but this Fortran compiler extends the
standard by allowing the \fIdata_i_do_variable\fR or \fIac_do_variable\fR to have the same
name as an integer array.
.ME
$
$ Error : 0676
$msg  0676 An identifier in a DATA value list must be the name of a previously declared named constant.
$nexp 0676
Error : An identifier in a DATA value list must be the name of a previously declared named constant.
.PP
A value in the value list of a data statement has the form:
.CS
  [\fIdata_stmt_repeat\*C *] \fIdata_stmt_constant
.CE
.PP
\fRIf the repeat factor or constant is an identifier, it must be the name of a
named constant and the named constant must have been declared previously in 
the scoping unit or made accessible by use or by host association.
.ME
$
$ Error : 0677
$msg  0677 If the repeat factor is an identifier, it must be the name of a scalar named constant.
$nexp 0677
Error : If the repeat factor is an identifier, it must be the name of a scalar named constant.
.PP
A value in the value list of a \*CDATA\fR statement may be preceded by a repeat 
factor as in:
.CS 
   [\fIdata_stmt_repeat\*C *] \fIdata_stmt_constant
.CE
.PP   
\fRIf the \*CDATA\fR statement repeat factor is an identifier, it must be the name of a
named constant and the named constant must represent a scalar value.
.ME
$
$ Error : 0678
$msg  0678 A DATA statement repeat factor must be type integer and be a scalar constant.
$nexp 0678
Error : A DATA statement repeat factor must be type integer and be a scalar constant.
.PP
A value in the value list of a \*CDATA\fR statement may be preceded by a repeat 
factor as in:
.CS   
  [\fIdata_stmt_repeat\*C *] \fIdata_stmt_constant
.CE
.PP   
The \*CDATA\fR statement repeat factor must be type integer.  It must be a 
scalar constant.
.ME
$
$ Error : 0679
$msg  0679 The value of a DATA statement repeat factor must be equal to or greater than zero.
$nexp 0679
Error : The value of a DATA statement repeat factor must be equal to or greater than zero.
.PP
A value in the value list of a \*CDATA\fR statement may be preceded by a repeat 
factor as in:
.CS   
     [\fIdata_stmt_repeat\*C *] \fIdata_stmt_constant
.CE
.PP   
If the \*CDATA\fR statement repeat factor is an identifier, it must be the name of a
named constant and the named constant must represent a value that is equal to 
or greater than zero.
.ME
$
$ Error : 0680
$msg  0680 More than one IF condition is specified for %s tasking directive.
$nexp 0680
Error : More than one IF condition is specified for %s tasking directive.
.PP
The \*CIF\fR condition parameter for \*CDOALL\fR and \*CPARALLEL\fR compiler tasking directives
can only be specified once. 
.ME
$
$ Error : 0681
$msg  0681 The specifier for number of characters in this %s statement must be of type integer.
$nexp 0681
Error : The specifier for number of characters in this %s statement must be of type integer.
.PP
An \*CENCODE\fR or \*CDECODE\fR statement is specifying a noninteger value for number of
characters.  In the following statements, \fIn\fR, the number of characters, must
be a nonzero integer expression less than or equal to 152:
.CS
   ENCODE (n,f,dent) [elist]
   DECODE (n,f,sent) [dlist]
.CE
.ME
$
$ Error : 0682
$msg  0682 The specifier for number of characters in this %s statement must be in the range 1 to 152.
$nexp 0682
Error : The specifier for number of characters in this %s statement must be in the range 1 to 152.
.PP
An \*CENCODE\fR or \*CDECODE\fR statement is specifying a value for number of characters that
is not in the range 1 to 152.  In the following statements, \fIn\fR, the number of
characters, must be a nonzero integer expression less than or equal to 152:
.CS
   ENCODE (n,f,dent) [elist]
   DECODE (n,f,sent) [dlist]
.CE
.ME
$
$ Error : 0683
$msg  0683 The specifier for number of characters in this %s statement must be a scalar integer expression.
$nexp 0683
Error : The specifier for number of characters in this %s statement must be a scalar integer expression.
.PP
An \*CENCODE\fR or \*CDECODE\fR statement is specifying a value for number of characters that
is not a valid expression.  In the following statements, \fIn\fR, the number of
characters, must be a nonzero integer expression less than or equal to 152:
.CS
   ENCODE (n,f,dent) [elist]
   DECODE (n,f,sent) [dlist]
.CE
.ME
$
$ Error : 0684
$msg  0684 Module procedure "%s" must have the PRIVATE attribute, because its function result is a private type.
$nexp 0684
Error : Module procedure "%s" must have the PRIVATE attribute, because its function result is a private type.
.PP
A module procedure that has a dummy argument or function result of a type 
that has private accessibility must have private accessibility.
.PP
If a module procedure is public, then if any of its dummy
arguments or its function result is a derived type, the type must be a
public type.
.ME
$
$ Error : 0685
$msg  0685 Module procedure "%s" must have the PRIVATE attribute, because dummy argument "%s" is a private type.
$nexp 0685
Error : Module procedure "%s" must have the PRIVATE attribute, because dummy argument "%s" is a private type.
.PP
A module procedure that has a dummy argument or function result of a type 
that has private accessibility must have private accessibility.
.PP
If a module procedure is public, then if any of its dummy
arguments or its function result is a derived type, the type must be a
public type.
.ME
$
$ Error : 0686
$msg  0686 Generic interface "%s" must be private, because specific interface "%s" is a function with a private type.
$nexp 0686
Error : Generic interface "%s" must be private, because specific interface "%s" is a function with a private type.
.PP
A module procedure that has a dummy argument or function result of a type 
that has private accessibility must have private accessibility and must not
have a generic identifier that has public accessibility.
.PP
If a generic identifier has public accessibility, then all
of its specific procedures must have function results and dummy arguments
that are declared to be public types.
.ME
$
$ Error : 0687
$msg  0687 Generic interface "%s" must be private, because dummy argument "%s" for specific interface "%s" is a private type.
$nexp 0687
Error : Generic interface "%s" must be private, because dummy argument "%s" for specific interface "%s" is a private type.
.PP
A module procedure that has a dummy argument or function result of a type 
that has private accessibility must have private accessibility.
.PP   
If a module procedure is public, then if any of its dummy
arguments or its function result is a derived type, the type must be a
public type.
.ME
$
$ Error : 0688
$msg  0688 Common block "%s" was specified in a SAVE statement, but has not been specified in a COMMON statement.
$nexp 0688
Error : Common block "%s" was specified in a SAVE statement, but has not been specified in a COMMON statement.
.PP
If a common block is specified in a \*CSAVE\fR statement, the common block must
also be declared in a \*CCOMMON\fR statement.
.ME
$
$ Internal : 0689
$msg  0689 The operator enum in globals.h does not match the operator_str array in debug.h.
$nexp 0689
Internal : The operator enum in globals.h does not match the operator_str array in debug.h.
.PP
When you add an operator to globals.h you must also add the corresponding
string to debug.h.
.PP
This message should never be generated and signifies a bad compiler or a bad
installation.  Please notify your product support organization with this
error message number and any supporting information.  This message does not
indicate a problem with your code.
.ME
$
$ Error : 0690
$msg  0690 Common block "%s" is specified in a TASK COMMON directive, therefore it must be specified in a COMMON statement.
$nexp 0690
Error : Common block "%s" is specified in a TASK COMMON directive, therefore it must be specified in a COMMON statement.
.PP
If a common block is specified in a \*CCDIR$ (!DIR$)\fR \*CTASK COMMON\fR statement, the
common block must also be declared in a \*CCOMMON\fR or a \*CTASK COMMON\fR statement.
.ME
$
$ Error : 0691
$msg  0691 "%s" is of a derived type that has an ultimate component that is allocatable, therefore it must not be a named constant or a variable in common.
$nexp 0691
Error : "%s" is of a derived type that has an ultimate component that is allocatable, therefore it must not be a named constant or a variable in common.
.PP
Neither a named constant nor a variable in a common block may
be of a derived type that 
has an allocatable component.
.ME
$
$ Ansi : 0692
$msg  0692 Initializing a named common block member in a program unit other than a block data program unit is nonstandard.
$nexp 0692
Ansi : Initializing a named common block member in a program unit other than a block data program unit is nonstandard.
.PP
An object is being initialized either by a \*CDATA\fR statement or by initialization
on a type declaration statement.  The object is a member of a named common 
block.  If an object is a member of a named common block it should only be 
initialized in a block data program unit.
.ME
$
$ Error : 0693
$msg  0693 A blank common block member must not be initialized.
$nexp 0693
Error : A blank common block member must not be initialized.
.PP
An object is being initialized either by a \*CDATA\fR statement or by initialization
on a type declaration statement.  The object is a member of blank common.  An
object that is a member of blank common must not be initialized.
.ME
$
$ Error : 0694
$msg  0694 This Hollerith constant is longer than one word.
$nexp 0694
Error : This Hollerith constant is longer than one word.
.PP
A Hollerith constant containing more characters than fit in a machine word is
being used in an expression.  In this context, a Hollerith constant is limited
to the number of characters that will fit in a machine word.
Hollerith constants are an extension to the Fortran standard.
.ME
$
$ Error : 0695
$msg  0695 A Cray character pointer must not be initialized.
$nexp 0695
Error : A Cray character pointer must not be initialized.
.PP
A \*CDATA\fR statement or a type declaration statement is attempting to initialize a
Cray character pointer.  Noncharacter Cray pointers can be initialized but Cray
character pointers cannot be initialized.
Cray pointers are an extension to the Fortran standard.
.ME
$
$ Error : 0696
$msg  0696 The implied-DO variable has already been used as an implied-DO variable in an inner loop.
$nexp 0696
Error : The implied-DO variable has already been used as an implied-DO variable in an inner loop.
.PP
A \*CDATA\fR statement may contain an implied-\*CDO\fR of the form:
.CS
   (\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C =
        \fIscalar_int_expr\*C, \fIscalar_int_expr\*C 
	[, \fIscalar_int_expr\*C])
.CE
.PP
The \fIdata_i_do_variable\fR of each implied-\*CDO\fR in the nest of implied-\*CDO\fRs must be a
unique name.  For example, the following nested set of implied-\*CDO\fRs does not
conform to the Fortran standard because variable \*CK\fR is used in
multiple loops:
.CS
DATA ((ARRAY(K,K), K = 1, 3), K = 1, 3)  /9*-1/
.CE
.ME
$
$ Error : 0697
$msg  0697 Cray pointer "%s" and  Cray pointee "%s" both must be public or they both must be private.
$nexp 0697
Error : Cray pointer "%s" and  Cray pointee "%s" both must be public or they both must be private.
.PP
The compiler detected one of the following:
.nf
	Cray Pointer	Cray Pointee
	\*CPRIVATE      PUBLIC
	PUBLIC       PRIVATE
.fi
.PP
\fRThey both must have either the \*CPUBLIC\fR or \*CPRIVATE\fR attribute.
Cray pointers are an extension to the Fortran standard.
.ME
$
$ Ansi : 0698
$msg  0698 Partial initialization of a whole array is an extension to the Fortran standard.
$nexp 0698
Ansi : Partial initialization of a whole array is an extension to the Fortran standard.
.PP
A constant must exist for each element of a whole array named in a 
\fIdata_stmt_object_list\fR, but some FORTRAN 77 compilers allow the number
of values in the constant list to be fewer than the number of targets if the 
last item in the target list is a whole array reference.
.PP
This is an outmoded FORTRAN 77 extension that was carried forward into this
compiler.  We recommend that you remove it where possible in existing code 
and avoid using it in any new code.
.ME
$
$ Error : 0699
$msg  0699 DATA target is a function reference or an array element reference to an undeclared array.
$nexp 0699
Error : DATA target is a function reference or an array element reference to an undeclared array.
.PP
The \*CDATA\fR target (\fIdata_stmt_object\fR or \fIdata_i_do_object\fR) has the form:
.CS
   \fIname\*C(\fIlist\*C)
.CE
.PP
\fRAt the time the reference was encountered, there was no additional
information available for the name; therefore it is ambiguous.  It
appears to be either a function reference or an array element reference
(where the array was not declared in the current scoping unit prior to
the \*CDATA\fR statement).
.PP
A \*CDATA\fR target cannot be a function reference because it must be a 
variable.
.PP
If an array element reference appears in a \*CDATA\fR statement, the array
must have had its array properties established by a previous specification
statement in the current scoping unit.
.PP
Example 1:  The following program does not conform to standard because the implied-\*CDO\fR
target array is declared to be an array by the specification statement
that follows the \*CDATA\fR statement.
.CS
 DATA (array(i), i = 1, 5) /5 * 1.0/
 DIMENSION array(5)
.CE
.PP
\fRExample 2:  The following program does not conform to standard because the implied-\*CDO\fR
target array is not declared in the internal subprogram.  The presence 
of a \*CDATA\fR statement in a scoping unit causes the target variable to be
implicitly declared to be a variable local to that scoping unit.  
Therefore, a contained scoping unit cannot initialize a variable 
declared in a host scoping unit.
.CS
 PROGRAM main
 REAL array(5)
 ...
 CONTAINS
   SUBROUTINE sub
   DATA (array(i), i = 1, 5) /5 * 1.0/
   ...
   END SUBROUTINE
 END PROGRAM
.CE
.ME
$
$ Error : 0700
$msg  0700 The intrinsic call "%s" is being made with illegal arguments.
$nexp 0700
Error : The intrinsic call "%s" is being made with illegal arguments.
.PP
A function or subroutine call which invokes the name of an intrinsic
procedure does not match any specific intrinsic.  All dummy arguments without
the \*COPTIONAL\fR attribute must match in type and rank exactly.
.ME
$
$ Error : 0701
$msg  0701 "%s" does not belong to the set of recognized intrinsic procedures
$nexp 0701
Error : "%s" does not belong to the set of recognized intrinsic procedures
.PP
A name declared with the \*CINTRINSIC\fR attribute is not in the set of
intrinsic functions and subroutines which the compiler recognizes. (If the
compiler does support this procedure, but does not recognize it by default,
you can add it to the set of recognized procedures by using the "-intrinsic"
option on the command line.)
.ME
$
$ Error : 0702
$msg  0702 Type double complex is not supported with -ep.
$nexp 0702
Error : Type double complex is not supported with -ep.
.PP
Type double complex is supported as an extension to the Fortran 
standard, only if \*C-dp\fR is used on the command line (\*C-dp\fR means "disable double
precision").  If \*C-ep\fR is on (enable double precision), then double complex is
not supported.  A double complex type which is unaffected by the \*C-dp/-ep\fR
command-line options can be specified by using \*CCOMPLEX(KIND=16)\fR.
.ME
$
$ Error : 0703
$msg  0703 A continuation line can only follow a line continued with the "&" symbol.
$nexp 0703
Error : A continuation line can only follow a line continued with the "&" symbol.
.PP
In free source form, a continuation line that starts with the \*C&\fR symbol
must follow a line that ends with the \*C&\fR symbol.
.ME
$
$ Internal : 0704
$msg  0704 Unexpected FLD value.
$nexp 0704
Internal : Unexpected FLD value.
.PP
The code was expecting a specific FLD value (such as AT_Tbl_Idx) but    
encountered a FLD value it could not handle.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0705
$msg  0705 "%s" is not a constant therefore it must not appear in an initialization expression.
$nexp 0705
Error : "%s" is not a constant therefore it must not appear in an initialization expression.
.PP
The \*CDATA\fR statement has the general form:
.CS   
   \fIdata_stmt_object_list\*C /\fIdata_stmt_value_list\*C/
.CE
.PP   
where a \fIdata_stmt_object\fR can be a variable or an implied-\*CDO\fR.  In a 
\fIdata_stmt_object\fR that is a variable, each subscript, section subscript, 
substring starting point, and substring ending point must be an initialization
expression.  An initialization is a constant expression with the addition that
exponentiation is allowed if the power is of type integer.  A constant 
expression is essentially an expression in which all primaries must be
constants, or resolve to constants, and each operation must be intrinsic. 
.ME
$
$ Error : 0706
$msg  0706 This function name must not appear in a DATA statement expression.
$nexp 0706
Error : This function name must not appear in a DATA statement expression.
.PP
The \*CDATA\fR statement has the general form:
.CS
   \fIdata_stmt_object_list\*C /\fIdata_stmt_value_list\*C/
.CE
.PP  
where a \fIdata_stmt_object\fR can be a variable or an implied-\*CDO\fR.  In a
\fIdata_stmt_object\fR that is a variable, each subscript, section subscript,
substring starting point, and substring ending point must be an initialization
expression.  If  
a function reference appears in an initialization expression,
it must be a reference to one of a restricted set of intrinsic functions 
allowed in an initialization expression.  See \fICFortran Language Reference
Manual\fR, publication SR-3902, 
for a complete 
description of initialization expressions.  It must not be a reference to a 
user-defined function.
.PP
The \*CDATA\fR statement implied-\*CDO\fR has the form:
.CS
(\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C =
  \fIscalar_int_expr\*C, \fIscalar_int_expr\*C [, \fIscalar_int_expr\*C])
.CE
.PP
A primary in a subscript of a \fIdata_i_do_object\fR subscript list must be a 
constant or a \*CDO\fR variable of a containing implied-\*CDO\fR.  A primary in such a 
subscript list cannot be a reference to either an intrinsic or a user-defined
function.  Also, each primary in each loop control \fIscalar_int_expr\fR must
be a constant or a \*CDO\fR variable of a containing implied-\*CDO\fR. 
.ME
$
$ Error : 0707
$msg  0707 Module procedure "%s" is not a module procedure in a parent of this scoping unit.
$nexp 0707
Error : Module procedure "%s" is not a module procedure in a parent of this scoping unit.
.PP
Each \fImodule_procedure_name\fR in a \*CMODULE PROCEDURE\fR statement
must be the name of a module procedure that is
accessible via host or use association.
.PP
The compiler found the module procedure name in the host, but it is not a module
procedure.  It is a variable, a derived type, or a namelist group name.
Following is an example of what the compiler found:
.CS
 MODULE MOD
 DIMENSION MM(100)

 CONTAINS
   SUBROUTINE JOE()
     INTERFACE BAD
       MODULE PROCEDURE MM ! MM is not a module
                           ! procedure.  It is
                           ! an array.
     END INTERFACE
   END SUBROUTINE JOE
 END MODULE
.CE
.ME
$
$ Warning : 0708
$msg  0708 Possible recursive reference to module procedure "%s".  RECURSIVE must be specified for a recursive reference.
$nexp 0708
Warning : Possible recursive reference to module procedure "%s".  RECURSIVE must be specified for a recursive reference.
.PP
The compiler detected a declaration for a module procedure inside an
interface block that is in the scope of the module procedure itself.  The
following example may clarify this:
.CS
MODULE MM
CONTAINS
  SUBROUTINE JOE
    INTERFACE GENERIC
      MODULE PROCEDURE JOE ! This is a reference
                           ! to the containing procedure
    END INTERFACE

    CALL GENERIC()   ! This is a recursive reference,
                     ! therefore JOE
                     ! must be declared
                     ! RECURSIVE SUBROUTINE JOE

   END SUBROUTINE JOE
END MODULE
.CE
.ME
$
$ Error : 0709
$msg  0709 A DATA implied-DO target must be an array element or scalar structure component reference.
$nexp 0709
Error : A DATA implied-DO target must be an array element or scalar structure component reference.
.PP
A \*CDATA\fR statement implied-\*CDO\fR has the form:
.CS
 (\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C =
     \fIscalar_int_expr\*C, \fIscalar_int_expr\*C
        [, \fIscalar_int_expr\*C])
.CE
.PP 
A \fIdata_i_do_object\fR can be an array element reference, a scalar structure 
component reference, or another implied-\*CDO\fR.  If the \fIdata_i_do\fR object is a 
structure component reference, at least one of the structure or component names
should have a subscript list associated with it.
.ME
$
$ Warning : 0710
$msg  0710 The -dp option does not change type %s*%d.  It will remain double precision.
$nexp 0710
Warning : The -dp option does not change type %s*%d.  It will remain double precision.
.PP
\*CREAL*16, DOUBLE PRECISION*16\fR and \*CCOMPLEX*32\fR are not affected by
the \*C-dp\fR command-line option.  They will remain as double precision type.
.ME
$
$ Caution : 0711
$msg  0711 The type statement for generic intrinsic function %s is ignored.
$nexp 0711
Caution : The type statement for generic intrinsic function %s is ignored.
.PP
The name of a generic intrinsic function appeared in a type declaration 
statement.  Generic intrinsic functions perform various operations, depending
on the data types of their arguments.  A specific data type cannot be assigned
to a generic intrinsic function.  The type declaration statement is ignored.
.ME
$
$ Error : 0712
$msg  0712 Generic interface "%s" must not also be the name of a module %s, unless it is a specific name in generic interface "%s".
$nexp 0712
Error : Generic interface "%s" must not also be the name of a module %s, unless it is a specific name in generic interface "%s".
.PP
If a module procedure and a generic interface name are the same, the module
procedure must be specified as a specific name in the generic interface.
The following is a legal example:
.CS
    MODULE XYZ
      INTERFACE IN
        MODULE PROCEDURE IN
      END INTERFACE
      CONTAINS
        SUBROUTINE  IN()
        END SUBROUTINE IN
   END MODULE XYZ
.CE
.PP
The following is an illegal example:
.CS
    MODULE XYZ
      INTERFACE IN
        MODULE PROCEDURE NOT_IN
      END INTERFACE
      CONTAINS
        SUBROUTINE  IN()
        END SUBROUTINE IN

        SUBROUTINE DOIT()
        CALL IN()  ! Illegal; the compiler cannot
                   ! determine which IN to call.
        END SUBROUTINE DOIT

        SUBROUTINE  NOT_IN()  
        END SUBROUTINE NOT_IN
   END MODULE XYZ
.CE
.ME
$
$ Error : 0713
$msg  0713 Generic interface "%s" is also an external or module procedure.  It must be a specific name in generic interface "%s".
$nexp 0713
Error : Generic interface "%s" is also an external or module procedure.  It must be a specific name in generic interface "%s".
.PP
If a generic interface and an external or module procedure share the same 
name, the procedure must be a specific name in the generic interface.
If a module procedure and a generic interface name are the same, the module
procedure must be specified as a specific name in the generic interface.
.PP
The following is a legal example:
.CS
 MODULE XYZ
   CONTAINS
     SUBROUTINE  IN()
     END SUBROUTINE IN

     SUBROUTINE DOIT()
     INTERFACE IN
       MODULE PROCEDURE IN
     END INTERFACE
     CALL IN()
     END SUBROUTINE DOIT
 END MODULE XYZ
.CE
.PP
The following is an illegal example:
.CS
MODULE XYZ
  CONTAINS
    SUBROUTINE  IN()
    END SUBROUTINE IN

    SUBROUTINE DOIT()
    INTERFACE IN
      MODULE PROCEDURE NOT_IN
    END INTERFACE     ! Illegal; IN not in interface
    CONTAINS
      SUBROUTINE B
      CALL IN()       ! Illegal; compiler cannot
      END SUBROUTINE B! determine which IN to call
    END SUBROUTINE DOIT

    SUBROUTINE NOT_IN
    END SUBROUTINE NOT_IN
END MODULE XYZ
.CE
.ME
$
$ Ansi : 0714
$msg  0714 "%s" is a common block name and is declared as an intrinsic procedure.  This is nonstandard.
$nexp 0714
Ansi : "%s" is a common block name and is declared as an intrinsic procedure.  This is nonstandard.
.PP
A common block name is being used as the name of an intrinsic procedure.
This is an extension to the Fortran standard.
.ME
$
$ Log_Warning : 0715
$msg  0715 Binary output (-eB or -b filename) disables assembly language output (-eS or -S filename).  Binary file selected.
$nexp 0715
Log_Warning : Binary output (-eB or -b filename) disables assembly language output (-eS or -S filename).  Binary file selected.
.PP
The compiler cannot have an assembly language file and a binary file open at 
the same time.   Assembly language output is disabled, because binary output
has been requested on the command line (\*C-eB\fR or \*C-b \fIfilename\fR). 
The compiler has processed a command line similar to this one:
.CS
        -eS -eB  \fIfile\*C.f  
.CE
.PP
This warning indicates that the \*C-eB\fR option overrides the \*C-eS\fR option.
.ME
$
$ Ansi : 0716
$msg  0716 "%s" is an external procedure or a program unit and is also a common block name.  This is nonstandard.
$nexp 0716
Ansi : "%s" is an external procedure or a program unit and is also a common block name.  This is nonstandard.
.PP
The Fortran standard prohibits a common block name from being the name of
an external subprogram or a program unit.  A program unit is a block data
subprogram, a module subprogram, or a main program.  An external subprogram
is an external function or subroutine.
.ME
$
$ Log_Warning : 0717
$msg  0717 The -Ta option implies -Ca.
$nexp 0717
Log_Warning : The -Ta option implies -Ca.
.PP
If the MPP apprentice option is specified, all CIF records are generated,
even if the user only requests specific CIF records.
.ME
$
$ Internal : 0718
$msg  0718 The line number passed to the routine set_format_start_idx is not a valid line number.
$nexp 0718
Internal : The line number passed to the routine set_format_start_idx is not a valid line number.
.PP
The routine set_format_start_idx was trying to match an input line number
with a line number currently in the statement buffer.  It could not find
a match.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0719
$msg  0719 Integer overflow resulted from an integer conversion or arithmetic operation.
$nexp 0719
Error : Integer overflow resulted from an integer conversion or arithmetic operation.
.PP
When trying to compute the value of a constant expression, the compiler
encountered an integer value that is too large to be represented.  A constant
expression is an expression involving only constants, and the value of the
expression is determined at compile time rather than at execution time.  This
error may occur during an intermediate computation (for example, add,
subtract, multiply, or divide, or exponentiation) or may occur when data 
conversion is required during the computation (for example, converting 
from real to integer).
.ME
$
$ Error : 0720
$msg  0720 A constant expression exceeds the valid range.
$nexp 0720
Error : A constant expression exceeds the valid range.
.PP
When trying to compute the value of a constant expression, the compiler
encountered an integer or real value that was too large to be represented.  A
constant expression is an expression involving only constants, and the value
of the expression is determined at compile time rather than at execution
time.  This error may occur during an intermediate computation (for example,
add, subtract, multiply, divide, or exponentiation) or may occur when data 
conversion is required during the computation (for example, converting from 
double precision to real).
.ME
$
$ Error : 0721
$msg  0721 A divisor of zero was detected in an expression.
$nexp 0721
Error : A divisor of zero was detected in an expression.
.PP
When trying to compute the value of a constant expression, the compiler
encountered a divide operation with a divisor of zero.  A constant expression
is an expression involving only constants, and the value of the expression
is determined at compile time rather than at execution time.
.ME
$
$ Error : 0722
$msg  0722 This use of function "%s" is not valid.
$nexp 0722
Error : This use of function "%s" is not valid.
.PP
A function name was encountered without a parentheses group.  
.ME
$
$ Error : 0723
$msg  0723 This use of a generic interface or internal function "%s" is not valid.
$nexp 0723
Error : This use of a generic interface or internal function "%s" is not valid.
.PP
A name that could either be a generic interface or an internal function is
specified without a parentheses group.
.ME
$
$ Error : 0724
$msg  0724 Unknown statement.  Expected assignment statement but found "%s" instead of "=" or "=>".
$nexp 0724
Error : Unknown statement.  Expected assignment statement but found "%s" instead of "=" or "=>".
.PP
The compiler expected an assignment statement but could not find
an assignment or pointer assignment operator at the correct point.
.ME
$
$ Error : 0725
$msg  0725 Module "%s" must be targeted for the same operating system as this compilation.
$nexp 0725
Error : Module "%s" must be targeted for the same operating system as this compilation.
.PP
The module being specified in the USE statement must be targetted for the
same operating system as this compilation.  Target operating systems may
not be mixed.
.ME
$
$ Error : 0726
$msg  0726 There is a problem with the module information file for module "%s".
$nexp 0726
Error : There is a problem with the module information file for module "%s".
.PP
The compiler received a read or write error while attempting to read or
write the module information file.
.ME
$
$ Error : 0727
$msg  0727 The BOUNDARY argument must have the same type and type parameters as ARRAY.
$nexp 0727
Error : The BOUNDARY argument must have the same type and type parameters as ARRAY.
.PP
The BOUNDARY argument must have the same type and type parameters as ARRAY.
.ME
$
$ Error : 0728
$msg  0728 At least one actual argument to this intrinsic must be present.
$nexp 0728
Error : At least one actual argument to this intrinsic must be present.
.PP
At least one actual argument must be passed to this intrinsic procedure.
.ME
$
$ Ansi : 0729
$msg  0729 "%s" is not type integer, therefore initializing it with a BOZ literal constant is nonstandard.
$nexp 0729
Ansi : "%s" is not type integer, therefore initializing it with a BOZ literal constant is nonstandard.
.PP
The Fortran standard states that a BOZ literal constant can only appear in
a \*CDATA\fR statement and it can only be used to initialize a variable of type 
integer.  
.ME
$
$ Warning : 0730
$msg  0730 A dummy argument with INTENT(OUT) or INTENT(INOUT) is associated with an actual argument that cannot be defined.
$nexp 0730
Warning : A dummy argument with INTENT(OUT) or INTENT(INOUT) is associated with an actual argument that cannot be defined.
.PP
An actual argument that is an expression, constant, or vector valued
subscript array reference has been associated with a dummy argument
that has the \*CINTENT(OUT)\fR or \*CINTENT(INOUT)\fR attribute.  A warning is
issued because the actual argument cannot be defined.
.ME
$
$ Error : 0731
$msg  0731 "%s" is the name of a dummy argument to program unit "%s", therefore it must not be use associated from module "%s".
$nexp 0731
Error : "%s" is the name of a dummy argument to program unit "%s", therefore it must not be use associated from module "%s".
.PP
The name of a dummy argument to the program unit has been found in a
module brought in by a \*CUSE\fR statement.  This creates a name conflict, therefore
it is not allowed.
.PP   
Example:
.CS
    MODULE NEW
      INTEGER ABC
    END MODULE

    SUBROUTINE XYZ(ABC)
     USE NEW     ! ABC is illegal here
    END SUBROUTINE
.CE
.ME
$
$ Error : 0732
$msg  0732 "%s" is not in module "%s".
$nexp 0732
Error : "%s" is not in module "%s".
.PP
The compiler cannot find the specified name in the module.  If a name is 
specified on a \*CUSE\fR statement, it must be in that module.
.ME
$
$ Error : 0733
$msg  0733 Initializing multiple array elements with a single Hollerith or character constant is nonstandard.
$nexp 0733
Error : Initializing multiple array elements with a single Hollerith or character constant is nonstandard.
.PP
A Hollerith constant (including the character literal form, '...') can 
initialize more than one element of an integer or real array when the array is
specified without a subscript list.  For example, given the array declared
.CS
INTEGER a(2)
.CE
.PP
on a 64-bit machine, the following \*CDATA\fR statements have the same effect:
.CS
  DATA a /'1234567890123456'/

  DATA a /8H12345678, 8H90123456/
.CE
.PP
\fRInitializing array elements in this manner is an extension to the Fortran 
standard.  It is an outmoded feature carried forward from CF77.  We
recommend that you remove it where possible from existing code and avoid 
using it in any new code.
.ME
$
$ Internal : 0734
$msg  0734 Internal error in create_loop_stmts. 
$nexp 0734
Internal : Internal error in create_loop_stmts. 
.PP
Unexpected intermediate text found in create_loop_stmts.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0735
$msg  0735 Using a single END DO as a termination statement for multiple DO loops is an extension to the Fortran standard.
$nexp 0735
Ansi : Using a single END DO as a termination statement for multiple DO loops is an extension to the Fortran standard.
.PP
The Fortran standard defines a block \*CDO\fR construct to be a \*CDO\fR loop that
terminates with an \*CEND DO\fR or \*CCONTINUE\fR statement where each \*CDO\fR loop in a nest of
\*CDO\fR loops must have its own terminating \*CEND DO\fR or \*CCONTINUE\fR statement.  The compiler 
extends the standard by allowing more than one \*CDO\fR loop to share a single 
labeled \*CEND DO\fR as the common termination statement.
.PP
This is an outmoded feature carried forward from CF77.  We
recommend that you remove it where possible from existing code and avoid 
using it in any new code.
.ME
$
$ Error : 0736
$msg  0736 "%s" is the name of this program unit, therefore it must not be use associated from module "%s".
$nexp 0736
Error : "%s" is the name of this program unit, therefore it must not be use associated from module "%s".
.PP
The name of the program unit has been found in a module brought in
by a \*CUSE\fR statement.  This creates a name conflict.
.PP
Example:
.CS
   MODULE NEW
    INTEGER ABC
   END MODULE

   PROGRAM ABC
     USE NEW   ! ABC is illegal here
   END PROGRAM
.CE
.ME
$
$ Internal : 0737
$msg  0737 Internal compiler error encountered in process_deferred_io_list.
$nexp 0737
Internal : Internal compiler error encountered in process_deferred_io_list.
.PP
In the routine process_deferred_io_list, an Alt_Return_Opr was found without
a Br_Index_Opr on the next stmt.  This indicates an internal compiler error
condition.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0738
$msg  0738 Dummy argument X is type complex, thus dummy argument Y must not be present.
$nexp 0738
Error : Dummy argument X is type complex, thus dummy argument Y must not be present.
.PP
If the dummy argument \*CX\fR to the \*CCMPLX\fR intrinsic is type complex, then the
dummy argument \*CY\fR must not be present.
.ME
$
$ Warning : 0739
$msg  0739 No arguments are allowed to the "%s" intrinsic function - arguments ignored.
$nexp 0739
Warning : No arguments are allowed to the "%s" intrinsic function - arguments ignored.
.PP
No actual arguments are allowed to be passed to this intrinsic function.  The 
arguments are ignored.
.ME
$
$ Error : 0740
$msg  0740 IMPLICIT NONE is specified in the local scope, therefore an explicit type must be specified for statement function "%s".
$nexp 0740
Error : IMPLICIT NONE is specified in the local scope, therefore an explicit type must be specified for statement function "%s".
.PP
When \*CIMPLICIT NONE\fR is specified, all statement functions must be explicitly typed.
.ME
$
$ Error : 0741
$msg  0741 IMPLICIT NONE is specified in the local scope.  Statement function dummy argument "%s" must have an explicit type.
$nexp 0741
Error : IMPLICIT NONE is specified in the local scope.  Statement function dummy argument "%s" must have an explicit type.
.PP
When \*CIMPLICIT NONE\fR is specified, all dummy arguments to statement functions must 
be explicitly typed.
.ME
$
$ Error : 0742
$msg  0742 IMPLICIT NONE is specified in the host scope, therefore an explicit type must be specified for statement function "%s".
$nexp 0742
Error : IMPLICIT NONE is specified in the host scope, therefore an explicit type must be specified for statement function "%s".
.PP
When \*CIMPLICIT NONE\fR is specified in a host scope, all statement functions must be
explicitly typed, including those in any contained scopes.
.ME
$
$ Error : 0743
$msg  0743 IMPLICIT NONE is specified in the host scope.  Statement function dummy argument "%s" must have an explicit type.
$nexp 0743
Error : IMPLICIT NONE is specified in the host scope.  Statement function dummy argument "%s" must have an explicit type.
.PP
When \*CIMPLICIT NONE\fR is specified in a host scope, all statement function dummy
arguments  must be explicitly typed, including those in any contained scopes.
.ME
$
$ Log_Warning : 0744
$msg  0744 The -%c command line option has an unsupported option "%s".
$nexp 0744
Log_Warning : The -%c command line option has an unsupported option "%s".
.PP
This command-line option is not supported on this hardware.  The option
is ignored.
.ME
$
$ Error : 0745
$msg  0745 The case value is not the same type as the case expression in the SELECT CASE statement.
$nexp 0745
Error : The case value is not the same type as the case expression in the SELECT CASE statement.
.PP
For a given \*CCASE\fR construct, each \fIcase_value\fR must be of the same type as
the \fI\fIcase_expr\fR specified in the \*CSELECT CASE\fR statement.  For type character, the
\fIcase_value\fRs need not have the same length as each other nor do they have to be
the same length as the \fIcase_expr\fR in the \*CSELECT CASE\fR statement.
.ME
$
$ Error : 0746
$msg  0746 The case value has the same value as a case value on line %d.
$nexp 0746
Error : The case value has the same value as a case value on line %d.
.PP
For a given \*CCASE\fR construct, the \fIcase_value_range\fRs must not overlap; 
there must be no possible value of the \fIcase_expr\fR of the \*CSELECT CASE\fR 
statement that matches more than one \fIcase_value_range\fR.  
.PP
The compiler encountered a \fIcase_value\fR that has already been specified in 
a previous \*CCASE\fR statement of the same \*CCASE\fR construct.  Example:
.CS
   SELECT CASE (k)
       
      CASE (1)
        ...

      CASE (1) ! Error; case_value 1 has
        ...    ! already been specified

    END SELECT
.CE
.ME
$
$ Error : 0747
$msg  0747 The case-value is already contained in a case-value range on line %d.
$nexp 0747
Error : The case-value is already contained in a case-value range on line %d.
.PP
For a given \*CCASE\fR construct, the \fIcase_value_range\fRs must not overlap; 
there must be no possible value of the \fIcase_expr\fR of the \*CSELECT CASE\fR 
statement that matches more than one \fIcase_value_range\fR.  
.PP
The compiler encountered a \fIcase_value\fR whose value is contained in a 
\fIcase_value_range\fR that was specified in a previous \*CCASE\fR statement of the same
\*CCASE\fR construct.  Example:
.CS
    SELECT CASE (k)
        
      CASE (1:10)
        ...

      CASE (3) ! Error; case_value 3
               ! is contained in
        ...    ! range (1:10) in a
               ! previous CASE statement.

    END SELECT
.CE
.ME
$
$ Error : 0748
$msg  0748 The case-value range contains a value that was already specified by a case-value on line %d.
$nexp 0748
Error : The case-value range contains a value that was already specified by a case-value on line %d.
.PP
For a given \*CCASE\fR construct, the \fIcase_value_range\fRs must not overlap; 
there must be no possible value of the \fIcase_expr\fR of the \*CSELECT CASE\fR 
statement that matches more than one \fIcase_value_range\fR.  
.PP
The compiler encountered a \fIcase_value_range\fR that specifies a range that 
contains a value that has already been specified by a \fIcase_value\fR in a previous
\*CCASE\fR statement of the same \*CCASE\fR construct.  Example:
.CS
   SELECT CASE (k)
        
    CASE (5)
       ...

    CASE (1:)  ! Error; case_value 5
       ...     ! has already been specified

    END SELECT
.CE
.ME
$
$ Error : 0749
$msg  0749 The case-value range overlaps a case-value range on line %d.
$nexp 0749
Error : The case-value range overlaps a case-value range on line %d.
.PP
For a given \*CCASE\fR construct, the \fIcase_value_range\fRs must not overlap; 
there must be no possible value of the \fIcase_expr\fR of the \*CSELECT CASE\fR 
statement that matches more than one \fIcase_value_range\fR.  
.PP
The compiler encountered a \fIcase_value_range\fR that overlaps a
\fIcase_value_range\fR specified
in a previous \*CCASE\fR statement of the same \*CCASE\fR construct.
Example:
.CS
   SELECT CASE (k)
        
    CASE (1:10)
      ...

    CASE (5:) ! Error; the range 5:10
      ...     ! has already been specified

    END SELECT
.CE
.ME
$
$ Error : 0750
$msg  0750 Actual argument number %d to statement function "%s" is not scalar.
$nexp 0750
Error : Actual argument number %d to statement function "%s" is not scalar.
.PP
Only scalar dummy and actual arguments can be used in statement functions.
.ME
$
$ Error : 0751
$msg  0751 Actual argument has type "%s".  Associated dummy argument "%s" has type "%s".
$nexp 0751
Error : Actual argument has type "%s".  Associated dummy argument "%s" has type "%s".
.PP
The type of the actual argument to a statement function must agree with
the type of the dummy argument it is associated with.
.ME
$
$ Error : 0752
$msg  0752 Actual argument number %d to statement function "%s" has a different kind type than the dummy argument.
$nexp 0752
Error : Actual argument number %d to statement function "%s" has a different kind type than the dummy argument.
.PP
The kind type of an actual argument to a statement function must agree with the
kind type of the dummy argument it is associated with.
.ME
$
$ Error : 0753
$msg  0753 Statement function "%s" must not call itself recursively.
$nexp 0753
Error : Statement function "%s" must not call itself recursively.
.PP
A statement function must not call itself.
.ME
$
$ Error : 0754
$msg  0754 Statement function "%s" is called with an incorrect number of arguments.
$nexp 0754
Error : Statement function "%s" is called with an incorrect number of arguments.
.PP
The number of actual arguments to a statement function call must be the same
as the number of its dummy arguments.
.ME
$
$ Error : 0755
$msg  0755 The expression of statement function "%s" must be a scalar expression.
$nexp 0755
Error : The expression of statement function "%s" must be a scalar expression.
.PP
Only scalar statement functions are allowed.
.ME
$
$ Error : 0756
$msg  0756 The type of the expression is not assignment compatible with the result of statement function "%s".
$nexp 0756
Error : The type of the expression is not assignment compatible with the result of statement function "%s".
.PP
The statement function expression must be compatible with the statement function
result according to the rules of assignment type conformance.
.ME
$
$ Error : 0757
$msg  0757 Operator "%s" is not intrinsic.  All operations in a statement function expression must be intrinsic.
$nexp 0757
Error : Operator "%s" is not intrinsic.  All operations in a statement function expression must be intrinsic.
.PP
An overloaded or defined operator is specified in a statement function 
expression.  Only intrinsic operations are allowed.
.ME
$
$ Warning : 0758
$msg  0758 The value to the left of the colon is greater than the value to the right of the colon. 
$nexp 0758
Warning : The value to the left of the colon is greater than the value to the right of the colon. 
.PP
If the \fIcase_expr\fR of the \*CSELECT CASE\fR statement has the value \fIc\fR and a \*CCASE\fR 
selector has the form \fIlow\*C:\fIhigh\fR, the case is selected if the expression

       \fIlow\*C .LE. \fIc\*C  .AND.  \fIc\*C .LE. \fIhigh\fR

is true.  The expression being diagnosed will never have the value true, because the value to
the left of the colon, \fIlow\fR, is greater than the value to the right of 
the colon, \fIhigh\fR.  This is, therefore, an "empty" \*CCASE\fR and the code in the
\*CCASE\fR will never be executed.
.ME
$
$ Error : 0759
$msg  0759 "%s" has the %s attribute, so it is a procedure.  Statement function actual arguments must be scalar data objects.
$nexp 0759
Error : "%s" has the %s attribute, so it is a procedure.  Statement function actual arguments must be scalar data objects.
.PP
All actual arguments to a statement function must be scalar data objects.
The following attributes declare an object to be a procedure, which is not a
data object.
.CS
     EXTERNAL
     INTRINSIC
     VFUNCTION
     NOSIDE EFFECTS
.CE
.ME
$
$ Error : 0760
$msg  0760 "%s" is a %s.  Statement function actual arguments must be scalar data objects.
$nexp 0760
Error : "%s" is a %s.  Statement function actual arguments must be scalar data objects.
.PP
The object must not be used as a statement function actual argument because it
is not a scalar data object.
.ME
$
$ Error : 0761
$msg  0761 "%s" is a procedure name, therefore it must not be used as an actual argument to a statement function.
$nexp 0761
Error : "%s" is a procedure name, therefore it must not be used as an actual argument to a statement function.
.PP
All actual arguments to a statement function must be scalar data objects.
.ME
$
$ Internal : 0762
$msg  0762 Internal error in io_ctl_list_semantics.
$nexp 0762
Internal : Internal error in io_ctl_list_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0763
$msg  0763 Namelist descriptor was not created for %s.
$nexp 0763
Internal : Namelist descriptor was not created for %s.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0764
$msg  0764 The SELECT CASE case-expr is type logical therefore a colon must not appear.
$nexp 0764
Error : The SELECT CASE case-expr is type logical therefore a colon must not appear.
.PP
A \*CCASE\fR selector has the following basic forms:
.CS
  CASE (\fIcase_value\*C)
  CASE (\fIcase_value\*C:)
  CASE (:\fIcase_value\*C)
  CASE (\fIcase_value:case_value\*C)
.CE
.PP
If the \fIcase_expr\fR of the \*CSELECT CASE\fR statement is type logical, only the first
form is allowed; that is, the \*CCASE\fR selector must not contain any ranges.
.ME
$
$ Error : 0765
$msg  0765 The SELECT CASE case-expr must be scalar.
$nexp 0765
Error : The SELECT CASE case-expr must be scalar.
.PP
The \*CSELECT CASE\fR statement has the form:
.CS
  [\fIcase_construct_name\*C:] SELECT CASE (\fIcase_expr\*C)
.CE
.PP
The \fIcase_expr\fR must be scalar and of type integer, character or logical.
.ME
$
$ Error : 0766
$msg  0766 The case-value must be a scalar expression.
$nexp 0766
Error : The case-value must be a scalar expression.
.PP
The \*CCASE\fR statement has the following forms:
.CS
    CASE (\fIcase_value\*C)
    CASE (\fIcase_value\*C:)
    CASE (:\fIcase_value\*C)
    CASE (\fIcase_value\*C:\fIcase_value\*C)
.CE
.PP
The \fIcase_value\fR must be scalar.    
.ME
$
$ Error : 0767
$msg  0767 The SELECT CASE case-expr must be type integer, character, or logical.
$nexp 0767
Error : The SELECT CASE case-expr must be type integer, character, or logical.
.PP
The \*CSELECT CASE\fR statement has the form:
.CS
   [\fIcase_construct_name\*C:] SELECT CASE (\fIcase_expr\*C)
.CE
.PP
The \fIcase_expr\fR must be type integer, character, or logical.
.ME
$
$ Error : 0768
$msg  0768 The case-value must be type integer, character, or logical.
$nexp 0768
Error : The case-value must be type integer, character, or logical.
.PP
The \*CCASE\fR statement has the following forms:
.CS
    CASE (\fIcase_value\*C)
    CASE (\fIcase_value\*C:)
    CASE (:\fIcase_value\*C)
    CASE (\fIcase_value\*C:\fIcase_value\*C)
.CE 
.PP
The \fIcase_value\fR in the first form must be type integer, character, or logical.
Each \fIcase_value\fR in the last three forms must be type integer or character. 
.ME
$
$ Error : 0769
$msg  0769 Unexpected syntax:  Expecting "%s" or EOS to follow the END keyword, but found "%c". 
$nexp 0769
Error : Unexpected syntax:  Expecting "%s" or EOS to follow the END keyword, but found "%c". 
.PP
The compiler is looking for an EOS or the following after the \*CEND\fR keyword:
\*CBLOCK DATA\fR, \*CMODULE\fR, \*CPROGRAM\fR, \*CSUBROUTINE\fR, 
\*CFUNCTION\fR, \*CINTERFACE\fR, \*CTYPE\fR, \*CIF\fR, \*CDO\fR,
\*CSELECT\fR, or \*CWHERE\fR.  The compiler did not find either the EOS or any of the 
keywords in the list.
.ME
$
$ Error : 0770
$msg  0770 The kind-selector expression must be a scalar integer initialization expression.
$nexp 0770
Error : The kind-selector expression must be a scalar integer initialization expression.
.PP
A \fIkind_selector\fR can appear with a data type attribute, such as:
.CS
  INTEGER \fIkind_selector
.CE
.PP
\fRThe \fIkind_selector\fR has the form:
.CS
  ( [KIND=] \fIexpr\*C)
.CE
.PP
where \fIexpr\fR must be a scalar integer initialization expression.  An
initialization expression is essentially an expression composed of intrinsic
operators, and primaries that are constants and/or references to selected 
intrinsic functions.  The expression must be such that a resultant value can 
be computed at compile time.  See the manual for a complete description of all
the characteristics that must be satisfied for an expression to be classed as 
an initialization expression.
.ME
$
$ Ansi : 0771
$msg  0771 In Fortran 95, a BOZ constant may appear only in a DATA statement (in Fortran 2003, it may also appear in intrinsic INT, REAL, DBLE, or CMPLX)
$nexp 0771
Ansi : In Fortran 95, a BOZ constant may appear only in a DATA statement (in Fortran 2003, it may also appear in intrinsic INT, REAL, DBLE, or CMPLX)
.PP
The Fortran 95 standard allows BOZ literal constants only in a \*CDATA\fR
statement value list. The Fortran 2003 standard also allows them as arguments
to intrinsics INT, REAL, or DBLE. As an extension, the compiler allows them
elsewhere.
.PP
By default, intrinsics REAL, DBLE, and CMPLX treat a BOZ constant as an
integer and return the real value having the same magnitude. When the option
-ansi or -ffortran2003 is in effect, the compiler behaves as Fortran 2003
prescribes, returning the real value having the same bit pattern as the BOZ
constant.
.ME
$
$ Error : 0772
$msg  0772 The rank of this actual argument must match that of assumed-shape dummy argument "%s".
$nexp 0772
Error : The rank of this actual argument must match that of assumed-shape dummy argument "%s".
.PP
When a dummy argument is declared to be an assumed-shape array, the actual
argument that is associated with it must conform in type, kind type, and
shape.  Shape conformance means having the same rank and the same extents 
in each rank.
.ME
$
$ Error : 0773
$msg  0773 The rank of this actual argument does not match that of the dummy argument "%s".
$nexp 0773
Error : The rank of this actual argument does not match that of the dummy argument "%s".
.PP
When the actual argument is an array expression or pointer it can only
be associated with an array dummy argument of the same rank.
.ME
$
$ Error : 0774
$msg  0774 Improper intrinsic argument type or inconsistent types.
$nexp 0774
Error : Improper intrinsic argument type or inconsistent types.
.PP
The type and/or the kind type of an actual argument is not valid.    
.ME
$
$ Internal : 0775
$msg  0775 An extent tmp has unexpected IR, during bound expansion at a call site.  The tmp is "%s" (%d).
$nexp 0775
Internal : An extent tmp has unexpected IR, during bound expansion at a call site.  The tmp is "%s" (%d).
.PP
During bound expansion, if the extent is a tmp, the IR is assumed to be
tmp = max(tmp,0).  The compiler has detected something other than this.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 0776
$msg  0776 "cif_stmt_type_rec" was passed a statement type it did not expect.
$nexp 0776
Internal : "cif_stmt_type_rec" was passed a statement type it did not expect.
.PP
cif_stmt_type_rec is probably trying to process a statement that maps to the 
enum value CIF_Stmt_Type_Error.  The array of CIF exact statement types might
have gotten out of step with the normal statement type array.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0777
$msg  0777 The actual argument to the PRESENT intrinsic must be an optional dummy argument.
$nexp 0777
Error : The actual argument to the PRESENT intrinsic must be an optional dummy argument.
.PP
The argument passed to the \*CPRESENT\fR intrinsic function must be a
dummy argument that has the \*COPTIONAL\fR attribute.
.ME
$
$ Ansi : 0778
$msg  0778 This format specifier is an extension to the Fortran standard.
$nexp 0778
Ansi : This format specifier is an extension to the Fortran standard.
.PP
The Fortran standard allows format specifiers to be a default character
expression, a \*CFORMAT\fR statement label, an asterisk (*), or a scalar default integer
variable.  The compiler allows other forms as an extension.  These include integer
and real whole arrays and Hollerith or Boolean constants.  These extensions
are interpreted as if they contain Hollerith data.
.ME
$
$ Error : 0779
$msg  0779 LOC function argument must be a variable, array, or array element.
$nexp 0779
Error : LOC function argument must be a variable, array, or array element.
.PP
The \*CLOC\fR intrinsic function argument must be a variable, array, or array element.
The \*CLOC\fR intrinsic function
is an extension to the Fortran standard.
.ME
$
$ Error : 0780
$msg  0780 Statement label "%s" was previously defined in this derived type definition.
$nexp 0780
Error : Statement label "%s" was previously defined in this derived type definition.
.PP
A derived type definition is a Fortran scoping unit.  A given statement
label must be defined only once in a scoping unit.  A previous definition of the
statement label was found within the current derived type definition. 
.ME
$
$ Error : 0781
$msg  0781 The substring start or end value exceeds the defined range.
$nexp 0781
Error : The substring start or end value exceeds the defined range.
.PP
A character substring reference has an improper substring designator.  In the
following character substring reference, the substring designators, \fIbegin\fR and
\fIend\fR, designate the beginning and ending character positions of the substring:
.CS
 CHAR ([\fIbegin\*C]:[\fIend\*C])
.CE
.PP
If the substring has length greater than 0 then \fIbegin\fR and \fIend\fR must be greater 
than 0 and less than or equal to the number of characters in the entity, \*CCHAR\fR.  
If \fIend\fR is less than \fIbegin\fR the substring has length 0.
.ME
$
$ Internal : 0782
$msg  0782 List entry %d has a variant problem with field %s.
$nexp 0782
Internal : List entry %d has a variant problem with field %s.
.PP
A list table entry has been used incorrectly. This is probably the result
of using the field IL_PREV_LIST_IDX when IL_ARG_DESC_VARIANT is true or
using IL_ARG_DESC_IDX when IL_ARG_DESC_VARIANT is false.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0783
$msg  0783 The TARGET argument must have the TARGET attribute or the POINTER attribute.
$nexp 0783
Error : The TARGET argument must have the TARGET attribute or the POINTER attribute.
.PP
The second argument to the \*CASSOCIATED\fR intrinsic function must be a pointer or a 
target.
.ME
$
$ Error : 0784
$msg  0784 The first argument to this intrinsic must have the POINTER attribute.
$nexp 0784
Error : The first argument to this intrinsic must have the POINTER attribute.
.PP
This argument must be a pointer.
.ME
$
$ Error : 0785
$msg  0785 The autotasking directive "%s" must only be used within a parallel region bounded by PARALLEL/ENDPARALLEL directives.
$nexp 0785
Error : The autotasking directive "%s" must only be used within a parallel region bounded by PARALLEL/ENDPARALLEL directives.
.PP
One of the following autotasking directives is not within a parallel region 
or is inside a guarded region.  The following directives must only be used 
within a parallel region bounded by the \*CPARALLEL/ENDPARALLEL\fR directives.
.CS
  CASE
  ENDCASE
  DO PARALLEL
  END DO
.CE
.ME
$
$ Error : 0786
$msg  0786 An actual argument must be definable when associated with a dummy argument that has INTENT(OUT) or INTENT(INOUT).
$nexp 0786
Error : An actual argument must be definable when associated with a dummy argument that has INTENT(OUT) or INTENT(INOUT).
.PP
A dummy argument that has either the \*CINTENT(OUT)\fR or \*CINTENT(INOUT)\fR attribute can
only be associated with an actual argument that can be defined.  It is an
error to associate an expression, a constant, or a vector subscript array 
section with such a dummy argument. It is also an error to use an
\*CINTENT(IN)\fR dummy argument as an actual argument that is associated with
such a dummy argument.
.ME
$
$ Ansi : 0787
$msg  0787 Intrinsic "%s" is an extension to the Fortran standard.
$nexp 0787
Ansi : Intrinsic "%s" is an extension to the Fortran standard.
.PP
This intrinsic procedure is an extension to the Fortran standard.
.ME
$
$ Log_Warning : 0788
$msg  0788 If -G0 (full debug) is specified, all optimizations are turned off.
$nexp 0788
Log_Warning : If -G0 (full debug) is specified, all optimizations are turned off.
.PP
Use of the \*C-G0\fR debug option requires all optimization to be turned off.  This
compilation will be handled as if \*C-O0\fR was specified on the command line.
Optimized debugging is turned on with different levels of the \*C-G\fR option.
.ME
$
$ Error : 0789
$msg  0789 The case-value-range is missing both its case-values.
$nexp 0789
Error : The case-value-range is missing both its case-values.
.PP
When a \fIcase_value\fR range of a \*CCASE\fR statement \fIcase_selector\fR contains a colon, the
\fIcase_value_range\fR must have one of the forms

.nf
     \fIcase_value\*C:
\fRor   \*C:\fIcase_value
\fRor   \fIcase_value\*C:\fIcase_value
.fi
.PP
A \fIcase_value_range\fR has been encountered that is missing both its left and right
\fIcase_value\fRs.
.ME
$
$ Warning : 0790
$msg  0790 Unknown compiler directive or syntax error.
$nexp 0790
Warning : Unknown compiler directive or syntax error.
.PP
A misspelled or unrecognized compiler directive was encountered.
.ME
$
$ Error : 0791
$msg  0791 "%s" is not a module, therefore it must not be specified on the USE statement as the module-name.
$nexp 0791
Error : "%s" is not a module, therefore it must not be specified on the USE statement as the module-name.
.PP
The name specified on the \*CUSE\fR statement as the module name is already known
to this scope as something other than a module name.  The \fImodule_name\fR can
only be a module name.  Following is an example of the error.
.CS
 PROGRAM ABC
 USE MOD_M :: BAD => R ! New local variable, BAD
 USE BAD               ! Illegal - BAD is a local
                       !    variable in this scope.
 END PROGRAM
.CE
.ME
$
$ Error : 0792
$msg  0792 "%s" is the name of the module being compiled.  It must not be specified on a USE statement.
$nexp 0792
Error : "%s" is the name of the module being compiled.  It must not be specified on a USE statement.
.PP
A module must not use itself, as in this example:
.CS
 MODULE MODULE_M
 USE MODULE_M   ! This is illegal
  ...
 END MODULE
.CE
.ME
$
$ Error : 0793
$msg  0793 Module "%s" has no public entities declared in the module, therefore names specified in the only-list cannot be found.
$nexp 0793
Error : Module "%s" has no public entities declared in the module, therefore names specified in the only-list cannot be found.
.PP
The module specified on the \*CUSE\fR statement is empty, which means that none of the
names specified on the \fIonly_list\fR will be found.  The module could appear to be empty
because all the module entities are private, the module has compilation
errors, or the file containing the module information is corrupted.
.ME
$
$ Error : 0794
$msg  0794 !DIR$ INTEGER= must either precede a program unit or must precede any statements within the program unit.
$nexp 0794
Error : !DIR$ INTEGER= must either precede a program unit or must precede any statements within the program unit.
.PP
The \*CINTEGER=\fR compiler directive must be seen by the compiler before any
declarative or executable statements are encountered. This means that it
can precede the program unit or it must immediately follow the program
unit header statement. The following examples show the two contexts that
are allowed.  The \*CINTEGER=\fR compiler directive is not allowed in 
interface bodies, internal procedures or module procedures.
.CS
!DIR$ INTEGER = 64
      integer i
      i = 10
      end

      subroutine sub
!DIR$ INTEGER = 46
      i = 10
      end
.CE
.ME
$
$ Warning : 0795
$msg  0795 Compiler directive %s is only allowed within a program unit.
$nexp 0795
Warning : Compiler directive %s is only allowed within a program unit.
.PP
A compiler directive is outside a program unit.  It must be specified in the 
program unit.
.ME
$
$ Error : 0796
$msg  0796 The specified SAFEVL= value on the IVDEP directive must be a scalar integer constant in the range 1 to 1024.
$nexp 0796
Error : The specified SAFEVL= value on the IVDEP directive must be a scalar integer constant in the range 1 to 1024.
.PP
A safe vector length for the \*CIVDEP\fR compiler directive must be a scalar
integer constant expression so that the compiler can evaluate it at
compile time.  The constant value must be in the range 1 to 1024.
.ME
$
$ Log_Warning : 0797
$msg  0797 The command line has an unsupported option "%c".
$nexp 0797
Log_Warning : The command line has an unsupported option "%c".
.PP
This command-line option is not supported on this hardware.  The option
is ignored.
.ME
$
$ Error : 0798
$msg  0798 Unexpected parameter or work distribution for the DO ALL directive.
$nexp 0798
Error : Unexpected parameter or work distribution for the DO ALL directive.
.PP
The \*CDO ALL\fR directive allows the following parameters and work distributions:
.CS
  IF(expr)
  SHARED(variable_list)
  PRIVATE(variable_list)
  AUTOSCOPE
  CONTROL(variable_list)
  SAVELAST
  MAXCPUS(n)

  SINGLE
  CHUNKSIZE(n)
  NUMCHUNKS(m)
  GUIDED [vl]
  VECTOR
.CE
.ME
$
$ Ansi : 0799
$msg  0799 The use of "%s" as a continuation character is an extension to the Fortran standard.
$nexp 0799
Ansi : The use of "%s" as a continuation character is an extension to the Fortran standard.
.PP
The use of a character that is not in the Fortran character set is
allowed as a continuation line indicator in fixed source form.
This is an extension to the Fortran standard.
.ME
$
$ Error : 0800
$msg  0800 Only one work distribution must be specified on a DO ALL directive.
$nexp 0800
Error : Only one work distribution must be specified on a DO ALL directive.
.PP
More than one work distribution is illegal on a \*CDO ALL\fR directive.
.ME
$
$ Warning : 0801
$msg  0801 Unsupported compiler directive.
$nexp 0801
Warning : Unsupported compiler directive.
.PP
The compiler encountered a compiler directive that is recognized but
not supported. This occurs because the compiler directive is not relevant to 
supported hardware or because support for the compiler directive is deferred
until a future release.
.ME
$
$ Error : 0802
$msg  0802 Variable subobjects are not allowed as arguments for this parameter of a tasking compiler directive.
$nexp 0802
Error : Variable subobjects are not allowed as arguments for this parameter of a tasking compiler directive.
.PP
When a tasking compiler directive defines scope or context for a parallel
region, it must be for whole variables, not variable subobjects.  The 
following code fragment is not allowed.
.CS
      TYPE X
         INTEGER I
      ENDTYPE 

      TYPE(X) :: K

CMIC$ DO ALL SHARED(K%I)
.CE
.ME
$
$ Error : 0803
$msg  0803 The expression for the tasking directive parameter IF must be a scalar logical expression.
$nexp 0803
Error : The expression for the tasking directive parameter IF must be a scalar logical expression.
.PP
The \*CIF\fR parameter for the tasking compiler directives \*CDO ALL\fR and \*CPARALLEL\fR
requires a scalar logical expression.
.ME
$
$ Caution : 0804
$msg  0804 "%s" is not a variable and will be ignored in the %s list of this %s directive.
$nexp 0804
Caution : "%s" is not a variable and will be ignored in the %s list of this %s directive.
.PP
An object other than a variable is in a \*CSHARED\fR, \*CPRIVATE\fR, or \*CCONTROL\fR list
on a tasking compiler directive statement.  It is ignored.

.ME
$
$ Error : 0805
$msg  0805 Object "%s" is declared both SHARED and PRIVATE.
$nexp 0805
Error : Object "%s" is declared both SHARED and PRIVATE.
.PP
On a tasking directive statement, a variable is listed in both the \*CPRIVATE\fR
and \*CSHARED\fR variable lists.
.ME
$
$ Error : 0806
$msg  0806 This argument on a tasking directive must be a scalar integer expression.
$nexp 0806
Error : This argument on a tasking directive must be a scalar integer expression.
.PP
The arguments to the \*CMAXCPUS\fR, \*CCHUNKSIZE\fR, \*CNUMCHUNKS\fR, or \*CGUIDED\fR parameters or
work distributions on a tasking directive must be scalar integer expressions.
.ME
$
$ Error : 0807
$msg  0807 The SHAPE argument must be a constant size rank one array with 7 or less elements.
$nexp 0807
Error : The SHAPE argument must be a constant size rank one array with 7 or less elements.
.PP
The \*CSHAPE\fR argument to the \*CRESHAPE\fR intrinsic function must be an array of rank
one and must not have more than 7 elements.
.ME
$
$ Error : 0808
$msg  0808 Unexpected work distribution for the DO PARALLEL directive.
$nexp 0808
Error : Unexpected work distribution for the DO PARALLEL directive.
.PP
Th following are the allowed work distributions for the \*CDO PARALLEL\fR compiler
directive:
.CS
  SINGLE
  CHUNKSIZE(n)
  NUMCHUNKS(m)
  GUIDED [vl]
  VECTOR
.CE
.ME
$
$ Error : 0809
$msg  0809 Unexpected parameter for the PARALLEL compiler directive.
$nexp 0809
Error : Unexpected parameter for the PARALLEL compiler directive.
.PP
The following are the allowed parameters for the \*CPARALLEL\fR directive.
.CS
  IF(expr)
  SHARED(variable_list)
  PRIVATE(variable_list)
  AUTOSCOPE
  CONTROL(variable_list)
  SAVELAST
  MAXCPUS(n)
.CE
.ME
$
$ Internal : 0810
$msg  0810 "%s" has a bad linear type.
$nexp 0810
Internal : "%s" has a bad linear type.
.PP
The linear type for the given object is Err_Res.  This needs to be set to the
correct linear type so that storage can be assigned.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0811
$msg  0811 The case-value expression must be an initialization expression.
$nexp 0811
Error : The case-value expression must be an initialization expression.
.PP
In a \*CCASE\fR statement of the form:
.CS
     \*CCASE (\fIcase_value_range_list\*C)
.CE
\fIcase_value_range\fR must have one of the following forms:

.nf
    \fIcase_value\fR
    \fIcase_value\*C:\fR
    \*C:\fIcase_value\fR
    \fIcase_value\*C:\fIcase_value
.fi
.PP
\fREach \fIcase_value\fR must be a scalar integer, character, or logical initialization
expression.  The \fIcase_value\fR must also be of the same type as the expression in
the corresponding \*CSELECT CASE\fR statement.  A character or logical initialization
expression is the same as a character or logical constant expression.  An
integer initialization expression is an integer constant expression in which
the exponentiation operation is permitted only with an integer power.
.ME
$
$ Error : 0812
$msg  0812 This ENDCASE autotasking directive has no matching CASE directive.
$nexp 0812
Error : This ENDCASE autotasking directive has no matching CASE directive.
.PP
An \*CENDCASE\fR directive can only be used to close a set of concurrent regions
delimited by \*CCASE\fR directives.
.ME
$
$ Error : 0813
$msg  0813 This END DO directive has no matching DO PARALLEL directive.
$nexp 0813
Error : This END DO directive has no matching DO PARALLEL directive.
.PP
An \*CEND DO\fR autotasking directive can only be used after a \*CDO PARALLEL\fR
directive.  The error could be caused by the two directives being placed
in separate parallel regions.
.ME
$
$ Error : 0814
$msg  0814 This DO ALL autotasking directive is already within a parallel region.
$nexp 0814
Error : This DO ALL autotasking directive is already within a parallel region.
.PP
The \*CDO ALL\fR directive creates a parallel region that is the body of the
next \*CDO\fR loop.  It cannot be used within another parallel region.
.ME
$
$ Error : 0815
$msg  0815 Unexpected nesting or overlap of GUARD regions.
$nexp 0815
Error : Unexpected nesting or overlap of GUARD regions.
.PP
Regions protected by a \*CGUARD/ENDGUARD\fR directive pair must not overlap or
be nested.  This message will be issued if two or more \*CGUARD\fR directives
are encountered before an \*CENDGUARD\fR.
.ME
$
$ Error : 0816
$msg  0816 Matching GUARD/ENDGUARD directives must both have the same flag argument or have no argument.
$nexp 0816
Error : Matching GUARD/ENDGUARD directives must both have the same flag argument or have no argument.
.PP
If a mutual exclusion flag is supplied on a \*CGUARD\fR or \*CENDGUARD\fR autotasking
directive, the same value must be specified for the matching directive.
.ME
$
$ Error : 0817
$msg  0817 This ENDGUARD directive has no matching GUARD directive.
$nexp 0817
Error : This ENDGUARD directive has no matching GUARD directive.
.PP
An \*CENDGUARD\fR autotasking directive was encountered without a matching \*CGUARD\fR
directive.
.ME
$
$ Error : 0818
$msg  0818 The PARALLEL directive must not be used within another parallel region.
$nexp 0818
Error : The PARALLEL directive must not be used within another parallel region.
.PP
The \*CPARALLEL\fR autotasking directive, which marks the entry of a parallel
region, must not be used within another parallel region.
.ME
$
$ Error : 0819
$msg  0819 This END PARALLEL directive has no matching PARALLEL directive.
$nexp 0819
Error : This END PARALLEL directive has no matching PARALLEL directive.
.PP
The \*CEND PARALLEL\fR autotasking directive must only be used after a \*CPARALLEL\fR
directive within the same scoping unit.
.ME
$
$ Error : 0820
$msg  0820 An END CASE directive was expected before the end of the previous parallel region.
$nexp 0820
Error : An END CASE directive was expected before the end of the previous parallel region.
.PP
An \*CEND PARALLEL\fR autotasking directive was encountered which ended a parallel
region. There were \*CCASE\fR directives within this region but no closing 
\*CEND CASE\fR directive.
.ME
$
$ Error : 0821
$msg  0821 A call to an internal procedure is illegal within a parallel region.
$nexp 0821
Error : A call to an internal procedure is illegal within a parallel region.
.PP
A call to an internal function or subroutine cannot be made from within
a parallel region. This includes regions bounded by \*CPARALLEL/ENDPARALLEL\fR
directives or from within the body of a \*CDO ALL\fR loop. 
.ME
$
$ Error : 0822
$msg  0822 An "%s" autotasking directive was expected.
$nexp 0822
Error : An "%s" autotasking directive was expected.
.PP
All parallel and guarded regions must be terminated before entering
or terminating a scope. If a \*CCONTAINS\fR statement or \*CEND\fR, \*CEND FUNCTION\fR, or 
\*CEND SUBROUTINE\fR statement is encountered while in a parallel region or guarded
region, an error is issued.
.ME
$
$ Error : 0823
$msg  0823 Two different common blocks, "%s" and "%s", are equivalenced together.   
$nexp 0823
Error : Two different common blocks, "%s" and "%s", are equivalenced together.   
.PP
Through an \*CEQUIVALENCE\fR statement the user has tried to overlay two different
common blocks.  This is illegal.  For example:
.CS
       PROGRAM BAD
       COMMON /ONE/ A,B,C
       COMMON /TWO/ D,E,F

       EQUIVALENCE(A,D) ! Illegal
       END
.CE
.ME
$
$ Internal : 0824
$msg  0824 The pdgcs symbol table index for attribute index %d ("%s") is 0.  This must be a valid index.
$nexp 0824
Internal : The pdgcs symbol table index for attribute index %d ("%s") is 0.  This must be a valid index.
.PP
A call is being made to the PDGCS interface, which requires a valid PDGCS 
symbol table index as one of its arguments.  This must be a valid index, but
the compiler detected a NULL index.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Warning : 0825
$msg  0825 The object being initialized is not a member of any common block declared in this block data program unit.
$nexp 0825
Warning : The object being initialized is not a member of any common block declared in this block data program unit.
.PP
A block data program unit is used to provide initial values for data objects
in named common blocks.  By extension, objects in blank common may also be 
initialized in a block data program unit.
.PP
The object being initialized is not a member of any common block (named or 
blank) declared in the block data program unit being compiled.  The object's
initialization will have no effect outside of the block data subprogram,
because the object is not a member of a common block.  The initialization 
should be removed or the item should be made a member of a (preferably named)
common block.
.ME
$
$ Error : 0826
$msg  0826 Two different objects, "%s" and "%s", in the same common block are equivalenced together.
$nexp 0826
Error : Two different objects, "%s" and "%s", in the same common block are equivalenced together.
.PP
Two different objects within the same common
block must not be overlayed such that it would
change the storage sequence of the common block.  Example:
.CS
     PROGRAM BAD
     COMMON // A,B,C
     EQUIVALENCE (A,C)  ! This is illegal
     END
.CE
.ME
$
$ Error : 0827
$msg  0827 "%s" is used in an expression, before it is typed via an implicit or type statement, so the type is assumed to be %s.
$nexp 0827
Error : "%s" is used in an expression, before it is typed via an implicit or type statement, so the type is assumed to be %s.
.PP
When an object is used in an expression, it is implicitly typed if it is the
first reference to this object.  The object can subsequently be typed in a
type declaration statement only if it confirms the type.
.PP
Example:
.CS
     DIMENSION ARRAY(K)
     REAL K          \fR! Illegal 
.CE
.PP
\*CK\fR can only be typed integer, because that is what it is implicitly typed as in 
the \*CDIMENSION\fR 
statement.
Also, if an object is referenced before an implicit statement that would reset
its type, its original implicit type remains.
.ME
$
$ Internal : 0828
$msg  0828 Unsupported operator in folder_driver.
$nexp 0828
Internal : Unsupported operator in folder_driver.
.PP
Internal compiler error. The driver for the expression folder was
called with an invalid operator.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 0829
$msg  0829 All ac-value expressions in an array constructor must have the same type and type parameters.
$nexp 0829
Error : All ac-value expressions in an array constructor must have the same type and type parameters.
.PP
An element of an array constructor was encountered that had a different
type or kind type than the rest of the elements.
.ME
$
$ Error : 0830
$msg  0830 There must be only one or zero arguments present when calling this intrinsic.
$nexp 0830
Error : There must be only one or zero arguments present when calling this intrinsic.
.PP
There must be only one or zero arguments present when calling this 
particular intrinsic procedure.
.ME
$
$ Error : 0831
$msg  0831 The value of this subscript is less than the declared lower bound.
$nexp 0831
Error : The value of this subscript is less than the declared lower bound.
.PP
A subscript value must be greater than or equal to the declared lower bound of
the corresponding dimension.
.ME
$
$ Internal : 0832
$msg  0832 The compiler has detected a local name table following the scope for "%s".
$nexp 0832
Internal : The compiler has detected a local name table following the scope for "%s".
.PP
When use_stmt_semantics is being executed, it assumes that it is the current
scope being worked on and that the local name table is being created at
the end of the local name table.  The compiler detected another scope's
local name table entries following this scopes local name table entries.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0833
$msg  0833 The argument to this intrinsic must be an allocatable array.
$nexp 0833
Error : The argument to this intrinsic must be an allocatable array.
.PP
The actual argument to this intrinsic procedure must be an allocatable array.
.ME
$
$ Error : 0834
$msg  0834 The shape of the initialization expression value does not match that of named constant "%s".
$nexp 0834
Error : The shape of the initialization expression value does not match that of named constant "%s".
.PP
The shape of the initialization expression result value must match the shape of
the corresponding named constant.
.ME
$
$ Error : 0835
$msg  0835 The initialization of scalar named constant "%s" with an array-valued expression is not valid.
$nexp 0835
Error : The initialization of scalar named constant "%s" with an array-valued expression is not valid.
.PP
A scalar named constant must only be given a scalar value.
.ME
$
$ Internal : 0836
$msg  0836 Compiler tmp "%s" does not have a storage block assigned to it.
$nexp 0836
Internal : Compiler tmp "%s" does not have a storage block assigned to it.
.PP
All compiler tmps must have a storage block assigned to them when they are
created.  The compiler detected a compiler tmp without a storage block
at the end of pass2 semantics during storage offset assignment.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0837
$msg  0837 An implied-DO variable that is not scalar is an extension to the Fortran standard.
$nexp 0837
Ansi : An implied-DO variable that is not scalar is an extension to the Fortran standard.
.PP
An implied-\*CDO\fR list in a \*CDATA\fR statement or in an array constructor contains an
implied-\*CDO\fR loop control variable that is not scalar.
.PP   
The \*CDATA\fR statement implied-\*CDO\fR has the form:
.CS
   (\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C =
        \fIscalar_int_expr\*C, \fIscalar_int_expr\*C 
	[, \fIscalar_int_expr\*C])
.CE
.PP   
The array constructor implied-\*CDO\fR has the form:
.CS
   (\fIac_value_list\*C, \fIac_do_variable\*C =
        \fI scalar_int_expr\*C, \fIscalar_int_expr\*C 
        [, \fIscalar_int_expr\*C])
.CE
.PP
A correction to the Fortran standard as a response to an interpretation 
request expands on the rules for implied-\*CDO\fR loop control variables that are
statement entities (the I/O implied-\*CDO\fR variable is not a statement entity).
Essentially, it states that a statement entity can have the same name as a 
common block name or an integer scalar variable in the scoping unit containing
the \*CDATA\fR statement or array constructor.  Therefore, a
statement entity cannot have the same name as an external procedure, an
internal procedure, a module procedure, a named constant, a construct name,
a generic name, a derived type name, an array, and so on.  Also, because it must
be type integer, it cannot have the same name as an entity declared to be of a 
type other than integer.
.PP
This Fortran compiler extends the standard by allowing a 
\fIdata_i_do_variable\fR or \fIac_do_variable\fR to have the same name as an integer array.
.ME
$
$ Ansi : 0838
$msg  0838 In Fortran 95, array constructor values of type character must all have the same length.
$nexp 0838
Ansi : In Fortran 95, array constructor values of type character must all have the same length.
.PP
Array constructor values must all possess the same type and
type parameters.  This includes the character length. Fortran 2003 relaxes the
restriction if an explicit type-spec appears at the beginning of the list of
values inside the brackets.
.ME
$
$ Internal : 0839
$msg  0839 The assumed-length character bounds entry from decl_semantics is not valid.
$nexp 0839
Internal : The assumed-length character bounds entry from decl_semantics is not valid.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0840
$msg  0840 "%s" is substringed but not declared type character, or the object is subscripted but not dimensioned.
$nexp 0840
Error : "%s" is substringed but not declared type character, or the object is subscripted but not dimensioned.
.PP
The user tried to equivalence an incorrectly declared variable.  A substringed
object must be type character and a subscripted object must be an array.
.ME
$
$ Error : 0841
$msg  0841 The start value of the section subscript triplet is less than the declared lower bound.
$nexp 0841
Error : The start value of the section subscript triplet is less than the declared lower bound.
.PP
In a section subscript that is a triplet subscript, the start value must be 
greater than or equal to the declared lower bound of the array.  For example,
if an array is declared as follows:
.CS
      INTEGER  array(10)
.CE
the start value of a section subscript triplet referencing \*CARRAY\fR must be 
equal to or greater than 1.
.ME
$
$ Error : 0842
$msg  0842 The initialization expression used on a type declaration statement must be a constant expression.
$nexp 0842
Error : The initialization expression used on a type declaration statement must be a constant expression.
.PP
The expression used to initialize a data object on a type declaration
statement must evaluate to a constant value.
.ME
$
$ Error : 0843
$msg  0843 The data type of object "%s" is %s and is incompatable with data type %s in this initialization assignment.
$nexp 0843
Error : The data type of object "%s" is %s and is incompatable with data type %s in this initialization assignment.
.PP
The variable becomes defined with the value determined from the
initialization expression.  This must meet the rules of intrinsic assignment
as defined in the Fortran standard.  The type of the specified 
variable and the type of the value do not meet the rules of intrinsic
assignment.

.ME
$
$ Error : 0844
$msg  0844 The initialization of scalar variable "%s" with an array-valued expression is not valid.
$nexp 0844
Error : The initialization of scalar variable "%s" with an array-valued expression is not valid.
.PP
A scalar variable must only be given a scalar value.
.ME
$
$ Error : 0845
$msg  0845 The shape of the initialization expression does not match that of variable "%s".
$nexp 0845
Error : The shape of the initialization expression does not match that of variable "%s".
.PP
The shape of the initialization expression must match the shape of the
corresponding variable.
.ME
$
$ Internal : 0846
$msg  0846 Storage block "%s" should be in the storage block table for the local scope, but is not.
$nexp 0846
Internal : Storage block "%s" should be in the storage block table for the local scope, but is not.
.PP
During conversion to PDGCS, send_stor_blk found a host associated static
storage block, that does not have a storage block in the local scope.  All of
these host associated storage blocks should have been entered into the local
storage block during attr_link_resolution.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0847
$msg  0847 "%s" does not have a storage block.
$nexp 0847
Internal : "%s" does not have a storage block.
.PP
Every non-constant data object should have a storage block assigned to it.
If this is an interface block, the storage block must be assigned by the
end of decl_semantics.  If this is not an interface block, a storage block
must be assigned by the time the object is sent thru the interface to PDG.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0848
$msg  0848 Dummy argument "%s" is longer than the actual argument.
$nexp 0848
Error : Dummy argument "%s" is longer than the actual argument.
.PP
A statement function is being referenced with an actual argument of type
character whose length is shorter than that of its associated dummy argument
in the statement function definition.  Actual arguments of type character
must have a length that is greater than or equal to that of the associated
dummy argument.
.ME
$
$ Error : 0849
$msg  0849 The start value of the section subscript triplet is greater than the declared upper bound.
$nexp 0849
Error : The start value of the section subscript triplet is greater than the declared upper bound.
.PP
In a section subscript that is a triplet subscript, the start value must be 
less than or equal to the declared upper bound of the array.  For example,
if an array is declared as follows:
.CS
      INTEGER  array(10)
.CE
the start value of a section subscript triplet referencing \*CARRAY\fR must be 
equal to or less than 10.
.ME
$
$ Internal : 0850
$msg  0850 "%s" is host associated and on the stack, but it is not in a host associated stack storage block.
$nexp 0850
Internal : "%s" is host associated and on the stack, but it is not in a host associated stack storage block.
.PP
During final_decl_semantics, the compiler found an object that is host
associated, but is not in a host associated storage block.  All host 
associated stack variables, must be in a host associated stack storage block.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0851
$msg  0851 A task common block member must not be data initialized.
$nexp 0851
Error : A task common block member must not be data initialized.
.PP
The indicated object is declared to be a member of a \*CTASK COMMON\fR 
block; therefore it must not be initialized.
.ME
$
$ Internal : 0852
$msg  0852 Host associated object "%s" must be referenced or defined by a contained procedure.
$nexp 0852
Internal : Host associated object "%s" must be referenced or defined by a contained procedure.
.PP
During conversion to PDGCS, a host associated dummy argument or variable has
been found that does not have the AT_REF_IN_CHILD or AT_DEF_IN_CHILD flag set.
To be host associated, an object must be referenced or defined by a
contained procedure.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0853
$msg  0853 The target must have the same character length as the pointer in a pointer assignment statement.
$nexp 0853
Error : The target must have the same character length as the pointer in a pointer assignment statement.
.PP
The type parameters of the target and the pointer used in a pointer assignment
statement must agree.  That includes the character length if the types of
the target and pointer are character.  This also applies to a structure 
constructor expression that corresponds to a pointer component.
.ME
$
$ Error : 0854
$msg  0854 The compiler cannot open file "%s", which may contain information about the used module "%s".
$nexp 0854
Error : The compiler cannot open file "%s", which may contain information about the used module "%s".
.PP
The compiler cannot open the specified module file for \*CUSE\fR statement processing.
Check permissions for the file and for the directory.  
If this is a non-Cray Research system, the compiler may be attempting to open 
a \*C.M\fR file.
This file was specified on the command line as \*C-p x.o\fR.
.ME
$
$ Error : 0855
$msg  0855 The compiler has detected errors in module "%s".  No module information file will be created for this module.
$nexp 0855
Error : The compiler has detected errors in module "%s".  No module information file will be created for this module.
.PP
The compiler detected errors in the module; therefore, no module information file
will be created for this module.  Errors can cause the information in
the module information file to be unreliable.
.ME
$
$ Error : 0856
$msg  0856 DO loop iteration count exceeds the compiler limit of %d iterations.
$nexp 0856
Error : DO loop iteration count exceeds the compiler limit of %d iterations.
.PP
A \*CDO\fR statement specifies an iteration count (number of times through the loop)
that exceeds the maximum allowed for the target machine.  
.PP
For the following statement, the iteration is calculated to be
(\fIend\*C - \fIstart\*C + \fIinc\*C) / \fIinc
.CS
  DO [label] [,] do_variable = start, end [, inc]
.CE
.ME
$
$ Internal : 0857
$msg  0857 DO loop iteration count calculation failed.
$nexp 0857
Internal : DO loop iteration count calculation failed.
.PP
The compiler is trying to calculate the iteration count for a \*CDO\fR loop
or implied-\*CDO\fR at compile time (when the start, end, and increment values
are all constants or all constant expressions).
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0858
$msg  0858 An object with the SAVE attribute must not be equivalenced to an object in a common block.
$nexp 0858
Error : An object with the SAVE attribute must not be equivalenced to an object in a common block.
.PP
The user tried to equivalence a saved object to a common block.
.ME
$
$ Error : 0859
$msg  0859 A variable subobject is not valid on a SUPPRESS directive.
$nexp 0859
Error : A variable subobject is not valid on a SUPPRESS directive.
.PP
Only variable names are allowed on \*CSUPPRESS\fR directives.  Structure
components, array elements or sections and character substrings are
not allowed.
.ME
$
$ Error : 0860
$msg  0860 The intrinsic "%s" cannot be passed as an actual argument.
$nexp 0860
Error : The intrinsic "%s" cannot be passed as an actual argument.
.PP
This intrinsic procedure name cannot be in an actual argument list.
.ME
$
$ Internal : 0861
$msg  0861 Bad IR in %s.
$nexp 0861
Internal : Bad IR in %s.
.PP
Improperly formed internal text.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0862
$msg  0862 The storage order of object "%s" has been altered through equivalencing.
$nexp 0862
Error : The storage order of object "%s" has been altered through equivalencing.
.PP
By equivalencing an object in a certain way the user changed the
storage order of the object.  For example:
.CS
 DIMENSION IA(10)
 COMMON /AA/ A,B,C,D,E,F,G,H,I,J,K
 EQUIVALENCE (IA(1), A)
 EQUIVALENCE (IA(2), C) \fR! Illegal; changes order of \*CIA
 END
.CE
.PP
.ME
$
$ Error : 0863
$msg  0863 "%s" has been referenced in the function character length expression, therefore it must not be declared as a "%s".
$nexp 0863
Error : "%s" has been referenced in the function character length expression, therefore it must not be declared as a "%s".
.PP
The compiler detected a conflict between a use and a declaration for an object.
The
object being declared was referenced in the function character length
expression, which prohibits it from being declared as any of the following
items:
.PP
.nf   
        Cray pointer
        Cray pointee
        Cray character pointee
        function result
        derived type
        namelist group
        construct name
        alternate function entry
        subroutine
.fi
.ME
$
$ Error : 0864
$msg  0864 "%s" has been referenced in the function character length expression, so it must not be a subroutine.
$nexp 0864
Error : "%s" has been referenced in the function character length expression, so it must not be a subroutine.
.PP
The object is referenced in the function character length expression,
which prohibits it from being a subroutine in an interface block or from
being used as a subroutine.
.ME
$
$ Log_Warning : 0865
$msg  0865 Inline option conflict detected.  Non-automatic mode selected.
$nexp 0865
Log_Warning : Inline option conflict detected.  Non-automatic mode selected.
.PP
This message is issued when both \*C-O inline[0-3]\fR and \*C-I filename\fR are
specified on the command line.  Nonautomatic inlining is selected.
.ME
$
$ Error : 0866
$msg  0866 The function character length expression references "%s", therefore it must not be used as a derived-type name.
$nexp 0866
Error : The function character length expression references "%s", therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict between uses of this object.  The
object being declared is referenced in the function character length
expression, which prohibits it from being used as a derived-type name.
.ME
$
$ Warning : 0867
$msg  0867 Module "%s" has no public objects declared in the module, therefore nothing can be use associated from the module.
$nexp 0867
Warning : Module "%s" has no public objects declared in the module, therefore nothing can be use associated from the module.
.PP
The module specified on the \*CUSE\fR statement is apparently empty.  This can be caused by one of
several reasons:
.BL
The module contains no declarations in its specification part.
.BL
Everything in the module is declared private.
.BL
The module has compilation errors.
.ME
$
$ Error : 0868
$msg  0868 "%s" is used in a constant expression, therefore it must be a constant.
$nexp 0868
Error : "%s" is used in a constant expression, therefore it must be a constant.
.PP
This expression must be a constant initialization expression.
Every identifier referenced in this expression must be declared to be a constant before 
this expression.
.ME
$
$ Error : 0869
$msg  0869 "%s" has been typed, but the intrinsic procedure with the same name is a subroutine and subroutines cannot be typed.
$nexp 0869
Error : "%s" has been typed, but the intrinsic procedure with the same name is a subroutine and subroutines cannot be typed.
.PP
The name specified with the \*CINTRINSIC\fR attribute is an intrinsic subroutine.
A subroutine must not be typed.  Example:
.CS
  REAL, INTRINSIC :: DATE_AND_TIME
.CE

\*CDATE_AND_TIME\fR is an intrinsic subroutine.  A subroutine must not be typed,
so this is not a valid statement.
.ME
$
$ Error : 0870
$msg  0870 The intrinsic call "%s" is not valid in a specification expression.
$nexp 0870
Error : The intrinsic call "%s" is not valid in a specification expression.
.PP
The specification expression contains a reference to an intrinsic function
that is not allowed in a specification expression.  The
intrinsic function must have a scalar integer result.
.ME
$
$ Internal : 0871
$msg  0871 Field "%s" for statement header %d indexes to itself.
$nexp 0871
Internal : Field "%s" for statement header %d indexes to itself.
.PP
Something is wrong with the statement header linkage.  The specified statement
header indexes to itself via the SH_NEXT_IDX field or the SH_PREV_IDX field.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0872
$msg  0872 The implied-do-object-list is missing for this implied-DO.
$nexp 0872
Error : The implied-do-object-list is missing for this implied-DO.
.PP
An implied-\*CDO\fR was encountered within an array constructor or in
an I/O list and it did not have an object list.  The following is
an example of an implied-\*CDO\fR that is not allowed.
.CS
   PRINT *, (I=1,10)
.CE
.ME
$
$ Internal : 0873
$msg  0873 The length tmp "%s" (%d) can only have one statement associated with it.  This one has multiple statement headers.
$nexp 0873
Internal : The length tmp "%s" (%d) can only have one statement associated with it.  This one has multiple statement headers.
.PP
This message is issued from insert_sh_after_entries.  The compiler is
attempting to change a length bound to length = 0, but the length bound has
multiple statement headers.  This should not happen.  Only the actual bound
entries can have multiple statement headers.  Lengths and extents should only
be one statement in length.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0874
$msg  0874 The argument to the compiler directive ID must be a character literal.
$nexp 0874
Error : The argument to the compiler directive ID must be a character literal.
.PP
Something other than a character literal constant was encountered on
a \*C!DIR$ ID\fR line.
.ME
$
$ Error : 0875
$msg  0875 This actual argument must not be an optional dummy argument.
$nexp 0875
Error : This actual argument must not be an optional dummy argument.
.PP
The particular actual argument must not be an optional dummy argument in this
context.
.ME
$
$ Error : 0876
$msg  0876 "%s" has the AUXILIARY attribute and is in the specification part of a module, therefore it must be in a common block.
$nexp 0876
Error : "%s" has the AUXILIARY attribute and is in the specification part of a module, therefore it must be in a common block.
.PP
The \*CAUXILIARY\fR attribute is an extension to the Fortran 
standard.  Auxiliary storage blocks can be specified in the specification part
of a module only if these storage blocks are common blocks.
.ME
$
$ Log_Warning : 0877
$msg  0877 The -u options are ignored because this is not a DEBUG version of the compiler.
$nexp 0877
Log_Warning : The -u options are ignored because this is not a DEBUG version of the compiler.
.PP
The \*C-u\fR options are used to debug the compiler and are only available with a
\*CDEBUG\fR compiler.  These are undocumented options used for compiler
development and testing.
.ME
$
$ Caution : 0878
$msg  0878 A module named "%s" has already been directly or indirectly use associated into this scope.
$nexp 0878
Caution : A module named "%s" has already been directly or indirectly use associated into this scope.
.PP
A module name is a global name and by definition,
all global names must be unique.  The compiler detected more than one 
module with the same name in this scope and assumes that they are the same
module.  This can happen because a module can be directly or indirectly use
associated into a scoping unit.  An example would be:
.CS
   MODULE ABC
   INTEGER I
   END MODULE

   MODULE CDE
   USE ABC
   END MODULE

   PROGRAM BBB
   USE CDE
   USE ABC  ! ABC is already in this scope via CDE
   END MODULE
.CE
.ME
$
$ Error : 0879
$msg  0879 The bloc or eloc variables must not be of derived type in a BUFFER I/O statement.
$nexp 0879
Error : The bloc or eloc variables must not be of derived type in a BUFFER I/O statement.
.PP
Because the I/O libraries must do implicit type conversion in \*CBUFFER IN\fR
and \*CBUFFER OUT\fR operations, begin (\fIbloc\fR) and end (\fIeloc\fR)
variables of derived type are not supported.
.CS
      BUFFERIN (id,m) (bloc,eloc)
      BUFFEROUT (id,m) (bloc,eloc)
.CE
.ME
$
$ Error : 0880
$msg  0880 Operator "%s" is not intrinsic.  All operations in a specification expression must be intrinsic.
$nexp 0880
Error : Operator "%s" is not intrinsic.  All operations in a specification expression must be intrinsic.
.PP
All operations in a specification expression must be intrinsic operations.  The
specification expression must not contain defined operators or overloaded
operators.
.ME
$
$ Error : 0881
$msg  0881 The value of DIM must be:  1 <= DIM <= (rank of MASK).
$nexp 0881
Error : The value of DIM must be:  1 <= DIM <= (rank of MASK).
.PP
The value of the \*CDIM\fR argument must be >= 1 or <= the rank of \*CMASK\fR.
.ME
$
$ Error : 0882
$msg  0882 Derived type "%s" has private components, which means component name "%s" must not be referenced.
$nexp 0882
Error : Derived type "%s" has private components, which means component name "%s" must not be referenced.
.PP
When a derived type is declared in a module, the components must be declared to
be private.  This means that any procedure use associating this derived type
does not have access to the component names or the internal structure of the
derived type.
.ME
$
$ Error : 0883
$msg  0883 Derived type "%s" has private components, therefore a structure constructor must not be defined for this type.
$nexp 0883
Error : Derived type "%s" has private components, therefore a structure constructor must not be defined for this type.
.PP
When a derived type is declared in a module, the components must be declared to
be private.  This means that any procedure use associating this derived type
does not have access to the component names or the internal structure of the
derived type.  Structure constructors of the derived type must not be used,
because the internal structure of the derived type is unknown.
.ME
$
$ Internal : 0884
$msg  0884 Verify_interface has found a bad dummy argument "%s" in the dummy argument list for procedure "%s".
$nexp 0884
Internal : Verify_interface has found a bad dummy argument "%s" in the dummy argument list for procedure "%s".
.PP
Verify_interface expects all dummy arguments to be Data_Objs or Pgm_Units.  It
found something else in the list.  This replaces the printf that said
"dummy not data or pgm in verify_interface."
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Log_Warning : 0885
$msg  0885 Inlining is a deferred implementation.
$nexp 0885
Log_Warning : Inlining is a deferred implementation.
.PP
Inlining will be implemented in a future release.
.ME
$
$ Log_Warning : 0886
$msg  0886 Implementation of the -G %d debugging level is deferred.
$nexp 0886
Log_Warning : Implementation of the -G %d debugging level is deferred.
.PP
The \*C-G 2\fR and \*C-G 3\fR debugging level options will be implememented in a future release.
.ME
$
$ Log_Warning : 0887
$msg  0887 The %s optimization level should be %d since the debugging level is %d.
$nexp 0887
Log_Warning : The %s optimization level should be %d since the debugging level is %d.
.PP
The optimization level is set too high for the debug level.  Lower the
optimization level using the \*C-O\fR command-line option.
.ME
$
$ Error : 0888
$msg  0888 The BOUNDARY argument must be present if the ARRAY argument is of derived type.
$nexp 0888
Error : The BOUNDARY argument must be present if the ARRAY argument is of derived type.
.PP
The \*CBOUNDARY\fR argument must be present if \*CARRAY\fR is of derived type.
.ME
$
$ Error : 0889
$msg  0889 The upper bound or extent of an assumed-size array must not be requested.
$nexp 0889
Error : The upper bound or extent of an assumed-size array must not be requested.
.PP
Requesting the upper bound or extent of the last dimension of 
an assumed-size array is not allowed.
.ME
$
$ Error : 0890
$msg  0890 "%s" is a dummy argument with INTENT(IN), therefore it must not be defined.
$nexp 0890
Error : "%s" is a dummy argument with INTENT(IN), therefore it must not be defined.
.PP
When a dummy argument is specified with \*CINTENT(IN)\fR, neither it nor any of
its subobjects can be defined. 
.ME
$
$ Internal : 0891
$msg  0891 Attribute %d (%s) has no TYPE.  It should because it is a Data_Obj.
$nexp 0891
Internal : Attribute %d (%s) has no TYPE.  It should because it is a Data_Obj.
.PP
Every Data_Obj should have a type.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0892
$msg  0892 The H edit descriptor is an obsolescent/deleted feature.
$nexp 0892
Ansi : The H edit descriptor is an obsolescent/deleted feature.
.PP
This feature was deleted in the Fortran 95 standard. The compiler supports
it as an extension.
.PP
Instead of using the \*CH\fR edit descriptor, the Fortran standard recommends
using the character constant edit descriptor.
.ME
$
$ Internal : 0893
$msg  0893 Fields %s and %s for %s entry %d must both be set to a legal value.  One field is set and the other is clear.
$nexp 0893
Internal : Fields %s and %s for %s entry %d must both be set to a legal value.  One field is set and the other is clear.
.PP
There are table index fields in the symbol tables that are dependent on 
field descriptors, so that we know which table the index is for.  The
detected an index with a Null_Idx field descriptor.
Related fields are  
.CS
  ATD_FLD	ATD_CONST_IDX
  ATD_FLD	ATD_TMP_IDX
  BD_LEN_FLD	BD_LEN_IDX
  BD_LB_FLD	BD_LB_IDX
  BD_UB_FLD	BD_UB_IDX
  BD_XT_FLD	BD_XT_IDX
  BD_SM_FLD	BD_SM_IDX
.CE
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0894
$msg  0894 Module "%s" has compile errors, therefore declarations obtained from the module via the USE statement may be incomplete.
$nexp 0894
Error : Module "%s" has compile errors, therefore declarations obtained from the module via the USE statement may be incomplete.
.PP
The specified module is in this compilation unit, but it has compile time 
errors.  Declarations obtained from this module may not be valid.
Recompile the module and the procedure that references the module.
.ME
$
$ Internal : 0895
$msg  0895 Intrinsic operator encountered in constant constructor that has no folder.
$nexp 0895
Internal : Intrinsic operator encountered in constant constructor that has no folder.
.PP
No folder exists for this intrinsic but
it is in a constant constructor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0896
$msg  0896 The data item length must be equal for bloc and eloc in a BUFFER I/O statement.
$nexp 0896
Error : The data item length must be equal for bloc and eloc in a BUFFER I/O statement.
.PP
Only certain combinations of data types are allowed for the \fIbloc\fR and
\fIeloc\fR parameters to \*CBUFFER IN\fR and \*CBUFFER OUT\fR.  The allowed
combinations are as follows:
.nf
   real - real
   integer - integer
   logical - logical
   integer - real
   logical - integer
   logical - real
   double precision - double precision
   double precision - complex
   complex - complex
   character - character
.fi
.CS
   BUFFERIN (id,m) (bloc,eloc)
   BUFFEROUT (id,m) (bloc,eloc)
.CE
.ME
$
$ Error : 0897
$msg  0897 This call to VFUNCTION "%s" is not allowed inside a WHERE block or on a WHERE statement.
$nexp 0897
Error : This call to VFUNCTION "%s" is not allowed inside a WHERE block or on a WHERE statement.
.PP
The compiler extension \*CVFUNCTION\fR is not supported for calls
under a \*CWHERE\fR mask. 
.ME
$
$ Error : 0898
$msg  0898 "%s" is declared as a scalar variable in a module, therefore it must not be used as an external function name.
$nexp 0898
Error : "%s" is declared as a scalar variable in a module, therefore it must not be used as an external function name.
.PP
When an object is declared in a module, its attributes are complete.
Its attributes must not be respecified by another declaration
statement or by its use as an external function call.  The following
example illustrates the problem.
.CS
 MODULE M
 INTEGER I        ! I is a scalar variable
 END MODULE

 SUBROUTINE P2()
 USE M
 II = I(6)        ! Illegal reference of I
 END SUBROUTINE
.CE
.ME
$
$ Ansi : 0899
$msg  0899 Use of the tab character is an extension of the Fortran standard.
$nexp 0899
Ansi : Use of the tab character is an extension of the Fortran standard.
.PP
The use of the tab character is allowed as an extension to the
Fortran standard.
.ME
$
$ Ansi : 0900
$msg  0900 Use of the "@" character in identifiers is an extension to the Fortran standard.
$nexp 0900
Ansi : Use of the "@" character in identifiers is an extension to the Fortran standard.
.PP
The use of the \*C@\fR character is allowed as an extension to the Fortran
standard.
.ME
$
$ Ansi : 0901
$msg  0901 Use of the "$" character in identifiers is an extension to the Fortran standard.
$nexp 0901
Ansi : Use of the "$" character in identifiers is an extension to the Fortran standard.
.PP
Use of the \*C$\fR character in identifiers is allowed as an extension to 
the Fortran standard.
.ME
$
$ Internal : 0902
$msg  0902 The char_len.fld is Null_Idx in create_runtime_array_constructor.
$nexp 0902
Internal : The char_len.fld is Null_Idx in create_runtime_array_constructor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Ansi : 0903
$msg  0903 Constant length character array constructor values with unequal lengths are nonstandard.
$nexp 0903
Ansi : Constant length character array constructor values with unequal lengths are nonstandard.
.PP
As an extension to the Fortran standard, type character array
constructors are allowed to have character values with unequal
lengths.  This is allowed only if the lengths are constant.  The
longest constant length is chosen as the element length for the
array constructor.  All shorter \fIac_values\fR are padded to this length.
.ME
$
$ Internal : 0904
$msg  0904 Call_Opr in constant constructor that was not an intrinsic.
$nexp 0904
Internal : Call_Opr in constant constructor that was not an intrinsic.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0905
$msg  0905 The section subscript triplet produces a subscript value greater than the declared upper bound.
$nexp 0905
Error : The section subscript triplet produces a subscript value greater than the declared upper bound.
.PP
In a section subscript that is a triplet subscript, each subscript value must
be greater than or equal to the declared lower bound of the array and must be
less than or equal to the declared upper bound of the array.  For example, if
an array is declared as follows:
.CS
INTEGER  array(10)
.CE
each subscript value of a section subscript triplet referencing \*CARRAY\fR must be 
equal to or greater than 1 and must be equal to or less than 10.
.ME
$
$ Error : 0906
$msg  0906 A structure constructor in a DATA statement value list must represent a constant value.
$nexp 0906
Error : A structure constructor in a DATA statement value list must represent a constant value.
.PP
Each component of a structure constructor in a \*CDATA\fR statement value list must
be an initialization expression.
.PP
Usually each primary of an initialization expression must be a constant
(either a named constant or a literal constant), or a subobject of a constant.
There are also limited cases where the primaries must be certain intrinsic
functions, or array constructors that are constant expressions.
.PP
Because the \*CDATA\fR statement value is a structure constructor, each of its 
components must obey the rules for an initialization expression.  Thus, for
example, in a \*CDATA\fR statement value list, a structure constructor containing a
variable would not be a constant value and therefore would not be an 
initialization expression.
.ME
$
$ Error : 0907
$msg  0907 All bounds and kind selector specification expressions must be scalar.
$nexp 0907
Error : All bounds and kind selector specification expressions must be scalar.
.PP
The compiler detected a nonscalar expression in a bounds expression
or in a kind selector expression.  Bounds expressions are used to declare
array dimension size and character length and must always be scalar and
type integer.  Kind selector expressions must always be scalar integer
constants and are used to declare the kind of a type.
.ME
$
$ Caution : 0908
$msg  0908 This integer constant is too large to be used in a 46-bit multiply or divide.
$nexp 0908
Caution : This integer constant is too large to be used in a 46-bit multiply or divide.
.PP
The use of this value in a 46-bit multiply or divide may produce a floating
point exception if its value is hidden from the compiler. This may occur when
a constant or variable with a value exceeding the 46-bit maximum is passed as
an actual argument to a subroutine or function which tries to perform the
multiply or divide. To prevent this, compile with \*C-i64\fR option. The \*C-i46\fR
option is the default.
.ME
$
$ Error : 0909
$msg  0909 There are not enough registers available to make this vfunction call.
$nexp 0909
Error : There are not enough registers available to make this vfunction call.
.PP
A call to a \*CVFUNCTION\fR can pass a maximum of seven single-word items or three
double-word items.  These can be mixed in any order, with a maximum of seven
words.  This call to a \*CVFUNCTION\fR passes more than seven words of arguments.

Functions classed as \*CVFUNCTION\fRs are an extension to the Fortran 
standard.
.ME
$
$ Error : 0910
$msg  0910 Arguments of derived type or type character are not allowed for vfunction calls.
$nexp 0910
Error : Arguments of derived type or type character are not allowed for vfunction calls.
.PP
All the arguments to a \*CVFUNCTION\fR must fit in seven registers. Only expressions
of type integer, real, complex, or logical are allowed and the total number
of words must not be greater than seven.

Functions classed as \*CVFUNCTION\fRs are an extension to the Fortran 
standard.
.ME
$
$ Log_Warning : 0911
$msg  0911 An assembly language file (-eS or -S filename) disables an assembly language listing (-rg).  Output file selected.
$nexp 0911
Log_Warning : An assembly language file (-eS or -S filename) disables an assembly language listing (-rg).  Output file selected.
.PP
The compiler cannot create an assembly language listing and an assembly 
language  output file at the same time.  The last option specified is 
the option selected.
.ME
$
$ Log_Summary : 0912
$msg  0912 openf95-912: %d ERRORS found in command line.  Compilation aborted.
$nexp 0912
Log_Summary : openf95-912: %d ERRORS found in command line.  Compilation aborted.
.PP
This message gives a summary of error messages issued during command-line
processing.  If any errors are found during command-line processing,
compilation is aborted.
.ME
$
$ Log_Warning : 0913
$msg  0913 A binary output file must be enabled to get an assembly language listing. (-rg)
$nexp 0913
Log_Warning : A binary output file must be enabled to get an assembly language listing. (-rg)
.PP
A binary (\*C-eB\fR or \*C-b\fR filename or default) output file must be enabled to 
get an assembly language listing.  For example:
.CS
  -dB -er  \fIfile\*C.f
.CE
.PP
\fRThis will receive the warning message.
.ME
$
$ Error : 0914
$msg  0914 "%s" has the DIMENSION attribute, therefore it must have an explicit interface to be used as a function.
$nexp 0914
Error : "%s" has the DIMENSION attribute, therefore it must have an explicit interface to be used as a function.
.PP
If a function has an array-valued result, it must have an explicit interface.
An explicit interface can be supplied by an interface block or by specifying
the function as an internal or module subprogram.
.ME
$
$ Error : 0915
$msg  0915 "%s" has the POINTER attribute, therefore it must have an explicit interface to be used as a function.
$nexp 0915
Error : "%s" has the POINTER attribute, therefore it must have an explicit interface to be used as a function.
.PP
If a function has a pointer-valued result, it must have an explicit interface.
An explicit interface can be supplied by an interface block or by specifying
the function as an internal or module subprogram.
.ME
$
$ Error : 0916
$msg  0916 "%s" has a variable length character result, therefore it must have an explicit interface.
$nexp 0916
Error : "%s" has a variable length character result, therefore it must have an explicit interface.
.PP
If a function has a variable length character result, it must have an 
explicit interface.  An explicit interface can be supplied by an interface 
block or by specifying the function as an internal or module subprogram.
Specifying the \*CEXTERNAL\fR attribute does not give an explicit interface.
.ME
$
$ Log_Error : 0917
$msg  0917 The CIF option has an illegal argument "%s".
$nexp 0917
Log_Error : The CIF option has an illegal argument "%s".
.PP
The \*C-C\fR command-line option is being passed an
invalid argument.
.ME
$
$ Warning : 0918
$msg  0918 Function "%s" has a pointer result, but the result has not been pointer assigned or allocated.
$nexp 0918
Warning : Function "%s" has a pointer result, but the result has not been pointer assigned or allocated.
.PP
A pointer must be associated before it is referenced.  This function has a
result that is a pointer, but the result has not been specified in a pointer
assignment statement or an \*CALLOCATE\fR statement.
.ME
$
$ Error : 0919
$msg  0919 "%s" has been host associated and used as a named constant, therefore it must not be redeclared as an internal %s.
$nexp 0919
Error : "%s" has been host associated and used as a named constant, therefore it must not be redeclared as an internal %s.
.PP
This object was declared to be a named constant in a host scope.  The object must not be
declared as an internal procedure, because it is host associated from
the host scope and used as a named constant in an initialization expression
in the local scope.
.ME
$
$ Error : 0920
$msg  0920 "%s" is host associated, therefore it must not be redeclared with the %s attribute.
$nexp 0920
Error : "%s" is host associated, therefore it must not be redeclared with the %s attribute.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.
After an object is host associated in a scope, it must not be redeclared.  
The compiler detected something similar to this:
.CS
PROGRAM ABC
INTEGER I
...
CONTAINS
  SUBROUTINE SUBR(A)
  DIMENSION A(I)

  SAVE I  ! Illegal; I used in DIMENSION statement
  END SUBROUTINE
END PROGRAM
.CE
.ME
$
$ Error : 0921
$msg  0921 "%s" is host associated, therefore it must not be redeclared as a %s.
$nexp 0921
Error : "%s" is host associated, therefore it must not be redeclared as a %s.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.
After an object is host associated into a scope, it must not be redeclared.  
.ME
$
$ Error : 0922
$msg  0922 "%s" has been use associated, therefore it must not be redeclared with the %s attribute.
$nexp 0922
Error : "%s" has been use associated, therefore it must not be redeclared with the %s attribute.
.PP
After an object has been use associated, it cannot be specified in any 
specification statements.
.ME
$
$ Error : 0923
$msg  0923 "%s" has been use associated, therefore it must not be redeclared as a %s.
$nexp 0923
Error : "%s" has been use associated, therefore it must not be redeclared as a %s.
.PP
After an item has been use associated, it must not be specified in any 
specification statements, other than being given the \*CPUBLIC\fR or \*CPRIVATE\fR 
attribute.
.ME
$
$ Error : 0924
$msg  0924 "%s" is host associated into this scope, so it cannot be redeclared as variable length character.
$nexp 0924
Error : "%s" is host associated into this scope, so it cannot be redeclared as variable length character.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.
After an object is host associated in a scope, it must not be redeclared.  
.ME
$
$ Error : 0925
$msg  0925 "%s" has been use associated, therefore it must not be redeclared as variable length character.
$nexp 0925
Error : "%s" has been use associated, therefore it must not be redeclared as variable length character.
.PP
After an item has been use associated, it must not be specified in any 
specification statements, other than being given the \*CPUBLIC\fR or 
\*CPRIVATE\fR attribute.
.ME
$
$ Error : 0926
$msg  0926 "%s" is host associated, therefore it must not be redeclared with the DIMENSION attribute.
$nexp 0926
Error : "%s" is host associated, therefore it must not be redeclared with the DIMENSION attribute.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.  After an object is host associated in a scope, it must not
be given the \*CDIMENSION\fR attribute.
.ME
$
$ Error : 0927
$msg  0927 "%s" has been use associated, therefore it must not be redeclared with the DIMENSION attribute.
$nexp 0927
Error : "%s" has been use associated, therefore it must not be redeclared with the DIMENSION attribute.
.PP
After an item has been use associated, it must not be specified in any 
specification statements, other than being given the \*CPUBLIC\fR or \*CPRIVATE\fR 
attribute.
.ME
$
$ Error : 0928
$msg  0928 "%s" is host associated, therefore it must not be redeclared in a common block.
$nexp 0928
Error : "%s" is host associated, therefore it must not be redeclared in a common block.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.
After an object is host associated in a scope, it must not be redeclared.  
.ME
$
$ Error : 0929
$msg  0929 "%s" has been use associated, therefore it must not be redeclared in a common block.
$nexp 0929
Error : "%s" has been use associated, therefore it must not be redeclared in a common block.
.PP
After an item has been use associated, it must not be specified in any 
specification statements, other than being given the \*CPUBLIC\fR or \*CPRIVATE\fR 
attribute.
.ME
$
$ Error : 0930
$msg  0930 "%s" is host associated, therefore it must not be redeclared as a function.
$nexp 0930
Error : "%s" is host associated, therefore it must not be redeclared as a function.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.
After an object is host associated in a scope, it must not be redeclared.  
.ME
$
$ Error : 0931
$msg  0931 "%s" has been use associated, therefore it must not be redeclared as a function.
$nexp 0931
Error : "%s" has been use associated, therefore it must not be redeclared as a function.
.PP
After an item has been use associated, it must not be redeclared.
.ME
$
$ Error : 0932
$msg  0932 "%s" is host associated, therefore it cannot be redeclared as a subroutine.
$nexp 0932
Error : "%s" is host associated, therefore it cannot be redeclared as a subroutine.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.
After an object is host associated in a scope, it must not be redeclared.  
.ME
$
$ Error : 0933
$msg  0933 "%s" has been use associated, therefore it must not be redeclared as a subroutine.
$nexp 0933
Error : "%s" has been use associated, therefore it must not be redeclared as a subroutine.
.PP
After an item has been use associated, it must not be redeclared.
.ME
$
$ Error : 0934
$msg  0934 Module "%s" has no public entities declared in the module, therefore names specified in the rename-list cannot be found.
$nexp 0934
Error : Module "%s" has no public entities declared in the module, therefore names specified in the rename-list cannot be found.
.PP
The module specified on the \*CUSE\fR statement is apparently empty, therefore, none of the
names specified on the \fIrename_list\fR will be found.
The module could be empty for one of several reasons:
.BL
The module contains no declarations in its specification part.
.BL
Everything in the module is declared private.
.BL
The module has compilation errors.
.ME
$
$ Warning : 0935
$msg  0935 The integer arithmetic expression exceeds 46-bit maximum.  64-bit integer arithmetic will be tried.
$nexp 0935
Warning : The integer arithmetic expression exceeds 46-bit maximum.  64-bit integer arithmetic will be tried.
.PP
When trying to compute the value of a constant expression, the compiler encountered
an integer value that was too large to be represented in 46-bit integer
format.  The value was treated as a 64-bit value, and 64-bit integer
arithmetic was performed.  A constant expression involves only constants, and
the value of the expression is determined at compile time, not at execution
time.  This error occurs when data type conversion is required during the
computation (for example, converting from real to integer).
.ME
$
$ Error : 0936
$msg  0936 A DATA implied-DO loop control expression must be a scalar integer expression.
$nexp 0936
Error : A DATA implied-DO loop control expression must be a scalar integer expression.
.PP
An implied-\*CDO\fR in a \*CDATA\fR statement has the form:
.CS
   (\fIdata_i_do_object_list\*C, \fIdata_i_do_variable\*C =
        \fIscalar_int_expr\*C, \fIscalar_int_expr\*C 
	[, \fIscalar_int_expr\*C])
.CE
.PP
The three \fIscalar_int_expr\fRs represent the start, end and increment values for 
the implied-\*CDO\fR.  Each of these expressions must be scalar and each must be of
type integer.
.ME
$
$ Internal : 0937
$msg  0937 The compiler is trying to use the intrinsic enum to call an intrinsic processor, but the enum is Unknown_Intrinsic.
$nexp 0937
Internal : The compiler is trying to use the intrinsic enum to call an intrinsic processor, but the enum is Unknown_Intrinsic.
.PP
There are a list of intrinsic enums, which are used to call the semantic
routines for intrinsic processing.  A enum is set to Uknown_Intrinsic and
the unkown_intrinsic routine is being called.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Caution : 0938
$msg  0938 A real division was encountered in an expression being converted to integer.
$nexp 0938
Caution : A real division was encountered in an expression being converted to integer.
.PP
An assignment statement is being used in which the operand on the left side
of the equal sign is type integer and the operand on the right side of the
equal sign is an expression of type real or double precision, containing a
division operation.  This message is a warning that division on this machine
is achieved through reciprocal approximation, which may yield unexpected
answers in these situations.  For example, in the following statement, where
\*CX\fR is 27.0 and \*CY\fR = 9.0, \*CX/Y\fR will yield 2.9999...:
.CS
  I = X/Y
.CE
.PP
When 2.9999...  is assigned to \*CI\fR (converted to integer) the result will be 2,
not 3.
.ME
$
$ Error : 0939
$msg  0939 Function "%s" is typed as assumed-length character.  It must have a known character length to be called.
$nexp 0939
Error : Function "%s" is typed as assumed-length character.  It must have a known character length to be called.
.PP
If a character function is called, the character function length must be known.
.ME
$
$ Ansi : 0940
$msg  0940 "%s" is a statement function dummy argument and a variable.  The types must agree.
$nexp 0940
Ansi : "%s" is a statement function dummy argument and a variable.  The types must agree.
.PP
If a statement function dummy argument has the same name as a variable, the
variable may be typed after
the statement function definition, but the type can only be confirmed.
.ME
$
$ Error : 0941
$msg  0941 Common block "%s" is defined and/or associated as a standard and a task common block in the same scope.
$nexp 0941
Error : Common block "%s" is defined and/or associated as a standard and a task common block in the same scope.
.PP
Common blocks can be defined in a scope by being declared, use associated
or host associated.  The common block in error is defined multiple 
times in this scope, but in some places it is a standard common block and in
other places it is a task common block.   Following are examples of how a
common block gets defined in a scope:
.CS
  MODULE CC
  COMMON /BB/ M,N  \fR! Common block \*CBB\fR is declared\*C 
  END MODULE       \fR! in \*CCC\fR's scope\*C

  PROGRAM ZZ
  USE CC           \fR!  Common block \*CBB\fR is use\*C 
  CONTAINS         \fR!  associated into \*CZZ\fR's scope\*C
    SUBROUTINE YY()
    N = M          \fR! Common block \*CBB\fR is host\*C 
    END SUBROUTINE \fR! associated into \*CYY\fR's scope\*C
  END PROGRAM
.CE       
.PP
Following is an example of the problem:
.CS
  MODULE CC
  COMMON /BB/ M,N      \fR! Common block \*CBB\fR declared\*C 
  END MODULE           \fR! in \*CCC\fR's scope\*C

  MODULE DD
  TASK COMMON /BB/ M,N \fR! Common block \*CBB\fR declared\*C 
  END MODULE           \fR! in \*CDD\fR's scope\*C

  PROGRAM QQ
  USE CC               \fR! Common block \*CBB\fR comes in\*C
  USE DD               \fR! Common block \*CBB\fR comes in\*C
                                \fR! but it is \*CTASK COMMON
  END PROGRAM
.CE 
.ME
.PP
Task common blocks are an extension to the Fortran standard.
$
$ Error : 0942
$msg  0942 Common block "%s" is defined and/or associated in this scope as a standard and an auxiliary storage block.
$nexp 0942
Error : Common block "%s" is defined and/or associated in this scope as a standard and an auxiliary storage block.
.PP
Common blocks can be defined in a scope by being declared, use associated
or host associated.  The common block in error is defined multiple 
times in this scope, but in some places it is a standard common block and in
other places it is a common block in auxiliary storage.   Following are
examples of how a common block gets defined in a scope:
.CS
   MODULE CC
   COMMON /BB/ M,N   \fR! Common block \*CBB\fR is declared\*C 
   END MODULE        \fR! in \*CCC\fR's scope\*C
 
   PROGRAM ZZ
   USE CC            \fR!  Common block \*CBB\fR is use\*C 
   CONTAINS          \fR!  associated into \*CZZ\fR's scope\*C
     SUBROUTINE YY()
     N = M           \fR! Common block \*CBB\fR is host\*C 
     END SUBROUTINE  \fR! associated into \*CYY\fR's scope\*C
   END PROGRAM
.CE 
.PP
Auxiliary storage is an extension to the Fortran standard.
.ME
$
$ Ansi : 0943
$msg  0943 The use of type default real or double precision real expressions for io-implied-do-control is an obsolescent/deleted feature.
$nexp 0943
Ansi : The use of type default real or double precision real expressions for io-implied-do-control is an obsolescent/deleted feature.
.PP
The feature was deleted in the Fortran
95 standard. This compiler supports the feature as an extension.
.PP
Use type integer
expressions instead.
.ME
$
$ Ansi : 0944
$msg  0944 The use of a type default real or double precision real DO variable is an obsolescent/deleted feature.
$nexp 0944
Ansi : The use of a type default real or double precision real DO variable is an obsolescent/deleted feature.
.PP
The feature was deleted in the Fortran
95 standard. This compiler supports the feature as an extension.
.PP
Use a \*CDO\fR variable of type integer instead.
.ME
$
$ Error : 0945
$msg  0945 An auxiliary variable must not be used in an I/O statement.
$nexp 0945
Error : An auxiliary variable must not be used in an I/O statement.
.PP
The name of an entity allocated to the SSD by using an \*CAUXILIARY\fR compiler
directive appears in an I/O statement.  I/O transfers are not allowed into or
out of auxiliary variables.
.PP
Auxiliary storage is an extension to the Fortran standard.
.ME
$
$ Error : 0946
$msg  0946 If a SIZE= specifier is present in an I/O control list, an ADVANCE= specifier also must appear.
$nexp 0946
Error : If a SIZE= specifier is present in an I/O control list, an ADVANCE= specifier also must appear.
.PP
A \*CSIZE=\fR specifier is in a \*CREAD\fR or \*CWRITE\fR statement that does not have an
\*CADVANCE=\fR specifier.
.ME
$
$ Error : 0947
$msg  0947 The array actual argument cannot be optional in this context.
$nexp 0947
Error : The array actual argument cannot be optional in this context.
.PP
When calling an elemental intrinsic function, if there is an optional array
actual argument being passed, then there must be a conformant nonoptional
actual argument also being passed.  Two objects are conformant if they have
the same rank and extent for each dimension.
.CS
     DIMENSION A(10), B(10)
     MAX (A3=A, A1=B, A2=4)       \fR ! Legal\*C
     MAX (A3=A, A1=5, A2=4)       \fR ! Illegal\*C
.CE
In the call to \*CMAX\fR, \*CA3\fR is an optional argument.
Because \*CA3\fR is specified, at least one of the nonoptional arguments
\*CA1\fR or \*CA2\fR must be specified and at least one of the nonoptional
arguments must be conformant to \*CA3\fR.
.ME
$
$ Limit : 0948
$msg  0948 The "%s" option was specified so the compilation is aborting on the first error.
$nexp 0948
Limit : The "%s" option was specified so the compilation is aborting on the first error.
.PP
If the \*C-ea\fR option is enabled, the compilation aborts after
encountering the first error.
.ME
$
$ Error : 0949
$msg  0949 Generic interface "%s" must not have an explicit type.
$nexp 0949
Error : Generic interface "%s" must not have an explicit type.
.PP
A generic interface must not be typed.
.ME
$
$ Error : 0950
$msg  0950 "%s" is a generic interface or an intrinsic.  It must not be typed, because it has already been referenced.
$nexp 0950
Error : "%s" is a generic interface or an intrinsic.  It must not be typed, because it has already been referenced.
.PP
A generic interface name that is not an intrinsic name must not
be given a type 
attribute.   A generic interface that is an intrinsic may be given a type
attribute, provided the generic interface was not previously referenced.
.ME
$
$ Error : 0951
$msg  0951 The extent for dimension %d is too large for array "%s".
$nexp 0951
Error : The extent for dimension %d is too large for array "%s".
.PP
The extent calculation is too large for this machine.  The array must be made
smaller.
.ME
$
$ Ansi : 0952
$msg  0952 "%s" is the name of a local variable in a host scope so it must not be the name of an external procedure.
$nexp 0952
Ansi : "%s" is the name of a local variable in a host scope so it must not be the name of an external procedure.
.PP
The Fortran standard defines an external procedure as a global entity.
Global entities are not allowed to have the same name as a local entity in
any scope.
.ME
$
$ Ansi : 0953
$msg  0953 "%s" is the name of a local entity in a host scope so it must not be the name of the module in a USE statement.
$nexp 0953
Ansi : "%s" is the name of a local entity in a host scope so it must not be the name of the module in a USE statement.
.PP
The Fortran standard defines a module as a global entity.  Global entities
are not allowed to have the same name as a local entity in any scope.
.ME
$
$ Log_Summary : 0954
$msg  0954 Open64 Fortran Version %s (%s) %s
$nexp 0954
Log_Summary : Open64 Fortran Version %s (%s) %s
.PP
This identifies which version and release of the compiler is being used.
This is used when \*C-V\fR is specified.
.ME
$
$ Error : 0955
$msg  0955 Program "%s" is missing an END statement.
$nexp 0955
Error : Program "%s" is missing an END statement.
.PP
The compiler detected a premature end of file.  The main program unit
must be terminated by an \*CEND [PROGRAM]\fR statement.
.ME
$
$ Error : 0956
$msg  0956 "%s" is host associated into this scope, but is not a derived type so it must not be used as a derived type.
$nexp 0956
Error : "%s" is host associated into this scope, but is not a derived type so it must not be used as a derived type.
.PP
If an entity is host associated into a scope as a variable, constant,
or procedure, it must not be used as a derived type.  
.ME
$
$ Ansi : 0957
$msg  0957 Permitting a BOZ constant to be signed is an extension to the Fortran standard.
$nexp 0957
Ansi : Permitting a BOZ constant to be signed is an extension to the Fortran standard.
.PP
The permissible forms for values in a \*CDATA\fR statement's \fIdata_stmt_value_list\fR
are:
.nf
    \fIscalar_constant
    signed_int_literal_constant
    signed_real_literal_constant
    structure_constructor
    boz_literal_constant\fR
.fi
.PP
Only an integer literal constant or a real literal constant can be signed.
Allowing a BOZ literal constant to be signed is an extension to the Fortran
standard. 
.ME
$
$ Error : 0958
$msg  0958 A sign is permitted only for an integer literal constant or a real literal constant.
$nexp 0958
Error : A sign is permitted only for an integer literal constant or a real literal constant.
.PP
The permissible forms for values in a \*CDATA\fR statement's \fIdata_stmt_value_list\fR
are:
.nf   
   \fIscalar_constant
   signed_int_literal_constant
   signed_real-literal-constant
   structure_constructor
   boz_literal_constant\fR
.fi
.PP   
Only an integer literal constant or a real literal constant can be signed (and
by extension, a BOZ literal constant can be signed).
.ME
$
$ Warning : 0959
$msg  0959 The AUTOSCOPE parameter on a PARALLEL or DOALL compiler directive is not yet supported.
$nexp 0959
Warning : The AUTOSCOPE parameter on a PARALLEL or DOALL compiler directive is not yet supported.
.PP
This release of the compiler does not support the \*CAUTOSCOPE\fR parameter
to the \*CDOALL\fR or \*CPARALLEL\fR tasking directives. Therefore, all variables
that are used inside a parallel region must have been specified with 
either the private or shared attribute on the \*CPARALLEL\fR or \*CDOALL\fR directive
line.
.ME
$
$ Error : 0960
$msg  0960 Variable "%s" is in a parallel region and must be in the shared or private list if autoscope is not specified.
$nexp 0960
Error : Variable "%s" is in a parallel region and must be in the shared or private list if autoscope is not specified.
.PP
All user variables used in a parallel region or \*CDOALL\fR loop must be in
either the shared or private list if autoscope is not specified. Autoscope
is not supported in this release of the compiler; therefore, all scopes must 
be specified explicitly.
.ME
$
$ Error : 0961
$msg  0961 The DO control variable must not be SHARED in a DOALL loop.
$nexp 0961
Error : The DO control variable must not be SHARED in a DOALL loop.
.PP
The \*CDO\fR variable of a \*CDOALL\fR loop must not be specified with 
the \*CSHARED\fR attribute. 
.ME
$
$ Error : 0962
$msg  0962 An array constructor implied-DO control expression must be a scalar integer expression.
$nexp 0962
Error : An array constructor implied-DO control expression must be a scalar integer expression.
.PP
An implied-\*CDO\fR in an array constructor has the form:
.CS 
   (\fIac_value_list\*C, \fIac_do_variable\*C =
        \fI scalar_int_expr\*C, \fIscalar_int_expr\*C 
	[, \fIscalar_int_expr\*C])
.CE
.PP
The three \fIscalar_int_expr\fRs represent the start, end and increment values for
the implied-\*CDO\fR.  Each of these expressions must be scalar and each must be of
type integer.
.ME
$
$ Internal : 0963
$msg  0963 Encountered SH_Tbl_Idx in cmp_ref_trees.
$nexp 0963
Internal : Encountered SH_Tbl_Idx in cmp_ref_trees.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0964
$msg  0964 Non constant character in gen_static_dv_whole_def.
$nexp 0964
Internal : Non constant character in gen_static_dv_whole_def.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0965
$msg  0965 Problem in process_deferred_functions.
$nexp 0965
Internal : Problem in process_deferred_functions.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0966
$msg  0966 Nonconstant shape for create_bd_ntry_for_const.
$nexp 0966
Internal : Nonconstant shape for create_bd_ntry_for_const.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0967
$msg  0967 Nonconstant character len in create_bd_ntry_for_const.
$nexp 0967
Internal : Nonconstant character len in create_bd_ntry_for_const.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0968
$msg  0968 Assumed_Size func result in set_shape_for_deferred_funcs.
$nexp 0968
Internal : Assumed_Size func result in set_shape_for_deferred_funcs.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0969
$msg  0969 Non constant character in gen_internal_dope_vector.
$nexp 0969
Internal : Non constant character in gen_internal_dope_vector.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0970
$msg  0970 No function type information in call_list_semantics.
$nexp 0970
Internal : No function type information in call_list_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0971
$msg  0971 Trying to change data obj in call_list_semantics.
$nexp 0971
Internal : Trying to change data obj in call_list_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0972
$msg  0972 Bad dummy argument in call_list_semantics.
$nexp 0972
Internal : Bad dummy argument in call_list_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0973
$msg  0973 Improper ir for left side of ptr assignment.
$nexp 0973
Internal : Improper ir for left side of ptr assignment.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0974
$msg  0974 Wrong statement header in assignment_stmt_semantics.
$nexp 0974
Internal : Wrong statement header in assignment_stmt_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0975
$msg  0975 Improper ir tree in expr_semantics.
$nexp 0975
Internal : Improper ir tree in expr_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0976
$msg  0976 Expected Dv_Deref_Opr from ptr_assign_from_pointer.
$nexp 0976
Internal : Expected Dv_Deref_Opr from ptr_assign_from_pointer.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0977
$msg  0977 Expected ir from ptr_assign_from_pointer.
$nexp 0977
Internal : Expected ir from ptr_assign_from_pointer.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0978
$msg  0978 Something other than list opnd in array_construct_semantics.
$nexp 0978
Internal : Something other than list opnd in array_construct_semantics.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0979
$msg  0979 Bad assumption in fold_aggragate_expression.
$nexp 0979
Internal : Bad assumption in fold_aggragate_expression.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0980
$msg  0980 Unexpected type for lcv constant in interpret_constructor.
$nexp 0980
Internal : Unexpected type for lcv constant in interpret_constructor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0981
$msg  0981 Not constant IN interpret_constructor.
$nexp 0981
Internal : Not constant IN interpret_constructor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0982
$msg  0982 Not an lcv constant in interpret_constructor.
$nexp 0982
Internal : Not an lcv constant in interpret_constructor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0983
$msg  0983 Invalid position idx in interpret_constructor.
$nexp 0983
Internal : Invalid position idx in interpret_constructor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0984
$msg  0984 Structure in array syntax portion of interpret ref.
$nexp 0984
Internal : Structure in array syntax portion of interpret ref.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0985
$msg  0985 Error in create_array_constructor_asg, not ir idx.
$nexp 0985
Internal : Error in create_array_constructor_asg, not ir idx.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0986
$msg  0986 Error in create_array_constructor_asg, unexpected opr.
$nexp 0986
Internal : Error in create_array_constructor_asg, unexpected opr.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Internal : 0987
$msg  0987 Problem in create_struct_constructor_asg.
$nexp 0987
Internal : Problem in create_struct_constructor_asg.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0988
$msg  0988 "%s" is the result name of function "%s", therefore it must not be use associated from module "%s".
$nexp 0988
Error : "%s" is the result name of function "%s", therefore it must not be use associated from module "%s".
.PP
The result name of this function was found in a module brought in by a 
\*CUSE\fR statement.  This creates a name conflict, as in the following example:
.CS
   MODULE NEW
    INTEGER ABC
   END MODULE

   FUNCTION X RESULT(ABC)
    USE NEW          ! ABC is illegal here
   END FUNCTION
.CE
.ME
$
$ Internal : 0989
$msg  0989 The compiler has found an unexpected entity "%s" in the attr table when checking for not visible during use processing.
$nexp 0989
Internal : The compiler has found an unexpected entity "%s" in the attr table when checking for not visible during use processing.
.PP
In routine attr_is_visible, the compiler found an attribute in the attr
table that was unexpected.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0990
$msg  0990 It is illegal to take the LOC of an auxiliary array.
$nexp 0990
Error : It is illegal to take the LOC of an auxiliary array.
.PP
An auxiliary array must not be an actual argument in the
\*CLOC\fR intrinsic function.  Both auxiliary storage and
the \*CLOC\fR intrinsic function are extensions to the
Fortran standard.
.ME
$
$ Error : 0991
$msg  0991 Multiple specific interfaces exist for "%s" and are ambiguous.  This makes %s interface "%s" ambiguous.
$nexp 0991
Error : Multiple specific interfaces exist for "%s" and are ambiguous.  This makes %s interface "%s" ambiguous.
.PP
Multiple specific interfaces exist that are ambiguous.  These are all
specified in the same generic or defined interface.  If a reference is
made to this generic interface, the compiler will not be able to resolve
to a specific interface, because it will not know which one to resolve to.
Within a scoping unit, two procedures in the same generic or defined 
interface are differentiated by their nonoptional dummy arguments.
One way to differentiate specific interfaces 
is by the 
number of dummy arguments.  If the specific interfaces have
the same number of dummy arguments, the dummy arguments must differ in type,
kind type or rank.  Specific interfaces in a defined interface must have
dummy arguments that differ in type, kind type or rank.
.ME
$
$ Log_Error : 0992
$msg  0992 "-O %d" is specified, therefore "-O %s%d" must not be specified.
$nexp 0992
Log_Error : "-O %d" is specified, therefore "-O %s%d" must not be specified.
.PP
If an optimization level is specified on the command line using \*C-O num\fR, none
of the following options may be specified on the command line:
.CS
 -O scalar0  -O vector0  -O task0
 -O scalar1  -O vector1  -O task1
 -O scalar2  -O vector2  -O task2
 -O scalar3  -O vector3  -O task3
.CE
.ME
$
$ Internal : 0993
$msg  0993 An operator internal text does not have a valid type table index.
$nexp 0993
Internal : An operator internal text does not have a valid type table index.
.PP
An operator ir node has a zero type table index. The routine that is
issuing this error expects the operator to have a valid type index.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 0994
$msg  0994 The actual arguments to the ASSOCIATED intrinsic may both be dummy arguments only if they are both pointers.
$nexp 0994
Error : The actual arguments to the ASSOCIATED intrinsic may both be dummy arguments only if they are both pointers.
.PP
The actual arguments to the associated intrinsic may both be dummy arguments only if they are both pointers.
.ME
$
$ Warning : 0995
$msg  0995 When attempting to print a source line for an error message: %s
$nexp 0995
Warning : When attempting to print a source line for an error message: %s
.PP
The compiler was unable to print a line from a source file to show where an
error occurred. This can occur if you use the -E option to capture
preprocessor output, and then move, rename, or edit one or more source files
before compiling the preprocessor output.
.ME
$
$ Error : 0996
$msg  0996 The value of this subscript is greater than the declared upper bound.
$nexp 0996
Error : The value of this subscript is greater than the declared upper bound.
.PP
A subscript value must be less than or equal to the declared upper bound of
the corresponding dimension.
.ME
$
$ Error : 0997
$msg  0997 The section subscript triplet produces a subscript value less than the declared lower bound.
$nexp 0997
Error : The section subscript triplet produces a subscript value less than the declared lower bound.
.PP
In a section subscript that is a triplet subscript, each subscript value must
be greater than or equal to the declared lower bound of the array and must be
less than or equal to the declared upper bound of the array.  For example, if
an array is declared as follows:
     
      INTEGER  array(10)
      
each subscript value of a section subscript triplet referencing ARRAY must be 
equal to or greater than 1 and must be equal to or less than 10.
.ME
$
$ Error : 0998
$msg  0998 The stride value of a section subscript triplet must not be zero.
$nexp 0998
Error : The stride value of a section subscript triplet must not be zero.
.PP
A section subscript triplet consists of a start value, an end value, and a 
stride value separated by colons as follows:

     [start-value] : [end-value] [ : stride]

The stride value must not be zero.
.ME
$
$ Error : 0999
$msg  0999 The argument to the CHAR intrinsic is outside the valid collating sequence.
$nexp 0999
Error : The argument to the CHAR intrinsic is outside the valid collating sequence.
.PP
The argument to the \*CCHAR\fR intrinsic is outside the valid collating sequence.
.ME
$
$ Comment : 1000
$msg  1000 Reserved
$nexp 1000
Comment : Reserved
.BL
Explanation 1000 is used by the openf95 installation process.
.BL
Explanation 1000 must be unformatted, hence the use of $EXP instead of $NEXP.
.BL
Explanation 1000 must be the USM VID string and nothing else.
  1000 90.43\n
.ME
$
$ Error : 1001
$msg  1001 The stride of an array subscript triplet must not be zero.
$nexp 1001
Error : The stride of an array subscript triplet must not be zero.
.PP
An array section was encountered that had a stride value of zero in it's
subscript triplet. 
.ME
$
$ Error : 1002
$msg  1002 "%s" is specified in a namelist group, therefore the type is assumed to be %s.
$nexp 1002
Error : "%s" is specified in a namelist group, therefore the type is assumed to be %s.
.PP
When an object is specified in a namelist group, it is implicitly typed if 
it is the first reference to this object.  The object can subsequently be
typed in a type declaration statement only if it confirms the type.
.PP
Example:
.CS
     IMPLICIT INTEGER(A-Z)
     NAMELIST /GROUP/ R 
     REAL R           \fR! Illegal
.CE
.PP
\*CR\fR can only be typed integer, because that is what it is
implicitly typed as in the \*CNAMELIST\fR statement
.ME
$
$ Warning : 1003
$msg  1003 This compilation unit contains more than one unnamed program unit.
$nexp 1003
Warning : This compilation unit contains more than one unnamed program unit.
.PP
A compilation unit can only have one unnamed program unit.
.ME
$
$ Internal : 1004
$msg  1004 "%s" has a negative offset.  (attr index is %d).
$nexp 1004
Internal : "%s" has a negative offset.  (attr index is %d).
.PP
When the frontend is finished with a data object its offset must be zero
or positive.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1005
$msg  1005 "%s" is a common block name and is also declared as an intrinsic procedure.
$nexp 1005
Error : "%s" is a common block name and is also declared as an intrinsic procedure.
.PP
The Fortran standard prohibits a common block name from being used as the 
name of an intrinsic procedure.
.ME
$
$ Ansi : 1006
$msg  1006 Global name "%s" is in use as a common block name and a %s name.
$nexp 1006
Ansi : Global name "%s" is in use as a common block name and a %s name.
.PP
The Fortran standard prohibits a common block name from being the name of
an external subprogram or a program unit.  A program unit is a block data
subprogram, a module subprogram, or a main program.  An external subprogram
is an external function or subroutine.  An external subprogram name can also
be defined on an ENTRY statement, a CALL statement, an EXTERNAL statement,
an interface body or called as a function in an expression.
.ME
$
$ Error : 1007
$msg  1007 Global name "%s" is in use as a %s name and a %s name.
$nexp 1007
Error : Global name "%s" is in use as a %s name and a %s name.
.PP
The scope of a global name is an entire compilation unit, so a global (or
external) name must only be declared once.
.ME
$
$ Caution : 1008
$msg  1008 "%s" cannot be double aligned because of equivalence alignment.
$nexp 1008
Caution : "%s" cannot be double aligned because of equivalence alignment.
.PP
The \fI-a\fI dalign\fR option is specified on the command line, so the compiler tries
to double align everything.  This variable cannot be double aligned, because it
is equivalenced to another variable that is not on aligned on a double word.
.PP
Following is an example:
.CS
       DOUBLE PRECISION :: B, C
       REAL, DIMENSION(10) :: A
       EQUIVALENCE(A(1), B)
       EQUIVALENCE(A(2), C) 
.Ce
If \*CB\fR is aligned on a double word, then \*CC\fR cannot be and vice versa.
.ME
$
$ Warning : 1009
$msg  1009 This compilation unit contains multiple main program units.
$nexp 1009
Warning : This compilation unit contains multiple main program units.
.PP
A compilation unit can only have one program unit.
.ME
$
$ Warning : 1010
$msg  1010 Global name "%s" is in use already as a %s name.
$nexp 1010
Warning : Global name "%s" is in use already as a %s name.
.PP
The scope of a global name is an entire compilation unit, so a global (or
external) name must only be declared once.
.ME
$
$ Error : 1011
$msg  1011 Procedure "%s" and this compilation must both be compiled with -a dalign, or without -a dalign.
$nexp 1011
Error : Procedure "%s" and this compilation must both be compiled with -a dalign, or without -a dalign.
.PP
If the current compilation unit is being compiled with the \*C-a dalign\fR 
option, each module it uses or each precompiled procedure it inlines must be 
compiled with the \*C-a dalign\fR option.  If the current compilation unit is
being compiled without the \*C-a dalign\fR option, each module it uses or each
precompiled procedure it inlines must be compiled without the \*C-a dalign\fR
option.
.ME
$
$ Error : 1012
$msg  1012 The DIM argument to the LBOUND, UBOUND, or SIZE intrinsic must be a value between 1 and the rank of the ARRAY argument.
$nexp 1012
Error : The DIM argument to the LBOUND, UBOUND, or SIZE intrinsic must be a value between 1 and the rank of the ARRAY argument.
.PP
When the \fIdim\fR argument is specified for the \*CLBOUND\fR, 
\*CUBOUND\fR, or \*CSIZE\fR intrinsic,\
its value must fall within the range of dimensions for the \fIarray\fR argument.
That range is 1 <= \fIdim\fR <= rank of \fIarray\fR.
.ME
$
$ Warning : 1013
$msg  1013 The -a dalign command line option has forced padding to be inserted before "%s" in common block "%s".
$nexp 1013
Warning : The -a dalign command line option has forced padding to be inserted before "%s" in common block "%s".
.PP
The \*C-a\fR \fIdalign\fR option forces double word items to be on a double word boundary.
An object in a common block is a double word object.  To get this object on
a double word boundary, a pad amount is inserted before the object in the
common block.
.ME
$
$ Error : 1014
$msg  1014 Character object "%s" has nonconstant bounds.  It can only be declared in a function, subroutine or interface body.
$nexp 1014
Error : Character object "%s" has nonconstant bounds.  It can only be declared in a function, subroutine or interface body.
.PP
Objects that are typed as character with nonconstant lengths can only be
declared in subroutines, functions, and interface bodies (which describe
subroutines and functions).  The compiler detected a character object
with a nonconstant length, but the declaration is not contained in a 
subroutine, interface body, or function.
.ME
$
$ Error : 1015
$msg  1015 Local-name "%s" must only be referenced once in a rename-list in this scope.
$nexp 1015
Error : Local-name "%s" must only be referenced once in a rename-list in this scope.
.PP
The BNF for a rename-list is:          local-name => use-name
.PP
The compiler has detected the same local-name in more than one rename.
Each local-name must be unique in a scope.
.ME
$
$ Internal : 1016
$msg  1016 An invalid type "%s" was sent to arith input conversion.
$nexp 1016
Internal : An invalid type "%s" was sent to arith input conversion.
.PP
Internal compiler error. A type that is not supported by the arith.a
input conversion routines was encountered.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1017
$msg  1017 The DIM argument is not in a valid range.
$nexp 1017
Error : The DIM argument is not in a valid range.
.PP
The user is trying to pass an illegal value for \fIdim\fR.
.ME
$
$ Internal : 1018
$msg  1018 The char_len field is not set for a character expression in create_tmp_asg.
$nexp 1018
Internal : The char_len field is not set for a character expression in create_tmp_asg.
.PP
Internal compiler error. Character length information was not valid 
for an internal data structure.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1019
$msg  1019 "%s" is in an equivalence group, but does not have ATD_EQUIV set TRUE.
$nexp 1019
Internal : "%s" is in an equivalence group, but does not have ATD_EQUIV set TRUE.
.PP
Everything in an equivalence group must have ATD_EQUIV set TRUE.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1020
$msg  1020 Internal compiler error in process_variable_size_func.
$nexp 1020
Internal : Internal compiler error in process_variable_size_func.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Note : 1021
$msg  1021 The implied-DO was transformed into a whole array or array section initialization.
$nexp 1021
Note : The implied-DO was transformed into a whole array or array section initialization.
.PP
An implied-DO is an inefficient way to initialize a whole array or an array
section.  Initialization of a large array via an implied-DO can utilize
significant compile-time resources.  Wherever possible, such an implied-DO
should be replaced by initialization in a type declaration statement (for whole
array initialization) or in a whole array or array section initialization in a
DATA statement.

For example,

          INTEGER array(100,100)
          DATA ((array(i,j), i = 1, 100), j = 1, 100)  /10000 * -1/

should be replaced with

          INTEGER :: array(100,100) = -1

or 

          INTEGER array(100,100)
          DATA array  /10000 * -1/

An initialization of a portion of an array should be replaced by an array
section initialization where possible (not all such initializations can be 
rewritten in array section notation).  

For example,

          INTEGER array(100,100)
          DATA ((array(i,j), i = 1, 100), j = 1, 50)  /4999 * -1, 0/

should be replaced with

          INTEGER array(100,100)
          DATA array(:, 1:50)  /4999 * -1, 0/
.ME
$
$ Internal : 1022
$msg  1022 Expected character substring in create_io_call_descriptor.
$nexp 1022
Internal : Expected character substring in create_io_call_descriptor.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1023
$msg  1023 The line number passed on the fei_new_stmt must be nonzero.
$nexp 1023
Internal : The line number passed on the fei_new_stmt must be nonzero.
.PP
fei_new_stmt requires a nonzero line number.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1024
$msg  1024 Expression evaluation failed. 
$nexp 1024
Internal : Expression evaluation failed. 
.PP
The compiler was trying to evaluate an expression at compile time and 
encountered an unexpected result or condition.

This message should never be generated.  Please notify your product
support organization with this error message number and any supporting
information.  This message does not indicate a problem with your code.
You may be able to change your code so that the compiler does not try to
issue this message.
.ME
$
$ Internal : 1025
$msg  1025 Nonconstant character length in create_scalar_type_tbl.
$nexp 1025
Internal : Nonconstant character length in create_scalar_type_tbl.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1026
$msg  1026 Cannot open output file for module information table for module "%s".  Check directory permissions.
$nexp 1026
Error : Cannot open output file for module information table for module "%s".  Check directory permissions.
.PP
The compiler cannot open up a file to write out the module information tables.
Check write permission on the current directory.
.ME
$
$ Error : 1027
$msg  1027 Module "%s", specified on the USE statement, is the module currently being compiled.  A module cannot use itself.
$nexp 1027
Error : Module "%s", specified on the USE statement, is the module currently being compiled.  A module cannot use itself.
.PP
A module cannot use itself, nor can any contained procedures of a module use
the module.  The compiler has detected something similar to this:
.CS
      MODULE M
        ...
      CONTAINS
        SUBROUTINE S()
        USE M	    \fR! Illegal\*C
        END SUBROUTINE
      END MODULE
.CE
.PP
.ME
$
$ Ansi : 1028
$msg  1028 "%s" is a host associated common block name and is an intrinsic procedure.  This is nonstandard.
$nexp 1028
Ansi : "%s" is a host associated common block name and is an intrinsic procedure.  This is nonstandard.
.PP
A host associated common block name is being used as the name of an 
intrinsic procedure.  This is an extension to the Fortran standard.
A common block name is host associated into a scope, if any member of the
common block is host associated into the scope.
.ME
$
$ Ansi : 1029
$msg  1029 "%s" is a use associated common block name and is an intrinsic procedure.  This is nonstandard.
$nexp 1029
Ansi : "%s" is a use associated common block name and is an intrinsic procedure.  This is nonstandard.
.PP
A use associated common block name is being used as the name of an 
intrinsic procedure.  This is an extension to the Fortran standard.
A common block name is use associated into a scope, if any member of the
common block is use associated into the scope.
.ME
$
$ Error : 1030
$msg  1030 "%s" is a host associated common block name and is also declared as an intrinsic procedure.
$nexp 1030
Error : "%s" is a host associated common block name and is also declared as an intrinsic procedure.
.PP
The Fortran standard prohibits a host associated common block name from 
being used as the name of an intrinsic procedure.   A common block name is host
associated into a scope, if any member of the common block is host associated 
into the scope.
.ME
$
$ Error : 1031
$msg  1031 "%s" is a use associated common block name and is also declared as an intrinsic procedure.
$nexp 1031
Error : "%s" is a use associated common block name and is also declared as an intrinsic procedure.
.PP
The Fortran standard prohibits a use associated common block name from being
used as the name of an intrinsic procedure.  A common block name is use
associated into a scope if any member of the common block is use associated
into the scope.
.ME
$
$ Ansi : 1032
$msg  1032 "%s" is a named constant and is also a host associated common block name.  This is nonstandard.
$nexp 1032
Ansi : "%s" is a named constant and is also a host associated common block name.  This is nonstandard.
.PP
The Fortran standard prohibits using the same name for a named constant
and a host associated common block name.   A common block name is host
associated into a scope, if any member of the common block is host associated
into the scope.
.ME
$
$ Ansi : 1033
$msg  1033 "%s" is a named constant and is also a use associated common block name.  This is nonstandard.
$nexp 1033
Ansi : "%s" is a named constant and is also a use associated common block name.  This is nonstandard.
.PP
The Fortran standard prohibits using the same name for a named constant
and a use associated common block name.   A common block name is use
associated into a scope, if any member of the common block is use associated
into the scope.
.ME
$
$ Error : 1034
$msg  1034 The compiler cannot open file "%s [or .o]", which may contain information about used module "%s".
$nexp 1034
Error : The compiler cannot open file "%s [or .o]", which may contain information about used module "%s".
.PP
The compiler cannot open the specified module file for \*CUSE\fR statement processing.
Check permissions for the file and for the directory.  
If this is a non-Cray system, the compiler may be attempting to open a .M file.
This file was specified on the command line as -p x.o.
.ME
$
$ Error : 1035
$msg  1035 Character object "%s" is used recursively to declare its own length.
$nexp 1035
Error : Character object "%s" is used recursively to declare its own length.
.PP
An object typed as character must not be specified as part of the expression
declaring its own length.  The following is an example of an invalid
declaration:
    CHARACTER*(CH) :: CH
.ME
$
$ Error : 1036
$msg  1036 Array "%s" is used recursively to declare its own bounds.
$nexp 1036
Error : Array "%s" is used recursively to declare its own bounds.
.PP
An array must not be specified as part of the expression declaring
its own bounds.  The following is an example of an invalid declaration:
       DIMENSION :: IARR(IARR)
.ME
$
$ Error : 1037
$msg  1037 "%s" has been declared and used as a dummy argument, therefore it must not be declared or used as a procedure.
$nexp 1037
Error : "%s" has been declared and used as a dummy argument, therefore it must not be declared or used as a procedure.
.PP
Once an object is declared as a dummy argument and then referenced or defined,
it must not be redeclared as a procedure or referenced as a procedure.
.ME
$
$ Error : 1038
$msg  1038 "%s" has been declared and used as a dummy argument, therefore it must not be declared as a %s.
$nexp 1038
Error : "%s" has been declared and used as a dummy argument, therefore it must not be declared as a %s.
.PP
The object being declared is a referenced or defined dummy argument, which
prohibits it from being declared as any of the following items:
.PP
.nf
	Cray pointer
	Cray pointee
	function result
	derived type
	generic interface
	namelist group
	statement function
	construct name
	function
	subroutine
.fi
.ME
$
$ Error : 1039
$msg  1039 "%s" has been declared and used as a dummy argument, therefore it must not be declared with the %s attribute.
$nexp 1039
Error : "%s" has been declared and used as a dummy argument, therefore it must not be declared with the %s attribute.
.PP
The object being declared is a referenced or defined dummy argument,
which prohibits it from being given any of the following attributes:
.PP
.nf
	\*CDIMENSION\fR
	\*CALLOCATABLE\fR
	\*CPARAMETER\fR
	\*CINTRINSIC\fR
	\*CVFUNCTION\fR
	\*CNOSIDE EFFECTS\fR
.fi
.ME
$
$ Error : 1040
$msg  1040 "%s" has been declared and used as a dummy argument, therefore it must not be used as a derived-type name.
$nexp 1040
Error : "%s" has been declared and used as a dummy argument, therefore it must not be used as a derived-type name.
.PP
The compiler detected a conflict in uses of this object.  The object is
a dummy argument, which prohibits it from being used as a derived-type name.
.ME
$
$ Error : 1041
$msg  1041 Dummy procedure "%s" is called within a parallel region and must be in the shared list if autoscope is not specified.
$nexp 1041
Error : Dummy procedure "%s" is called within a parallel region and must be in the shared list if autoscope is not specified.
.PP
All dummy procedures called in a parallel region or DOALL loop must be in 
the shared list if autoscope is not specified. Autoscope is not
supported in this release of the compiler; therefore, all scopes must be
specified explicitly.
.ME
$
$ Error : 1042
$msg  1042 The compiler could not successfully write intermediate file "%s".
$nexp 1042
Error : The compiler could not successfully write intermediate file "%s".
.PP
The compiler could not complete writing the intermediate file, most likely
due to insufficient free disk space.
.ME
$
$ Error : 1043
$msg  1043 The compiler cannot open intermediate file "%s".
$nexp 1043
Error : The compiler cannot open intermediate file "%s".
.PP
The compiler cannot open the specified intermediate file for output.
.ME
$
$ Internal : 1044
$msg  1044 Internal : %s
$nexp 1044
Internal : Internal : %s
.PP
The intermediate file generator detected an internal error condition.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Summary : 1045
$msg  1045 openf95: Open64 Fortran Version %s (openf95:%s mif:%03d) %s
$nexp 1045
Log_Summary : openf95: Open64 Fortran Version %s (openf95:%s mif:%03d) %s
.PP
This identifies which version and release of the compiler is being used.
.ME
$
$ Caution : 1046
$msg  1046 The bounds needed for automatic variable "%s" are not available at all entry points.
$nexp 1046
Caution : The bounds needed for automatic variable "%s" are not available at all entry points.
.PP
A bound for an automatic variable can contain dummy arguments.  The compiler
has found one or more entry points where the dummy argument is not specified,
so that the length of the automatic variable cannot be determined at all 
entry points.   At entry points where the length cannot be determined, a
zero length variable will be allocated.
.ME
$
$ Error : 1047
$msg  1047 Typeless or BOZ constant is not allowed because the DO-variable is type DOUBLE PRECISION.
$nexp 1047
Error : Typeless or BOZ constant is not allowed because the DO-variable is type DOUBLE PRECISION.
.PP
A typeless or BOZ constant is limited to one word when used in an arithmetic
context.  Assignment of such a typeless or BOZ constant to a variable of type
DOUBLE PRECISION is not allowed.  Similarly, such a constant must not be
a DO loop expression when the DO-variable is of type DOUBLE PRECISION.
.ME
$
$ Internal : 1048
$msg  1048 Invalid operator encountered in change_to_base_and_offset.
$nexp 1048
Internal : Invalid operator encountered in change_to_base_and_offset.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1049
$msg  1049 Invalid form to operator Init_Reloc_Opr found in cvrt_exp_to_pdg.
$nexp 1049
Internal : Invalid form to operator Init_Reloc_Opr found in cvrt_exp_to_pdg.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1050
$msg  1050 Invalid form of Implied_Do_Opr in expand_io_list.
$nexp 1050
Internal : Invalid form of Implied_Do_Opr in expand_io_list.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1051
$msg  1051 Object "%s" is data initialized, but does not have a storage type of static or common.
$nexp 1051
Internal : Object "%s" is data initialized, but does not have a storage type of static or common.
.PP
A compilation assumption is that data initialized objects must be in static
or common storage.  This object is not in static or common storage.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Error : 1052
$msg  1052 The TARGET environment variable has not been set.
$nexp 1052
Log_Error : The TARGET environment variable has not been set.
.PP
When compiling in the Distributed Programming Environment, the TARGET 
environment variable must be set to the name of the target machine.  For
example:

      % setenv TARGET cray-ymp
.ME
$
$ Error : 1053
$msg  1053 "%s" is both a MODULE name specified on a USE statement and an object use associated from MODULE "%s".
$nexp 1053
Error : "%s" is both a MODULE name specified on a USE statement and an object use associated from MODULE "%s".
.PP
The object specified is use associated into this scope from a module.  It is
also the name of a module specified on a USE statement.  Each module name
specified on a USE statement must be unique.
.ME
$
$ Error : 1054
$msg  1054 A 32 bit integer is not a valid argument to this intrinsic.
$nexp 1054
Error : A 32 bit integer is not a valid argument to this intrinsic.
.PP
The information returned from this intrinsic will not fit in a 32 bit
word.  The argument must be a 64 bit word.
.ME
$
$ Error : 1055
$msg  1055 Module file "%s" is incompatible with this compiling system.  Recompile the module with this compiling system.
$nexp 1055
Error : Module file "%s" is incompatible with this compiling system.  Recompile the module with this compiling system.
.PP
The compiler is attempting to read a module file created with an
incompatible compiler.  Recompile the module file with the current
compiler and command line options to ensure compatibility.
.ME
$
$ Error : 1056
$msg  1056 This is an invalid value for the NCOPIES argument.
$nexp 1056
Error : This is an invalid value for the NCOPIES argument.
.PP
This argument is a negative value and that is invalid.
.ME
$
$ Error : 1057
$msg  1057 Object "%s" has been USE associated twice from the same module but is not the sma object.
$nexp 1057
Error : Object "%s" has been USE associated twice from the same module but is not the sma object.
.PP
Later.
.ME
$
$ Internal : 1058
$msg  1058 Unexpected input to set_merge_link routine during use statement semantics.  Attribute "%s" has 3 indexes - %d %d and %d.
$nexp 1058
Internal : Unexpected input to set_merge_link routine during use statement semantics.  Attribute "%s" has 3 indexes - %d %d and %d.
.PP
An assumption is made in the set_mod_link routines that all duplicate attrs
from the same original module will merge into one attribute.  The compiler has
found a case were there are 3 different attribute indexes, rather than just 2.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1059
$msg  1059 Generic interface "%s" has both subroutine and function specific interfaces.
$nexp 1059
Error : Generic interface "%s" has both subroutine and function specific interfaces.
.PP
All the specific procedures in a generic interface must be functions or
subroutines.  Functions and subroutines cannot be mixed in a generic interface.
This generic interface has both subroutine and function specific procedures.
.ME
$
$ Internal : 1060
$msg  1060 Converting message file; libcif returned error status:  %s
$nexp 1060
Internal : Converting message file; libcif returned error status:  %s
.PP
This message should never be generated.  The compiler could not output the
messages it has generated.  Please notify your product support organization
with this error message number and any supporting information.  This message
does not indicate a problem with your code.
.ME
$
$ Warning : 1061
$msg  1061 Integer length %d is not supported on this hardware.  This directive is ignored.
$nexp 1061
Warning : Integer length %d is not supported on this hardware.  This directive is ignored.
.PP
Integer length 46 and 64 are not supported on a 32 bit hardware.
.ME
$
$ Error : 1062
$msg  1062 The argument is not in the valid range for this intrinsic.
$nexp 1062
Error : The argument is not in the valid range for this intrinsic.
.PP
The user has chosen an invalid numeric value as input to this intrinsic.
.ME
$
$ Internal : 1063
$msg  1063 Index %d is not a valid index for the %s table.
$nexp 1063
Internal : Index %d is not a valid index for the %s table.
.PP
This is an internal error that will only be issued in specially built
debug bounds checking compilers.  There is an out of bounds table    
reference to a symbol table or IR table.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Warning : 1064
$msg  1064 Optimization levels "%s" and "%s" are specified on the command line.  These cause the default "%s" to be reset to "%s".
$nexp 1064
Log_Warning : Optimization levels "%s" and "%s" are specified on the command line.  These cause the default "%s" to be reset to "%s".
.PP
The user has specified some optimization levels that require the compiler to
change the default optimization level to be compatible.  
.ME
$
$ Error : 1065
$msg  1065 Object "%s" has already been specified in a CACHE_ALIGN directive.
$nexp 1065
Error : Object "%s" has already been specified in a CACHE_ALIGN directive.
.PP
A variable or common block may not be specified in more than one
CACHE_ALIGN compiler directive.
.ME
$
$ Error : 1066
$msg  1066 Variable subobjects are not allowed in a CACHE_ALIGN compiler directive.
$nexp 1066
Error : Variable subobjects are not allowed in a CACHE_ALIGN compiler directive.
.PP
Only variable names and common blocks are allowed in CACHE_ALIGN
compiler directive lists. Variable subobjects are not allowed.
.ME
$
$ Error : 1067
$msg  1067 This object is not allowed in a CACHE_ALIGN compiler directive.
$nexp 1067
Error : This object is not allowed in a CACHE_ALIGN compiler directive.
.PP
Only variables and common blocks are allowed in a CACHE_ALIGN compiler
directive. Also, variables in common blocks are not allowed in a 
CACHE_ALIGN directive.
.ME
$
$ Log_Warning : 1068
$msg  1068 Optimization level "%s" is specified on the command line.  This causes the default "%s" to be reset to "%s".
$nexp 1068
Log_Warning : Optimization level "%s" is specified on the command line.  This causes the default "%s" to be reset to "%s".
.PP
The user has specified an optimization level that requires the compiler to
change a default optimization level to be compatible.  
.ME
$
$ Warning : 1069
$msg  1069 The %s optimization option is ignored, if the debugging level is %d.
$nexp 1069
Warning : The %s optimization option is ignored, if the debugging level is %d.
.PP
This optimization is ignored when this level of debugging is specified.  To
enable the optimization, a more optimized debugging level is needed.
.ME
$
$ Error : 1070
$msg  1070 This reference to the "%s" intrinsic must have an integer scalar result to be specified in a specification expression.
$nexp 1070
Error : This reference to the "%s" intrinsic must have an integer scalar result to be specified in a specification expression.
.PP
Intrinsics are allowed in specification expressions only if they have integer
scalar results.
.ME
$
$ Error : 1071
$msg  1071 Interface %s(%s) contains procedure "%s" which has dummy argument "%s".  This dummy argument must not be OPTIONAL.
$nexp 1071
Error : Interface %s(%s) contains procedure "%s" which has dummy argument "%s".  This dummy argument must not be OPTIONAL.
.PP
A dummy argument has the \*COPTIONAL\fR attribute, but the specific interface
it is declared in is a defined operator or defined assignment interface block.
.ME
$
$ Error : 1072
$msg  1072 Interface OPERATOR(%s) contains procedure "%s" which has dummy argument "%s".  This dummy argument must have INTENT(IN).
$nexp 1072
Error : Interface OPERATOR(%s) contains procedure "%s" which has dummy argument "%s".  This dummy argument must have INTENT(IN).
.PP
Within a defined operator interface block the intents of dummy arguments must
be specified with certain values.
The dummy arguments must have \*CINTENT(IN)\fR.
.ME
$
$ Error : 1073
$msg  1073 Interface %s(%s) contains procedure "%s" which has dummy procedure "%s".  A dummy procedure is not allowed.
$nexp 1073
Error : Interface %s(%s) contains procedure "%s" which has dummy procedure "%s".  A dummy procedure is not allowed.
.PP
Specific interfaces within a defined assignment or defined operator interface
block must have dummy arguments that are data objects.   Dummy procedures are
not allowed.
.ME
$
$ Error : 1074
$msg  1074 Interface ASSIGNMENT(=) contains procedure "%s" which has dummy argument "%s".  The dummy argument must have INTENT(%s).
$nexp 1074
Error : Interface ASSIGNMENT(=) contains procedure "%s" which has dummy argument "%s".  The dummy argument must have INTENT(%s).
.PP
Within a defined assignment interface block the intents of dummy
arguments must be specified with certain values.
The first dummy argument must have \*CINTENT(OUT)\fR or
\*CINTENT(INOUT)\fR.  The second dummy argument must have \*CINTENT(IN)\fR.
.ME
$
$ Error : 1075
$msg  1075 This argument may not be ALLOCATABLE or POINTER.
$nexp 1075
Error : This argument may not be ALLOCATABLE or POINTER.
.PP
This argument may not have the POINTER, or ALLOCATABLE attribute.
.ME
$
$ Ansi : 1076
$msg  1076 Arguments which have TYPELESS type are not standard.
$nexp 1076
Ansi : Arguments which have TYPELESS type are not standard.
.PP
TYPELESS is not allowed in this context.
.ME
$
$ Ansi : 1077
$msg  1077 Unused
$nexp 1077
Ansi : Unused
.PP
.ME
$
$ Error : 1078
$msg  1078 This use of generic interface "%s" is not valid.
$nexp 1078
Error : This use of generic interface "%s" is not valid.
.PP
The compiler detected a generic interface reference where a data object 
or function call was expected.  This is probably the result of a generic 
interface name without an actual argument list.
.ME
$
$ Internal : 1079
$msg  1079 Invalid type sent to arith.a folding routine.
$nexp 1079
Internal : Invalid type sent to arith.a folding routine.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1080
$msg  1080 The argument to the PRESENT intrinsic must be an unqualified name.
$nexp 1080
Error : The argument to the PRESENT intrinsic must be an unqualified name.
.PP
An interpretation of the Fortran standard has changed the wording of the
description of the argument to the PRESENT intrinsic function to read as
follows:

    A must be the name of an optional dummy argument that is accessible in
    the procedure in which the PRESENT function reference appears.

The word "name" in the Fortran standard is a technical term, defined to be
a letter followed by up to 30 alphanumeric characters.  A "name" therefore can 
not include a subscript list, substring expressions, the structure component
separator (%), etc. and thus the argument to the PRESENT intrinsic function
can not include any qualification.
.ME
$
$ Error : 1081
$msg  1081 Name qualification is not allowed in this context.
$nexp 1081
Error : Name qualification is not allowed in this context.
.PP
In this context (such as a value in a DATA statement value list), a named 
constant may appear, but not a subobject of a named constant.  For example:

       DATA (a(i), i = 1, t%i)  / p(i) * t%i /

In the above DATA statement, assume that T is a named constant structure and
P is a named constant array.  All of the references to subobjects of T and P
in the above DATA statement example are prohibited because an identifier in
each of these contexts must be the name of a named constant.  The name must
not be qualified by a subscript list or structure component name.
.ME
$
$ Error : 1082
$msg  1082 The iteration count is too large.
$nexp 1082
Error : The iteration count is too large.
.PP
The iteration count is calculated as follows:

  MAX( INT( (end-value - start-value + inc-value) / inc-value), 0)

The loop control expression values are such that the value that would 
represent the iteration count is larger than the largest integer that can
be represented.
.ME
$
$ Warning : 1083
$msg  1083 The magnitude of the final value of the DO variable is too large.
$nexp 1083
Warning : The magnitude of the final value of the DO variable is too large.
.PP
If the loop executes to completion, the magnitude of the final value of the
DO variable will be larger than the largest integer that can be represented
(if the increment value is positive), or smaller than the smallest negative
integer that can be represented (if the increment value is negative) in
an integer DO variable of the declared kind type value.

The final value of the DO variable is calculated from:

        start-value + iteration-count * increment-value

This message is issued for a DO statement of the following form on a machine
whose word size is 32 bits because the final value of the DO variable
would be 2147483648 (assume the DO variable is type default integer).  This
value is larger than the largest integer that can be represented.

        DO i = 1, 2147483647 

This message is also issued if the DO variable is of type nondefault integer
and the final value is out of range for the bit size of the kind type 
parameter of the DO variable.  For example:

        INTEGER(KIND=1) i
  
        DO i = 1, 1000

A kind type parameter value of 1 implies that variable I can only contain
integer values in the range -127 to +127.  The final value of the DO variable
is 1001 which is outside this range.
.ME
$
$ Error : 1084
$msg  1084 An implied-DO increment value of zero is not allowed.
$nexp 1084
Error : An implied-DO increment value of zero is not allowed.
.PP
The increment value for an implied-DO must not be zero.  This error
is issued if an increment value of zero is detected in an I/O implied-DO,
array constructor implied-DO, or DATA implied-DO.  Also, an increment
value that is dependent on the value of an outer implied-DO variable must not
evaluate to zero when the outer loop is iterated.
.ME
$
$ Error : 1085
$msg  1085 Namelist group "%s" has the PUBLIC attribute so namelist group object "%s" cannot have PRIVATE components.
$nexp 1085
Error : Namelist group "%s" has the PUBLIC attribute so namelist group object "%s" cannot have PRIVATE components.
.PP
If a namelist group name has the \*CPUBLIC\fR attribute, no item in the namelist
group object list can have the \*CPRIVATE\fR attribute. Also, a namelist
group list item of derived type may not have a component with the
\*CPRIVATE\fR attribute.
.ME
$
$ Warning : 1086
$msg  1086 More than one actual argument has been specified for argument "%s" of the %s intrinsic.
$nexp 1086
Warning : More than one actual argument has been specified for argument "%s" of the %s intrinsic.
.PP
The compiler recognized that more than one actual argument was specified for
a particular dummy argument.  This can result from two identical argument
keywords or an argument keyword and a positional argument for the same dummy
argument.
.ME
$
$ Error : 1087
$msg  1087 Argument "%s" to the %s intrinsic has the wrong rank.
$nexp 1087
Error : Argument "%s" to the %s intrinsic has the wrong rank.
.PP
A difference was detected between the rank of the actual argument and the
rank of the dummy argument for this intrinsic function.
.ME
$
$ Error : 1088
$msg  1088 Argument "%s" to the %s intrinsic has the wrong type.
$nexp 1088
Error : Argument "%s" to the %s intrinsic has the wrong type.
.PP
A difference was detected between the type of the actual argument and the
type of the dummy argument for this intrinsic function.
.ME
$
$ Error : 1089
$msg  1089 Argument "%s" to the %s intrinsic has the wrong kind type.
$nexp 1089
Error : Argument "%s" to the %s intrinsic has the wrong kind type.
.PP
A difference was detected between the kind type parameter of the actual
argument and the kind type parameter of the dummy argument for this
intrinsic function.
.ME
$
$ Error : 1090
$msg  1090 The %s intrinsic requires the "%s" argument.
$nexp 1090
Error : The %s intrinsic requires the "%s" argument.
.PP
A required argument to an intrinsic function was not specified.
.ME
$
$ Error : 1091
$msg  1091 The rank of this POINTER actual argument does not match the rank of POINTER dummy argument "%s".
$nexp 1091
Error : The rank of this POINTER actual argument does not match the rank of POINTER dummy argument "%s".
.PP
If the dummy argument is a POINTER, the actual argument must be a POINTER
and the types, type parameters, and ranks must agree.
.ME
$
$ Error : 1092
$msg  1092 Cray pointer "%s" has multiple pointees which are typed with differing numeric lengths.
$nexp 1092
Error : Cray pointer "%s" has multiple pointees which are typed with differing numeric lengths.
.PP
A Cray pointer may have multiple pointees, but if the pointer does, all the
pointees must be typed with types that have the same numeric length.  For
example:

          real(kind=4) :: A
          real(kind=8) :: B
          pointer(PA,A)
          pointer(PA,B)

This is illegal, because the length of a real(kind=4) type is shorter than
the length of a real(kind=8) type.

NOTE:  Cray character pointers are allowed to have multiple pointees with
       different character lengths.
.ME
$
$ Error : 1093
$msg  1093 The output argument of this intrinsic does not conform to the other actual arguments.
$nexp 1093
Error : The output argument of this intrinsic does not conform to the other actual arguments.
.PP
The output argument(s) of intrinsic subroutines must be conformable with
the other arguments to the intrinsic.
.ME
$
$ Error : 1094
$msg  1094 "%s" is declared as the statement function dummy argument, therefore it must not be used as an external function name.
$nexp 1094
Error : "%s" is declared as the statement function dummy argument, therefore it must not be used as an external function name.
.PP
A statement function dummy argument must be a scalar data object and must
be used as a scalar data object.  The following example illustrates the 
problem.  In the example, X is the statement function dummy argument, but
the reference to X in the statement function expression is to a function.

    PROGRAM P
    G(X) = X(3)
    END SUBROUTINE

.ME
$
$ Internal : 1095
$msg  1095 Invalid form of preparsed format constant.
$nexp 1095
Internal : Invalid form of preparsed format constant.
.PP
The preparser used for FORMAT statements returned an invalid result.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1096
$msg  1096 An assumed-size array is illegal in this context.
$nexp 1096
Error : An assumed-size array is illegal in this context.
.PP
The array arguments to the transformational intrinsic may not be assumed-
size arrays.
.ME
$
$ Ansi : 1097
$msg  1097 It is nonstandard to mix kind types in an equivalence group, if any object in the group is a non default numeric type.
$nexp 1097
Ansi : It is nonstandard to mix kind types in an equivalence group, if any object in the group is a non default numeric type.
.PP
If an \fIequivalence_object\fR is of an intrinsic type other than
default integer, default real, double precision real, default complex,
or default logical all objects in the equivalence set must be
of the same type with the same kind type parameter value.
.ME
$
$ Error : 1098
$msg  1098 "%s" is a MODULE name specified on a USE statement, so it must not be specified as a rename or only name.
$nexp 1098
Error : "%s" is a MODULE name specified on a USE statement, so it must not be specified as a rename or only name.
.PP
The compiler has found the name of the module specified in the rename or only
list.  The module name must not be renamed.  The following example shows the
problem:

       MODULE ABC
       integer one
       END MODULE

       PROGRAM P
       USE ABC, NEW_ABC => ABC      ! Illegal to rename module name
       END PROGRAM
.ME
$
$ Error : 1099
$msg  1099 An INTEGER variable has been used as a FORMAT specifier but was not specified in an ASSIGN statement.
$nexp 1099
Error : An INTEGER variable has been used as a FORMAT specifier but was not specified in an ASSIGN statement.
.PP
The use of an INTEGER variable as a FORMAT specifier is only allowed
if the variable has be used in an ASSIGN statement with a valid
FORMAT statement label. The compiler has detected that no ASSIGN
statement with this variable was encountered. 
.ME
$
$ Error : 1100
$msg  1100 I/O list items of a derived type which have a PRIVATE component are not allowed.
$nexp 1100
Error : I/O list items of a derived type which have a PRIVATE component are not allowed.
.PP
A derived-type object must not appear as an input/output list item
if any component ultimately contained within the object is not accessible
within the scoping unit containing the intput/output statement. This 
will happen when a derived-type object is use associated from a module
where the derived-type definition contains private components.
.ME
$
$ Error : 1101
$msg  1101 An identifier in a DATA value list must be the name of a scalar named constant.
$nexp 1101
Error : An identifier in a DATA value list must be the name of a scalar named constant.
.PP
The values in the value list of a DATA statement may be literal constants or
named constants.  If a named constant appears, it must be the name of a 
scalar named constant (not an array constant that is an array).  For example,
the following program is in error:

         INTEGER, PARAMETER :: f(2) = (/ 1, 2 /)
         INTEGER            :: array(2)
         DATA array /f/

F is the name of a named constant that is an array and thus must not appear
in a DATA statement value list.
.ME
$
$ Caution : 1102
$msg  1102 Cray pointer "%s" has multiple pointees with differing types.  This may be non portable.
$nexp 1102
Caution : Cray pointer "%s" has multiple pointees with differing types.  This may be non portable.
.PP
A Cray pointer may have multiple pointees, but to be portable, they all should
be typed with types that have the same numeric length.  For example:
   
             real(kind=4) :: A
             real(kind=8) :: B
             pointer(PA,A)
             pointer(PA,B)
   
This is legal on a 64-bit system, but if you port this code to a 32
bit system, A is stored in 32 bits and B is stored in 64 bits.  This
means pointer PA is pointing to 2 items that have different storage
sizes.  This will be flagged as illegal on 32 bit systems.

NOTE:  Cray character pointers are allowed to have multiple pointees with
       different character lengths.
.ME
$
$ Caution : 1103
$msg  1103 Procedure "%s" has the RECURSIVE attribute, so -ev (saveall option) will be ignored for this procedure.
$nexp 1103
Caution : Procedure "%s" has the RECURSIVE attribute, so -ev (saveall option) will be ignored for this procedure.
.PP
The -ev option tells the compiler to statically allocate all local variables in
the compilation unit.  If a procedure is recursive, statically allocating the
local variables has the potential to cause unwanted behavior from the compiler. 
Therefore, the compiler ignores the -ev option for all recursive procedures
and any procedures contained in the recursive procedures.  If the saveall
option is needed for a recursive procedure, specify the SAVE statement in
the procedure and in any contained procedures.
.ME
$
$ Log_Warning : 1104
$msg  1104 The -eR option overrides the -ev option.
$nexp 1104
Log_Warning : The -eR option overrides the -ev option.
.PP
The -eR option implies implicit recursion in all procedures in the compilation
unit.  The -ev option implies saveall for all procedures in the compilation
unit.  Specifying saveall for a recursive procedure may cause indeterminate or
unwanted results at execution time.  Therefore, the compiler does not allow the
-ev and -eR options to be specified on the commandling.  If the saveall option
is desired, specify the SAVE statement in each procedure in the compilation 
unit.
.ME
$
$ Error : 1105
$msg  1105 The unroll directive must be followed by EOS or a positive integer value <= 1024,  to be used for the unroll count.
$nexp 1105
Error : The unroll directive must be followed by EOS or a positive integer value <= 1024,  to be used for the unroll count.
.PP
The syntax for the UNROLL directive is:

           UNROLL[n]

  where n is an optional positive integer initialization expression used as
  the unroll count.

n must be <= 1024.
.ME
$
$ Error : 1106
$msg  1106 The SHAPE argument must have a constant size and must be less than 8.
$nexp 1106
Error : The SHAPE argument must have a constant size and must be less than 8.
.PP
The SHAPE argument to the RESHAPE intrinsic must be a one dimensional
array with a constant size.
.ME
$
$ Error : 1107
$msg  1107 Function "%s" must be the current function being compiled or a dummy procedure to be typed as assumed size character.
$nexp 1107
Error : Function "%s" must be the current function being compiled or a dummy procedure to be typed as assumed size character.
.PP
If a function is assumed-size character, it must be the current function
being compiled or be a dummy procedure.  The caller determines the character
length of the function.
.ME
$
$ Error : 1108
$msg  1108 The type of the actual argument, "%s", does not match "%s", the type of the dummy argument.
$nexp 1108
Error : The type of the actual argument, "%s", does not match "%s", the type of the dummy argument.
.PP
A difference was detected between the type of the actual argument and the
type of the dummy argument supplied in an explicit interface for the called
routine.
.ME
$
$ Ansi : 1109
$msg  1109 Initializing a member of blank common is nonstandard.
$nexp 1109
Ansi : Initializing a member of blank common is nonstandard.
.PP
An object is being initialized either by a \*CDATA\fR statement or by
initialization on a type declaration statement.  The object is a member
of blank common.  It is nonstandard to initialize a member of blank common.
If you wish to initialize a member of a common block, use a named common 
block.
.ME
$
$ Warning : 1110
$msg  1110 DOUBLE PRECISION is not supported on this platform.  REAL will be used.
$nexp 1110
Warning : DOUBLE PRECISION is not supported on this platform.  REAL will be used.
.PP
DOUBLE PRECISION is not supported on this platform.  The compiler will use
a REAL precision.
.ME
$
$ Error : 1111
$msg  1111 The external name following the equal on the compiler directive NAME must be a character literal.
$nexp 1111
Error : The external name following the equal on the compiler directive NAME must be a character literal.
.PP
Something other than a character literal constant was encountered following
the equal sign on a \*C!DIR$ NAME\fR line.
.ME
$
$ Error : 1112
$msg  1112 Invalid %s for %s. It must be a variable, array element or whole array reference.
$nexp 1112
Error : Invalid %s for %s. It must be a variable, array element or whole array reference.
.PP
The ENCODE and DECODE statements have not been extended to include newer Fortran
specific features. This means that only variables, array elements or 
whole arrays can be used as the destination or source. Character substrings,
array sections, derived type components, Fortran pointers, and 
allocatable arrays are not allowed. The use of internal file IO is 
recommended for these objects when they are type CHARACTER.
.ME
$
$ Error : 1113
$msg  1113 The %s specifier must be scalar.
$nexp 1113
Error : The %s specifier must be scalar.
.PP
This IO control item specifier must be a scalar expression, variable
or array element.
.ME
$
$ Internal : 1114
$msg  1114 Defines "%s" and "%s" are incompatible.  This compiler has not been built correctly.
$nexp 1114
Internal : Defines "%s" and "%s" are incompatible.  This compiler has not been built correctly.
.PP
This is an internal message that only comes out in debug mode.  # defines 
set in defines.h have been set in an incorrect combination.  Check defines.h
for the problem.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Limit : 1115
$msg  1115 The maximum number, %d, of alternate entries in one scope has been exceeded.
$nexp 1115
Limit : The maximum number, %d, of alternate entries in one scope has been exceeded.
.PP
An internal error condition has occured because an internal number has grown
too large for its field size.
.PP
Please notify your product support organization.  You may be able to
split your code into multiple program units so that compilation can
successfully complete.
.ME
$
$ Internal : 1116
$msg  1116 Defines "%s" or defines "%s" must be specified in defines.h under the appropriate build section.
$nexp 1116
Internal : Defines "%s" or defines "%s" must be specified in defines.h under the appropriate build section.
.PP
The compiler is built incorrectly.  One or the other of the listed defines
must be set under the section describing the compiler being built in defines.h.
This is an internal error and will only be seen when an internal compiler is
built.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1117
$msg  1117 Internal error in create_struct_argchck_tbl.
$nexp 1117
Internal : Internal error in create_struct_argchck_tbl.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1118
$msg  1118 The TASK COMMON statement is not supported on this platform.
$nexp 1118
Error : The TASK COMMON statement is not supported on this platform.
.PP
The task common block is not supported on this platform.
.ME
$
$ Internal : 1119
$msg  1119 Internal compiler error. The number of actual arguments does not match the number of dummy arguments for "%s".
$nexp 1119
Internal : Internal compiler error. The number of actual arguments does not match the number of dummy arguments for "%s".
.PP
This internal compiler error indicates that the call site processing of user 
or intrinsic calls encountered incorrect internal information concerning 
the interface of the program unit being called.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1120
$msg  1120 This is not a legal value for the DIM argument.
$nexp 1120
Error : This is not a legal value for the DIM argument.
.PP
The user has chosen a value that the compiler has determined to 
be invalid for the DIM argument to this intrinsic.  Please
check the standard for the correct range of values for the DIM
argument.
.ME
$
$ Error : 1121
$msg  1121 The NUMCPUS tasking directive is not allowed within a parallel region.
$nexp 1121
Error : The NUMCPUS tasking directive is not allowed within a parallel region.
.PP
This tasking implementation does not allow the \*NUMCPUS\fR tasking
directive to be specified within a parallel region.  A parallel region is
either a \*CDOALL\fR loop or a region of code delimited by a 
\*CPARALLEL\fR/\*CENDPARALLEL\fR pair.
.ME
$
$ Warning : 1122
$msg  1122 The value specified on the NUMCPUS tasking directive is "%d".  Its range must be 1 to 64 so it has been reset to "%d".
$nexp 1122
Warning : The value specified on the NUMCPUS tasking directive is "%d".  Its range must be 1 to 64 so it has been reset to "%d".
.PP
The value specified on the NUMCPUS tasking directive must be greater than zero
and less than or equal to 64.
.ME
$
$ Caution : 1123
$msg  1123 Arguments to the CNCALL tasking directive are ignored.
$nexp 1123
Caution : Arguments to the CNCALL tasking directive are ignored.
.PP
The compiler ignores arguments specified on the CNCALL tasking directive line.
.ME
$
$ Error : 1124
$msg  1124 The NUMCPUS tasking directive must have a value specified in the range of 1 to 64.
$nexp 1124
Error : The NUMCPUS tasking directive must have a value specified in the range of 1 to 64.
.PP
The NUMCPUS tasking directive must have a value specified in the range 1 to 64.
Syntax for the NUMCPUS directive is:   NUMCPUS(value)  where value is 
1 to 64 inclusive.
.ME
$
$ Error : 1125
$msg  1125 Invalid type of argument for VAL intrinsic.
$nexp 1125
Error : Invalid type of argument for VAL intrinsic.
.PP
Only scalar INTEGER, LOGICAL, and REAL variables and expressions are supported 
with the %VAL intrinsic function. If a program unit is the argument, the %val 
intrinsic has no affect. The address of the program unit is passed as if 
the %val intrinsic had not been used.
.ME
$
$ Error : 1126
$msg  1126 Object "%s", specified on the PERMUTATION tasking directive, must be an integer array.
$nexp 1126
Error : Object "%s", specified on the PERMUTATION tasking directive, must be an integer array.
.PP
The PERMUTATION tasking directive requires all objects specified on the
directive to be integer arrays.
.ME
$
$ Caution : 1127
$msg  1127 Bit value truncated in conversion.
$nexp 1127
Caution : Bit value truncated in conversion.
.PP
A typeless constant was used in an expression or assignment and the 
converion caused bits to be truncated. The following rules apply.

If it is a numeric typeless constant, (BOZ or boolean) and is larger
than the result type of the operation, bits are truncated on the left
side. If it is a hollerith constant, "H" hollerith constants are
truncated on the right side, "L" constants are truncated on the right side, 
and "R" constants are truncated on the left side. Character literal 
constants used as typeless (a compiler extension) are truncated on the right
side.
.ME
$
$ Error : 1128
$msg  1128 Common block "%s" is specified in a COMMON directive, therefore it must be specified in a COMMON statement.
$nexp 1128
Error : Common block "%s" is specified in a COMMON directive, therefore it must be specified in a COMMON statement.
.PP
If a common block is specified in a \*CCDIR$ (!DIR$)\fR \*CCOMMON\fR statement,
the common block must also be declared in a \*CCOMMON\fR statement.
.ME
$
$ Error : 1129
$msg  1129 Common block "%s" may be specified in a COMMON directive or as TASK COMMON, but it must not be specified as both.
$nexp 1129
Error : Common block "%s" may be specified in a COMMON directive or as TASK COMMON, but it must not be specified as both.
.PP
A common block must not be specified on both a \*CTASK COMMON\fR directive and
a \*CCOMMON\fR directive.   A common block must not be specified on both a
\*CTASK COMMON\fR statement and a \*CCOMMON\fR directive.
.ME
$
$ Warning : 1130
$msg  1130 The INTEGER(KIND=6) and INTEGER*6 declarations will be removed in the next release.
$nexp 1130
Warning : The INTEGER(KIND=6) and INTEGER*6 declarations will be removed in the next release.
.PP
Starting with the next release of the compiler, INTEGER(KIND=6) and INTEGER*6
declaration forms will no longer be accepted.

On 64-bit platforms which had a default of INTEGER(KIND=6), the new default
will be INTEGER(KIND=8).   Beginning with the next release on these platforms,
the command line option "-O fastint" combined with the default integer will
provide equivalent behavior to the current behavior for default integer.

On 32-bit platforms, INTEGER(KIND=6) and INTEGER*6 are currently mapped
to INTEGER(KIND=4) and INTEGER*4.  For larger integer types, use
INTEGER(KIND=8) which will provide a 64-bit integer type.
.ME
$
$ Log_Warning : 1131
$msg  1131 The "-i 46" option will be removed in the next release of openf95.  Use "-O fastint" instead.
$nexp 1131
Log_Warning : The "-i 46" option will be removed in the next release of openf95.  Use "-O fastint" instead.
.PP
The "-i 46" option is no longer relevant because different bit lengths are used
for fast integer operations on different architectures.  Therefore, the more
general "-O fastint" option has been introduced.  The "-i 46" option will be
removed in the next release of this compiler.  Use the "-O fastint" option 
instead.
.ME
$
$ Log_Warning : 1132
$msg  1132 File "%s" : "%s".  The compiler is attempting to open this file to search for module "%s".
$nexp 1132
Log_Warning : File "%s" : "%s".  The compiler is attempting to open this file to search for module "%s".
.PP
The compiler is attempting to open a file that was specified on the -p 
command line.  The open routine has returned the specified error.  The
compiler may also be attempting to open a temporary file that it previously
created during this compilation that contains information about a module
compiled during this compilation.
.ME
$
$ Error : 1133
$msg  1133 This Hollerith constant is longer than 256 bits.
$nexp 1133
Error : This Hollerith constant is longer than 256 bits.
.PP
A Hollerith constant used as a numeric constant cannot be longer than 256
bits. 
.ME
$
$ Error : 1134
$msg  1134 "%s" is already a symbolic constant, therefore it must not be given the %s attribute.
$nexp 1134
Error : "%s" is already a symbolic constant, therefore it must not be given the %s attribute.
.PP
N$PES is a special symbolic constant.  It is compiler defined as type INTEGER
and the type may not be changed.  No attributes may be given to N$PES.
It may be used as a symbolic constant in places where a symbolic constant is
legal.  The value of N$PES is set by a compiler command line option, a load
time option or a runtime option.
.ME
$
$ Error : 1135
$msg  1135 "%s" is already a symbolic constant, therefore it must not be declared as a %s.
$nexp 1135
Error : "%s" is already a symbolic constant, therefore it must not be declared as a %s.
.PP
N$PES is a special symbolic constant.  It is compiler defined as type INTEGER
and the type may not be changed.  No attributes may be given to N$PES.
It may be used as a symbolic constant in places where a symbolic constant is
legal.  The value of N$PES is set by a compiler command line option, a load
time option or a runtime option.
.ME
$
$ Error : 1136
$msg  1136 "%s" is a symbolic constant, therefore it must not be declared as a procedure or used as a derived type.
$nexp 1136
Error : "%s" is a symbolic constant, therefore it must not be declared as a procedure or used as a derived type.
.PP
N$PES is a special symbolic constant.  It is compiler defined as type INTEGER
and the type may not be changed.  No attributes may be given to N$PES.
It may be used as a symbolic constant in places where a symbolic constant is
legal.  The value of N$PES is set by a compiler command line option, a load
time option or a runtime option.
.ME
$
$ Error : 1137
$msg  1137 %s" is a scalar integer symbolic constant, therefore it must not be an array, typed as character, or be in common.
$nexp 1137
Error : %s" is a scalar integer symbolic constant, therefore it must not be an array, typed as character, or be in common.
.PP
N$PES is a special symbolic constant.  It is compiler defined as type INTEGER
and the type may not be changed.  No attributes may be given to N$PES.
It may be used as a symbolic constant in places where a symbolic constant is
legal.  The value of N$PES is set by a compiler command line option, a load
time option or a runtime option.
.ME
$
$ Error : 1138
$msg  1138 "%s" is a symbolic constant, therefore it must not be an object in a namelist group.
$nexp 1138
Error : "%s" is a symbolic constant, therefore it must not be an object in a namelist group.
.PP
N$PES is a special symbolic constant.  It is compiler defined as type INTEGER
and the type may not be changed.  No attributes may be given to N$PES.
It may be used as a symbolic constant in places where a symbolic constant is
legal.  The value of N$PES is set by a compiler command line option, a load
time option or a runtime option.
.ME
$
$ Error : 1139
$msg  1139 Only one work distribution must be specified on a DO PARALLEL directive.
$nexp 1139
Error : Only one work distribution must be specified on a DO PARALLEL directive.
.PP
More than one work distribution is illegal on a DO PARALLEL directive.
.ME
$
$ Warning : 1140
$msg  1140 Work distribution parameter NCPUS_CHUNKS is not supported on this platform.
$nexp 1140
Warning : Work distribution parameter NCPUS_CHUNKS is not supported on this platform.
.PP
Work distribution parameter NCPUS_CHUNKS is not supported on this platform.
The default is SINGLE and if no other work distribution is specified,
the default will be used.
.ME
$
$ Error : 1141
$msg  1141 Only variable names are allowed in a %s compiler directive.
$nexp 1141
Error : Only variable names are allowed in a %s compiler directive.
.PP
A name was encountered in a BOUNDS or NOBOUNDS compiler directive that was
not a variable or dummy argument.
.ME
$
$ Error : 1142
$msg  1142 The STACK directive must not be specified in the specification part of a MODULE.
$nexp 1142
Error : The STACK directive must not be specified in the specification part of a MODULE.
.PP
The STACK directive must not be specified in the specification part of a MODULE.
Default storage in the specification part of a MODULE is always static storage
and must not be changed with the STACK directive.
.ME
$
$ Error : 1143
$msg  1143 The STACK directive must not be specified inside an interface body or an interface block.
$nexp 1143
Error : The STACK directive must not be specified inside an interface body or an interface block.
.PP
The STACK directive must not be specified inside an interface body or an 
interface block.  The directive would have no meaning in this location.
.ME
$
$ Warning : 1144
$msg  1144 A SAVE statement with no save entity list and a %s directive are specified in the same scope.  SAVE takes precedence.
$nexp 1144
Warning : A SAVE statement with no save entity list and a %s directive are specified in the same scope.  SAVE takes precedence.
.PP
The compiler has detected a SAVE statement with no saved entity list and a
STACK or SYMMETRIC directive in the same scope.  The SAVE statement takes 
precedence over the directive.  The STACK directive tells the compiler to
put all local variables on the stack, but the SAVE statement tells the
compiler to put all local variable in static storage.  SAVE overrides because
it is a standard part of the Fortran language.  The SYMMETRIC directive,
available on MPP platforms also infers stack storage for local variables.
The same reasoning applies, make SAVE override SYMMETRIC.
.ME
$
$ Warning : 1145
$msg  1145 The result of 128 bit floating point operations currently may be of a lesser precision.
$nexp 1145
Warning : The result of 128 bit floating point operations currently may be of a lesser precision.
.PP
The result of 128 bit floating point operations currently may be of a lesser
precision.  This includes anything typed as DOUBLE PRECISION, DOUBLE
PRECISION*16, REAL (kind=16), REAL*16 and DOUBLE COMPLEX.
.ME
$
$ Warning : 1146
$msg  1146 The !DIR$ INTEGER=46 directive will be removed in the next release; "-O fastint" will provide equivalent behavior.
$nexp 1146
Warning : The !DIR$ INTEGER=46 directive will be removed in the next release; "-O fastint" will provide equivalent behavior.
.PP
openf95 will no longer support the !DIR$ INTEGER=46 directive in the next
release.  The f90 command line option "-O fastint" will provide equivalent
behavior.  

NOTE:   !DIR$ INTEGER=32 and !DIR$ INTEGER=64 will still be accepted.
.ME
$
$ Error : 1147
$msg  1147 The INLINE ALWAYS and the INLINE NEVER directives have both been specified for object "%s".  Only one may be specified.
$nexp 1147
Error : The INLINE ALWAYS and the INLINE NEVER directives have both been specified for object "%s".  Only one may be specified.
.PP
The compiler has found an INLINE ALWAYS and a INLINE NEVER directive specified
for the same object.  Only one of these directives may be specified for an
object.
.ME
$
$ Internal : 1148
$msg  1148 Can not build the message file.
$nexp 1148
Internal : Can not build the message file.
.PP
This message should never be generated.  The compiler encountered an error
or an unexpected occurrence when building the message file.  Please notify
your product support organization with this error message number and any
supporting information.  This message does not indicate a problem with your
code.
.ME
$
$ Warning : 1149
$msg  1149 N$PES has been referenced, but was not given a value with the -X option.  A value of 0 (zero) is being used for N$PES.
$nexp 1149
Warning : N$PES has been referenced, but was not given a value with the -X option.  A value of 0 (zero) is being used for N$PES.
.PP
Currently, F90_M only supports compile-time N$PES.  Any program that references
N$PES must supply a compile-time value for N$PES with the -X command line 
option.  The compiler will use a value of 0 for N$PES if a value is not 
supplied on the command line.
.ME
$
$ Internal : 1150
$msg  1150 Line number is invalid.
$nexp 1150
Internal : Line number is invalid.
.PP
Internal compiler error. Line number information on an operator
is not a valid number. This means it was not set correctly.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1151
$msg  1151 Module "%s" has been referenced in a USE statement.  It may not be redefined with a MODULE statement.
$nexp 1151
Error : Module "%s" has been referenced in a USE statement.  It may not be redefined with a MODULE statement.
.PP
The Fortran standard states that it is illegal to have two global names that
are the same.  This makes the following case illegal:

m.f:   module m
       integer :: i=2
       end module
       
m1.f:  program p
       use m
       ...
       end program

       module m			! This is illegal because a module m has been
                                ! previously referenced.
       integer :: i=4
       end module

       subroutine s()
       use m
       ...
       end subroutine
.ME
$
$ Error : 1152
$msg  1152 The size of the first (or only) dimension of MATRIX_B must equal the size of the last (or only) dimension of MATRIX_A.
$nexp 1152
Error : The size of the first (or only) dimension of MATRIX_B must equal the size of the last (or only) dimension of MATRIX_A.
.PP
The size of the first (or only) dimension of MATRIX_B must equal the size of the last (or only) dimension of MATRIX_A.
.ME
$
$ Error : 1153
$msg  1153 Invalid argument to the PACK intrinsic.
$nexp 1153
Error : Invalid argument to the PACK intrinsic.
.PP
The VECTOR argument to the PACK intrinsic must have the same type and
kind type parameters as the ARRAY argument.  Also, the VECTOR argument
must have rank one.
.ME
$
$ Error : 1154
$msg  1154 Invalid FIELD argument to the UNPACK intrinsic.
$nexp 1154
Error : Invalid FIELD argument to the UNPACK intrinsic.
.PP
The FIELD argument must have the same type and kind type parameters as the 
VECTOR argument.
.ME
$
$ Error : 1155
$msg  1155 The MASK argument must be conformable with ARRAY.
$nexp 1155
Error : The MASK argument must be conformable with ARRAY.
.PP
The MASK argument to the PACK intrinsic must be conformable with the
ARRAY argument.
.ME
$
$ Error : 1156
$msg  1156 Illegal value for the POS argument.
$nexp 1156
Error : Illegal value for the POS argument.
.PP
The POS argument must be nonnegative and less than BIT_SIZE(I).
.ME
$
$ Warning : 1157
$msg  1157 Module file "%s" was created with a previous compiler release.  It will not be supported by the next major release.
$nexp 1157
Warning : Module file "%s" was created with a previous compiler release.  It will not be supported by the next major release.
.PP
The module file was created with a previous major release of this compiler.
We guarantee upwards compatibility for one major release, so by the next
major release, this module file needs to be recreated.
.ME
$
$ Error : 1158
$msg  1158 An ELSE IF block must not follow an ELSE block.
$nexp 1158
Error : An ELSE IF block must not follow an ELSE block.
.PP
If an \*CIF\fR construct contains an \*CELSE\fR block, the \*CELSE\fR must be
the last block in the construct.  Thus, an \*CELSE IF\fR block can not follow
an \*CELSE\fR block.
.ME
$
$ Internal : 1159
$msg  1159 The library format parser is issuing message number "%d".  This message is unknown to the compiler.
$nexp 1159
Internal : The library format parser is issuing message number "%d".  This message is unknown to the compiler.
.PP
The library format parser and the compiler are out of sync.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Ansi : 1160
$msg  1160 The NULL edit descriptor is an extension to the Fortran standard.
$nexp 1160
Ansi : The NULL edit descriptor is an extension to the Fortran standard.
.PP
The compiler has detected ,, in a format specification.  The Fortran
standard does not allow a comma to follow a comma in a format specification.
.ME
$
$ Caution : 1161
$msg  1161 Alignment of variable "%s" in common "%s" may cause performance degradation.
$nexp 1161
Caution : Alignment of variable "%s" in common "%s" may cause performance degradation.
.PP
On 32-bit architectures, a performance advantage is gained if multi-word items
are aligned on a 64 bit boundary, rather than a 32 bit boundary.  The object
in question, is not aligned on a double word boundary because of its position
in the common block.  A 32-bit (default integer) size object may be inserted
before this object in the common block declaration.  This will cause the
object to be aligned on a 64-bit boundary.  A second option is to specify
-a dalign on the command line.  This will cause the compiler to insert
a 32-bit pad before the object.  A warning will be issued whenever this pad
is inserted.
.ME
$
$ Log_Warning : 1162
$msg  1162 -i 46 means -i %d on this platform.  -i 46  will be removed in the next release of this compiler.  
$nexp 1162
Log_Warning : -i 46 means -i %d on this platform.  -i 46  will be removed in the next release of this compiler.  
.PP
The -i 46 command line option will be treated as if -i 32 or -i64 (platform
dependent) was specified on the command line.  In the next release of this 
compiler, the -i 46 command line option will be removed.
.ME
$
$ Warning : 1163
$msg  1163 !DIR$ INTEGER=46 means INTEGER=%d on this platform.  The !DIR INTEGER=46 directive will be removed in the next release.
$nexp 1163
Warning : !DIR$ INTEGER=46 means INTEGER=%d on this platform.  The !DIR INTEGER=46 directive will be removed in the next release.
.PP
!DIR$ INTEGER=46 means !DIR$ INTEGER=32 or !DIR$ INTEGER=64, depending on the
platform.  After this release !DIR$ INTEGER=46 will no longer be supported.
.ME
$
$ Internal : 1164
$msg  1164 Internal compiler error in conditional compilation routine "%s".
$nexp 1164
Internal : Internal compiler error in conditional compilation routine "%s".
.PP
An internal compiler error occured within the routines that support
conditional compilation. 
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1165
$msg  1165 Conditional compilation has unexpected syntax.  Expected %s.
$nexp 1165
Error : Conditional compilation has unexpected syntax.  Expected %s.
.PP
While parsing a conditional compilation directive, a syntax error
was encountered. 
.ME
$
$ Error : 1166
$msg  1166 Conditional compilation blocking error.  %s.
$nexp 1166
Error : Conditional compilation blocking error.  %s.
.PP
A conditional compilation directive was encountered that was not
expected. This is a blocking error where conditional compilation
directives like ENDIF, ELSE, or ELIF, do not have corresponding
IF, IFDEF, or IFNDEF directives.
.ME
$
$ Error : 1167
$msg  1167 Conditional compilation error.  Identifier "%s" is referenced but not defined.
$nexp 1167
Error : Conditional compilation error.  Identifier "%s" is referenced but not defined.
.PP
An identifier was encountered in the expresion within a conditional
compilation directive that was not previously defined in a 
"#define" directive. 
.ME
$
$ Error : 1168
$msg  1168 Common block "%s" is specified in a CACHE_ALIGN directive, therefore it must be specified in a COMMON statement.
$nexp 1168
Error : Common block "%s" is specified in a CACHE_ALIGN directive, therefore it must be specified in a COMMON statement.
.PP
If a common block is specified in a \*CCDIR$ (!DIR$)\fR \*CCACHE_ALIGN\fR 
statement, the common block must also be declared in a \*CCOMMON\fR or a 
\*CTASK COMMON\fR statement.
.ME
$
$ Warning : 1169
$msg  1169 The !DIR$ [NO]MODINLINE must be specified within the scope of a module.
$nexp 1169
Warning : The !DIR$ [NO]MODINLINE must be specified within the scope of a module.
.PP
The compiler has detected a MODINLINE or NOMODINLINE directive 
within the scope of a PROGRAM, BLOCKDATA, external SUBROUTINE or external
FUNCTION.  This directive must only be specified in a module or inside of
any contained procedures within the module.
.ME
$
$ Warning : 1170
$msg  1170 The %s directive will no longer be available in the next release.
$nexp 1170
Warning : The %s directive will no longer be available in the next release.
.PP
The specified directive is being removed in the next major release.
.ME
$
$ Error : 1171
$msg  1171 An explicit type must be specified for object "%s", because -eI, the IMPLICIT NONE command line option is specified.
$nexp 1171
Error : An explicit type must be specified for object "%s", because -eI, the IMPLICIT NONE command line option is specified.
.PP
The -eI command line option causes an IMPLICIT NONE to be specified in each
procedure in the compilation.  This command line option is in effect for this
compilation.  The listed object needs to have an explicit type specified.
.ME
$
$ Log_Warning : 1172
$msg  1172 -s cf77types is for FORTRAN 77 programs only.  If used with Fortran 90/95 programs, unexpected behavior may result.
$nexp 1172
Log_Warning : -s cf77types is for FORTRAN 77 programs only.  If used with Fortran 90/95 programs, unexpected behavior may result.
.PP
The -s cf77types option is designed to make FORTRAN 77 programs that use an
asterisk in a noncharacter type declaration (such as INTEGER*8) continue 
to work in the manner in which they worked with the CF77 compiler.  This
compiler treats declarations using an asterisk the same as declarations using
kind type parameter values; for example, INTEGER*8 has the same meaning as 
INTEGER(KIND=8).  All new Fortran programs should be written with this in mind.

Note:  -s cf77types is replacing the -si option because it is a more 
       descriptive name.
.ME
$
$ Internal : 1173
$msg  1173 The value "%s" has been used as an align to size in align_bit_length.  Only 8, 16, 32 and 64 are valid bit sizes.
$nexp 1173
Internal : The value "%s" has been used as an align to size in align_bit_length.  Only 8, 16, 32 and 64 are valid bit sizes.
.PP
The align_bit_length utility routine taks as input a bit size.  This routine
currently only works with 8, 16, 32 and 64.  One of these values must be
passed to the utility routine.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1174
$msg  1174 The dope vector element length of %d has exceeded the maximum length of %d.
$nexp 1174
Error : The dope vector element length of %d has exceeded the maximum length of %d.
.PP
The dope vector element length was exceeded.
.ME
$
$ Error : 1175
$msg  1175 Integer overflow has occurred while calculating array bounds, character length or offset.
$nexp 1175
Error : Integer overflow has occurred while calculating array bounds, character length or offset.
.PP
The compiler does internal folding to calculate such things as array length,
stride between elements of an array, structure size, component size, size of
an object, offsets for storage assignment ect..  During one of tests 
calculations an integer overflow occurred.
.ME
$
$ Error : 1176
$msg  1176 The SHAPE array for the RESHAPE intrinsic function contains a negative value.
$nexp 1176
Error : The SHAPE array for the RESHAPE intrinsic function contains a negative value.
.PP
The SHAPE array for a RESHAPE intrinsic function call must not contain
any element that is negative.
.ME
$
$ Error : 1177
$msg  1177 Conditional compilation #error:  \"%s\".
$nexp 1177
Error : Conditional compilation #error:  \"%s\".
.PP
An #error conditional compilation directive was encountered.  The text of 
the directive is included with this error message.
.ME
$
$ Error : 1178
$msg  1178 The conditional compilation ERROR directive must not be continued.
$nexp 1178
Error : The conditional compilation ERROR directive must not be continued.
.PP
The message text used on a conditional compilation ERROR directive
must fit on one line. The length of the line is the length of the 
Fortran source line which is dependent on source form and the -N
command line option.
.ME
$
$ Internal : 1179
$msg  1179 Internal compiler error. Invalid use of %s in folder_driver call.
$nexp 1179
Internal : Internal compiler error. Invalid use of %s in folder_driver call.
.PP
The routine folder_driver was called with an improper type for the
operator result, or improper types for its arguments.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1180
$msg  1180 "%s" has already been named as a pointee in a POINTER statement.  It cannot be given character type now.
$nexp 1180
Error : "%s" has already been named as a pointee in a POINTER statement.  It cannot be given character type now.
.PP
A character pointee must be declared as an assumed-size character variable.
Character pointee arrays are not valid.
.ME
$
$ Error : 1181
$msg  1181 Module file "%s" must be recompiled. Its format is unsupported.
$nexp 1181
Error : Module file "%s" must be recompiled. Its format is unsupported.
.PP
The module file specified was compiled with a prerelease compiler or with
an old no longer supported compiler.  (We commit to supporting one major
release previous to the current release.)  The current version of the 
compiler has changed its module format and the module file has a format 
that is not supported. 

This message also issues when the compiler being used is older than the
compiler that was used to compile the module file.
.ME
$
$ Log_Error : 1182
$msg  1182 "-O taskinner" is specified, therefore "-O task2" or "-O task3" must be specified.
$nexp 1182
Log_Error : "-O taskinner" is specified, therefore "-O task2" or "-O task3" must be specified.
.PP
The optimization option "taskinner" was specified.  Therefore, either the 
optimization option "task2" or "task3" must also be specified.
.ME
$
$ Error : 1183
$msg  1183 Module file "%s" must be recompiled. It was created by a later release of the compiler
$nexp 1183
Error : Module file "%s" must be recompiled. It was created by a later release of the compiler
.PP
The module file specifed was compiled with a compiler that was a later
release than this compiler. Its has a format that is not supported by
this compiler and must be recompiled.
.ME
$
$ Warning : 1184
$msg  1184 Evaluation of this constant expression produced a NaN or other abnormal value.
$nexp 1184
Warning : Evaluation of this constant expression produced a NaN or other abnormal value.
.PP
When computing the value of a constant expression, the compiler encountered
an abnormal value such as a NaN.  A constant expression is an expression
involving only constants.  The value of the expression is determined at
compile time rather than at execution time.  This warning may occur during
an intermediate computation (for example, addition, subtraction,
multiplication, division, or exponentiation) or may occur when data
conversion is required during the computation (for example, converting from
double precision to real).
.ME
$
$ Log_Warning : 1185
$msg  1185 The "-O pattern" option is temporarily disabled.
$nexp 1185
Log_Warning : The "-O pattern" option is temporarily disabled.
.PP
libsci is not yet available so the "-O pattern" option is temporarily
disabled.  When specified, it is ignored.  
.ME
$
$ Error : 1186
$msg  1186 The actual argument to IACHAR and ICHAR must have length equal to one character.
$nexp 1186
Error : The actual argument to IACHAR and ICHAR must have length equal to one character.
.PP
The actual argument to \*CIACHAR\fR and \*CICHAR\fR must have length = 1.
.ME
$
$ Error : 1187
$msg  1187 The SHAPE argument specified is not valid for the SOURCE argument provided.
$nexp 1187
Error : The SHAPE argument specified is not valid for the SOURCE argument provided.
.PP
The number of elements in the array constructor provided for the SOURCE argument
is not equal to the product of the extents specified by the SHAPE argument.
.ME
$
$ Error : 1188
$msg  1188 The arguments to this bitwise intrinsic or operator must be the same size.
$nexp 1188
Error : The arguments to this bitwise intrinsic or operator must be the same size.
.PP
Arguments to bitwise intrinsics, such as AND and OR, must be the
same number of words long. On solaris, this is not allowed

      integer * 8 i
      real * 4 x

      print *, or(i,x)


Also, on solaris, this is not allowed.

      print *, i.or.x

.ME
$
$ Warning : 1189
$msg  1189 This numeric constant is out of range.
$nexp 1189
Warning : This numeric constant is out of range.
.PP
A numeric real constant was found to be out of range for the 
data type specified. This warning is issued to point out that
the overflow/underflow occured and the proper IEEE value (Inf, -Inf)
has been stored for the constant.
.ME
$
$ Internal : 1190
$msg  1190 Internal compiler error. Invalid type or constant sent to cvrt_str_to_cn.
$nexp 1190
Internal : Internal compiler error. Invalid type or constant sent to cvrt_str_to_cn.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1191
$msg  1191 Unsupported operator in expr_sem.
$nexp 1191
Internal : Unsupported operator in expr_sem.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Warning : 1192
$msg  1192 The "%s" option conflicts with the "%s" option.  The "%s" option is ignored.
$nexp 1192
Log_Warning : The "%s" option conflicts with the "%s" option.  The "%s" option is ignored.
.PP
Two options conflict.  The first option named in the message was specified on
the compiler command line before the second option named in the message.  The 
first option is ignored (the second option overrides it).  For example, if
"-O fastint" is specified on the command line and then "-i 64" is
specified, the "-O fastint" option is ignored ("-i 64" overrides it).
.ME
$
$ Caution : 1193
$msg  1193 Module "%s" is indirectly used in module "%s" and is from file "%s".  That file no longer exists.
$nexp 1193
Caution : Module "%s" is indirectly used in module "%s" and is from file "%s".  That file no longer exists.
.PP
When a module is used, the path and filename where the compiled module is found
are stored with the module information.  The loader uses this stored information
to find the compiled module for loading purposes.  (The module may contain
module procedures and/or initialized data that is needed in the load step.) 

An indirectly used module is when module B uses module A and then module C
uses module B.  Module A is then indirectly referenced in module C.  When
a module is indirectly used, the compiler checks to see if the compiled
module file is still available.  If the compiler can no longer detect the
compiled module file, this Caution message is issued.  Compilation will
successfully complete and does not depend on this compiled module file.
The load step does need the compiled module file, so its current location
must be specified on the load line. 
.ME
$
$ Ansi : 1194
$msg  1194 The use of the Dw.dEe edit descriptor is an extension to the Fortran standard.
$nexp 1194
Ansi : The use of the Dw.dEe edit descriptor is an extension to the Fortran standard.
.PP
The Dw.dEe edit descriptor is nonstandard.  Dw.d is a valid Fortran edit
descriptor.  It is the addition of the Ee that makes it nonstandard.
.ME
$
$ Warning : 1195
$msg  1195 Possible function result type conflict. -i32 changes the type of "%s" to a half word integer.  "%s" is not changed.
$nexp 1195
Warning : Possible function result type conflict. -i32 changes the type of "%s" to a half word integer.  "%s" is not changed.
.PP
Command line option -i32 has been used with this compilation.  On an MPP,
this option only assigns a half word of storage to an item declared to be
type default integer.  In this function, one or more results is of type
default integer and one or more results is of a type other than default
integer.  With -i32, the default integer result(s) is now only a half
word, rather than a full word of storage.  The type of the other result(s)
has not changed.  Using -s default32 will change all default types to
half word.
.ME
$
$ Log_Warning : 1196
$msg  1196 Command line option "%s" is being replaced by "%s".  "%s" will no longer be available in the next release.
$nexp 1196
Log_Warning : Command line option "%s" is being replaced by "%s".  "%s" will no longer be available in the next release.
.PP
In release 2 to be removed in release 3:
Command line option -O unroll is the same as -O unroll2.  Option -O nounroll
is the same as -O unroll0.  We are removing -O unroll and -O nounroll to avoid
duplication.  

In release 3 to be removed in release 4:
Command line option -si is the same as -scf77types. We are renaming -si
to -s cf77types so that we have a more descriptive name.

In release 3 to be removed in release 4:
-O fastint provides the same functionality as -i32.  Command line option 
-i32 will be removed.  -O nofastint provides the same functionality as -i64, 
so -i64 sill be removed.
.ME
$
$ Error : 1197
$msg  1197 The array subscript for dimension %d does not fall within the defined range.
$nexp 1197
Error : The array subscript for dimension %d does not fall within the defined range.
.PP
An array reference was encountered where a subscript was out of bounds 
for the array. The compiler will check array bounds at compile time if
-C is specified and the subscript and bounds values are constant. The
following code shows three cases where this message would be issued.

      integer i(10)
      i(11) = 1
      i(1:11:1) = 1
      i(-1:10:1) = 1
.ME
$
$ Caution : 1198
$msg  1198 Alignment of component "%s" in numeric sequence structure "%s" may cause performance degradation.
$nexp 1198
Caution : Alignment of component "%s" in numeric sequence structure "%s" may cause performance degradation.
.PP
On 32-bit architectures, a performance advantage is gained if multi-word items
are aligned on a 64 bit boundary, rather than a 32 bit boundary.  The component
in question, is not aligned on a double word boundary because of its position
in the derived type.  A 32-bit (default integer) size component may be inserted
before this component in the derived type declaration.  This will cause the
component to be aligned on a 64-bit boundary.  A second option is to specify
-a dalign on the command line.  This will cause the compiler to insert
a 32-bit pad before the component.  A warning will be issued whenever this pad
is inserted.  Following are two examples of this situation:
     
        ....
        TYPE X
         SEQUENCE
         INTEGER :: A
         COMPLEX :: B
        END TYPE

        TYPE(X) :: Q
        TYPE(X) :: R

        SAVE Q,R

    
  In the above example, we will assume that Q is at offset 0 in the local
  static storage block and R is at offset 96.  This means Q%B is not
  aligned on a double word boundary, but R%B is aligned on a double word
  boundary.

        ....
        TYPE A
         SEQUENCE
         COMPLEX :: X
         INTEGER :: Y
         COMPLEX :: Z
        END TYPE

  In this example, there is no way that the X component and the Z
  component can both be double aligned without a 32 bit pad being 
  inserted before component Z.
.ME
$
$ Log_Warning : 1199
$msg  1199 Inlining may not be combined with debugging.  Inlining has been turned off.
$nexp 1199
Log_Warning : Inlining may not be combined with debugging.  Inlining has been turned off.
.PP
Inlining does not work with debugging.
.ME
$
$ Internal : 1200
$msg  1200 An invalid name is being entered into a name table.  The name must not be NULL and must be greater than one in length.
$nexp 1200
Internal : An invalid name is being entered into a name table.  The name must not be NULL and must be greater than one in length.
.PP
The name being entered into a name table must be a valid name.  It must be
non-NULL and have a length greater than 0.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1201
$msg  1201 The offset or length for block or object "%s" must be constant.  It is not.
$nexp 1201
Internal : The offset or length for block or object "%s" must be constant.  It is not.
.PP
Offsets and block lengths may be based on N$PEs for common blocks, static blocks
and other user declared areas.  The compiler has detected the use of a 
N$PE constant being used where a true constant is required.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Inline : 1202
$msg  1202 Routine %s was not inlined because %s.
$nexp 1202
Inline : Routine %s was not inlined because %s.
.PP
There are conditions which inhibit a routine from being inlined.
For example:  routines containing ASSIGN statments cannot be inlined.
.ME
$
$ Internal : 1203
$msg  1203 Bad assumption in create_constructor_constant.
$nexp 1203
Internal : Bad assumption in create_constructor_constant.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Inline : 1204
$msg  1204 The call to %s was inlined.
$nexp 1204
Inline : The call to %s was inlined.
.PP
This routine was expanded in place.   The overhead of the call no
longer exists.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1205
$msg  1205 Dummy argument "%s" is longer than the actual argument.
$nexp 1205
Error : Dummy argument "%s" is longer than the actual argument.
.PP
An actual argument of type character is associated with a dummy argument
whose length is longer than that of the actual argument.  Actual arguments 
of type character must have a length that is greater than or equal to that 
of the associated dummy argument.
.ME
$
$ Error : 1206
$msg  1206 Asterisk is not allowed as UNIT control item specifier for this %s statement.
$nexp 1206
Error : Asterisk is not allowed as UNIT control item specifier for this %s statement.
.PP
The UNIT= specifier can only be an asterisk when used in a WRITE, PRINT, or
READ statement.
.ME
$
$ Error : 1207
$msg  1207 An asterisk can not be used as the UNIT control item specifier for unformatted I/O.
$nexp 1207
Error : An asterisk can not be used as the UNIT control item specifier for unformatted I/O.
.PP
In a READ, WRITE, or PRINT I/O statement, the UNIT specifier can not be 
an asterisk if the I/O is unformatted. 
.ME
$
$ Ansi : 1208
$msg  1208 A FMT or NML specifer without a keyword following a keyworded UNIT specifier is an extension to the Fortran standard.
$nexp 1208
Ansi : A FMT or NML specifer without a keyword following a keyworded UNIT specifier is an extension to the Fortran standard.
.PP
This compiler allows IO control lists that break the rules of keyworded 
arguments when the first specifier is the UNIT specifier with a UNIT= keyword 
and the second argument does not have a keyword. Ordinarily, this would be an
error in that the compiler would not know what the specifier without the
keyword is. In this case, and this case only, the compiler assumes that
the second specifier is the FORMAT or NAMELIST specifier.

      WRITE ( UNIT = 10, *) I

.ME
$
$ Inline : 1209
$msg  1209 Routine %s was conditionally expanded inline.
$nexp 1209
Inline : Routine %s was conditionally expanded inline.
.PP
Non-constant stride multipliers were detected in an array
mapping.   A conditional test was generated to determine if
the call should be executed or the inlined routine.
.ME
$
$ Error : 1210
$msg  1210 Subprograms that contain assigned GOTO statements cannot contain Autotasking directives.
$nexp 1210
Error : Subprograms that contain assigned GOTO statements cannot contain Autotasking directives.
.PP
An assigned GOTO statement was encountered within a subprogram that contains
Autotasking directives. Branches in or out of a parallel region are
not allowed and the assigned GOTO has this potential.
.ME
$
$ Error : 1211
$msg  1211 The character length for "%s" is dependent upon the runtime N$PES symbolic constant.  This is not allowed.
$nexp 1211
Error : The character length for "%s" is dependent upon the runtime N$PES symbolic constant.  This is not allowed.
.PP
Runtime N$PES must only be used for array bounds.  It must not be used to
declare character length.
.ME
$
$ Error : 1212
$msg  1212 An initialization expression must not contain symbolic constant "%s".
$nexp 1212
Error : An initialization expression must not contain symbolic constant "%s".
.PP
Symbolic constants are not allowed in initialization expressions.  These
must be true constants.  Examples where this is not allowed include
component bounds and kind types.
.ME
$
$ Internal : 1213
$msg  1213 "%s" for "%s" must be a constant or a symbolic constant tmp.
$nexp 1213
Internal : "%s" for "%s" must be a constant or a symbolic constant tmp.
.PP
ATD_OFFSET_IDX and SB_LEN_IDX must be constant values or symbolic constants
represented by compiler temps.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1214
$msg  1214 INTENT OUT dummy arguments must not have a constant passed as an actual argument.
$nexp 1214
Error : INTENT OUT dummy arguments must not have a constant passed as an actual argument.
.PP
The user has tried to map a constant actual argument onto an INTENT OUT
dummy argument.
.ME
$
$ Log_Warning : 1215
$msg  1215 Command line option "-du" must not be specified with "-O ieeeconform".  "-eu" is in effect.
$nexp 1215
Log_Warning : Command line option "-du" must not be specified with "-O ieeeconform".  "-eu" is in effect.
.PP
The -O ieeeconform option, available on IEEE platforms causes the resulting
executable code to conform more closely to the IEEE floating-point standard.

The -du option on IEEE platforms, causes a faster divide sequence to be used,
which may affect the results when converting to an integer value or when
comparing results with those obtained from another system that supports IEEE
floating-point arithmetic.  The -eu option on IEEE platforms causes a true
IEEE divide sequence to be generated.

Thus, since -O ieeeconform is requesting executable code to conform more
closely to the IEEE floating-point standard, -eu is in affect causing a 
true IEEE divide sequence to be geneated.
.ME
$
$ Log_Warning : 1216
$msg  1216 Command line option "-O ieeeconform" causes default option "-du" to be switched to "-eu".
$nexp 1216
Log_Warning : Command line option "-O ieeeconform" causes default option "-du" to be switched to "-eu".
.PP
The -O ieeeconform option, available on IEEE platforms causes the resulting
executable code to conform more closely to the IEEE floating-point standard.
   
The -du option on IEEE platforms, causes a faster divide sequence to be used,
which may affect the results when converting to an integer value or when
comparing results with those obtained from another system that supports IEEE
floating-point arithmetic.  The -eu option on IEEE platforms causes a true
IEEE divide sequence to be generated.
   
Thus, since -O ieeeconform is requesting executable code to conform more
closely to the IEEE floating-point standard, -eu is in affect causing a 
true IEEE divide sequence to be generated.
.ME
$
$ Error : 1217
$msg  1217 The %s autotasking directive is missing for this %s directive.
$nexp 1217
Error : The %s autotasking directive is missing for this %s directive.
.PP
All parallel and guarded regions must be terminated before entering or
terminating a scope or block. If a CONTAINS statement or END, END FUNCTION, 
or END SUBROUTINE statement is encountered while in a parallel region or 
guarded region, an error is issued. Also the parallel or guarded region
must be properly nested within or fully contain code blocks like IF,
DO, CASE, or WHERE constructs.

The WAIT and SEND autotasking directives are a pair, so if a WAIT directive
is specified, the SEND directive must also be specified.  Any IF, DO, CASE
and WHERE constructs must be fully contained within the WAIT/SEND region.
.ME
$
$ Log_Warning : 1218
$msg  1218 Implementation of command line option "%s" is deferred.
$nexp 1218
Log_Warning : Implementation of command line option "%s" is deferred.
.PP
Implementation of the specified command line is deferred until a future revision
or release.
.ME
$
$ Error : 1219
$msg  1219 This %s directive does not precede a DO loop construct.
$nexp 1219
Error : This %s directive does not precede a DO loop construct.
.PP
A DO PARALLEL or DO ALL autotasking directive was encountered where no DO 
loop construct was found. The DO PARALLEL directive can only be specified 
within a parallel region and must precede a DO loop. The DO ALL must not 
be specified within a parallel region and must precede a DO loop.
.ME
$
$ Error : 1220
$msg  1220 Illegal branch %s a %s autotasking region.
$nexp 1220
Error : Illegal branch %s a %s autotasking region.
.PP
It is illegal to branch into or out of a PARALLEL, DOALL, CASE, or GUARD
autotasking region. This includes GOTO statements as well as ERR=, EOF= 
or EOR= branches from IO statements and alternate return branches from
subroutine calls.
.ME
$
$ Log_Warning : 1221
$msg  1221 The -O command line option has been specified with no arguments.  It will be ignored.
$nexp 1221
Log_Warning : The -O command line option has been specified with no arguments.  It will be ignored.
.PP
The -O command line option specifies optimization options for compilation.
If it is specified with no arguments it is ignored and does not change any
optimization levels.
.ME
$
$ Error : 1222
$msg  1222 The FIELD argument to the UNPACK intrinsic does not conform to MASK.
$nexp 1222
Error : The FIELD argument to the UNPACK intrinsic does not conform to MASK.
.PP
The MASK and FIELD arguments must be conformable with the UNPACK intrinsic.
.ME
$
$ Error : 1223
$msg  1223 "%s" has the %s attribute, so it must not be an array whose bounds are determined by a symbolic constant expression.
$nexp 1223
Error : "%s" has the %s attribute, so it must not be an array whose bounds are determined by a symbolic constant expression.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be declared as an array whose bounds are determined by a 
symbolic constant expression, because it is equivalenced, data initialized,
typed as an assumed-length character and/or has one or more of the following
attributes:

           \*CALLOCATABLE\fR
           \*CDIMENSION\fR
           \*CPARAMETER\fR
           \*CSAVE\fR
           \*CPRIVATE\fR
           \*CPUBLIC\fR
           \*CPOINTER\fR
           \*CEXTERNAL\fR
           \*CINTRINSIC\fR
           \*CVFUNCTION\fR
           \*CNOSIDE EFFECTS\fR
.ME
$
$ Error : 1224
$msg  1224 "%s" is a %s, therefore it must not be an array whose bounds are determined by a symbolic constant expression.
$nexp 1224
Error : "%s" is a %s, therefore it must not be an array whose bounds are determined by a symbolic constant expression.
.PP
The compiler detected a conflict in declarations for this object.  The
object must not be an array whose bounds are determined by a symbolic 
constant expression.  because it has been declared to be one of the following:

           Cray pointer
           module procedure
           derived type
           generic interface
           namelist group
           statement function
           construct
           module
           block data
           program
.ME
$
$ Warning : 1225
$msg  1225 Character constant intrinsic argument has been converted to Hollerith.
$nexp 1225
Warning : Character constant intrinsic argument has been converted to Hollerith.
.PP
A character constant is used as an actual argument to an intrinsic function
that does not accept character arguments, but it does accept Boolean (or
Hollerith) arguments.  This compiler treats a character constant as Hollerith in
contexts in which a character constant is invalid and a Hollerith constant is
legal.
.ME
$
$ Limit : 1226
$msg  1226 The "-ea" option was specified so the compilation is aborting on the first error.
$nexp 1226
Limit : The "-ea" option was specified so the compilation is aborting on the first error.
.PP
If the \*C-ea\fR option is enabled, the compilation aborts after
encountering the first error.
.ME
$
$ Error : 1227
$msg  1227 "%s", in common block "%s", must not be initialized, because the block length is dependent on a symbolic constant.
$nexp 1227
Error : "%s", in common block "%s", must not be initialized, because the block length is dependent on a symbolic constant.
.PP
If a common block has an array whose length is based on a symbolic constant,
no members of the common block may be data initialized, because the offsets and
length of the block are based on symbolic constants.
.ME
$
$ Error : 1228
$msg  1228 "%s", in common block "%s", must not be equivalenced, because the block length is dependent on a symbolic constant.
$nexp 1228
Error : "%s", in common block "%s", must not be equivalenced, because the block length is dependent on a symbolic constant.
.PP
If a common block contains an array whose length is dependent on a symbolic
constant, no items in the common block may be equivalenced.  The offsets of
objects in the common block and the block length are based on symbolic 
constants.
.ME
$
$ Ansi : 1229
$msg  1229 The use of symbolic constant "%s" is non standard.
$nexp 1229
Ansi : The use of symbolic constant "%s" is non standard.
.PP
The use of symbolic constants, (constants whose values are not known until
load or runtime) is not part of the Fortran standard.
.ME
$
$ Error : 1230
$msg  1230 Entry point "%s" is an array based on symbolic constants.  There are multiple entry points, so this is not allowed.
$nexp 1230
Error : Entry point "%s" is an array based on symbolic constants.  There are multiple entry points, so this is not allowed.
.PP
If a function has alternate entry points, the function and its entry points
are equivalenced together.  Equivalencing is not allowed for arrays whose
length is determined by a symbolic constant expression, thus if a function
has multiple entry points, none of the entry points can have an array length
based on a symbolic constant expression.  An array-valued function with
no alternate entry points, may have an array length based on a symbolic
constant expression.
.ME
$
$ Log_Warning : 1231
$msg  1231 Command line options -Xm and -X # (where # is number of N$PES) are mutually exclusive.  -X %s takes precedence.
$nexp 1231
Log_Warning : Command line options -Xm and -X # (where # is number of N$PES) are mutually exclusive.  -X %s takes precedence.
.PP
Command line options -Xm and -X# are mutually exclusive.  -Xm means malleable.
N$PES should not be specified in the program.  -X #, says use # number of 
pes to compile this program with.  The compiler uses the last specified -X
option on the command line.
.ME
$
$ Error : 1232
$msg  1232 Command line option -Xm has been specified, so N$PES must not be used in a declaration statement.
$nexp 1232
Error : Command line option -Xm has been specified, so N$PES must not be used in a declaration statement.
.PP
-Xm means the program being compiled is malleable, therefore N$PES should not
be specified in the program unit declaration section.  N$PES must lnly be used
in executable code.  It must not be used to declare array bounds when -Xm is 
specified.  The compiler is issuing an error because it has found a reference
to N$PES in an array bounds declaration.
.ME
$
$ Error : 1233
$msg  1233 The %s directive must not be specified in the specification part of a MODULE.
$nexp 1233
Error : The %s directive must not be specified in the specification part of a MODULE.
.PP
The following directives are not allowed within the specification part of
a MODULE.

SYMMETRIC:  This directive causes stack based variables to be put on the 
            shared stack.  The specification part of a MODULE has no stack
            based variables, so the SYMMETRIC directive has no meaning in
            a MODULE.
.ME
$
$ Caution : 1234
$msg  1234 The SYMMETRIC directive does not apply to variable "%s" because the variable has the "%s" attribute.
$nexp 1234
Caution : The SYMMETRIC directive does not apply to variable "%s" because the variable has the "%s" attribute.
.PP
Specifying !DIR$ SYMMETRIC with no variable names, causes all variable stored
on the stack, to be stored on the shared stack.  The following attributes
prevent the variable from being stored on the shared stack:

TARGET
AUXILIARY

The variable will be stored on the non-shared stack.
.ME
$
$ Error : 1235
$msg  1235 Variable "%s" must not be specified with the !DIR$ SYMMETRIC directive because it is host associated.
$nexp 1235
Error : Variable "%s" must not be specified with the !DIR$ SYMMETRIC directive because it is host associated.
.PP
Host associated variables must not be specified with the SYMMETRIC directive.
.ME
$
$ Caution : 1236
$msg  1236 SYMMETRIC does not apply to variable "%s" because it is host associated.
$nexp 1236
Caution : SYMMETRIC does not apply to variable "%s" because it is host associated.
.PP
At this time host associated stack variables may not be stored on the shared
stack.  
.ME
$
$ Internal : 1237
$msg  1237 I/O problem in module processing.  I/O error is "%s".
$nexp 1237
Internal : I/O problem in module processing.  I/O error is "%s".
.PP
Module processing found an unexpected I/O problem.  strerror is used to 
give more clues as to what went wrong.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Error : 1238
$msg  1238 "%s" is an invalid argument to the -X command line option.  The argument to -X must be m or in the range 1 thru 2048.
$nexp 1238
Log_Error : "%s" is an invalid argument to the -X command line option.  The argument to -X must be m or in the range 1 thru 2048.
.PP
-X npes specifies the number of npes to use during execution.   npes must be
m (for malleable) or an integer in the range 1 thru 2048.
.ME
$
$ Error : 1239
$msg  1239 All objects in this equivalence set must be default numeric or numeric sequence derived type.  "%s" is not.
$nexp 1239
Error : All objects in this equivalence set must be default numeric or numeric sequence derived type.  "%s" is not.
.PP
From the Fortran standard:  "If an \fIequivalence-object\fR is of type 
default integer, default real, double precision real, default complex, default
logical, or numeric sequence type, all of the objects in the equivalence set 
must be of these types."

This compiler allows as an extension, the mixing of default numeric types with
default character type in an equivalence set.  Numeric sequence derived types
are not allowed to be mixed with default character or character sequence
derived types.
.ME
$
$ Error : 1240
$msg  1240 All objects in this equivalence set must be default character or character sequence derived type.  "%s" is not.
$nexp 1240
Error : All objects in this equivalence set must be default character or character sequence derived type.  "%s" is not.
.PP
From the Fortran standard:  "If an \fIequivalence-object\fR is of type
default character or character sequence type, all of the objects in the 
equivalence set must be of these types."

This compiler also allows as an extension, the mixing of default numeric types
with default character types.  Character sequence types are not allowed to be
mixed with default numeric types.
.ME
$
$ Error : 1241
$msg  1241 Object "%s" is a non-default intrinsic type.  All objects in this equivalence set must be the same type and kind type.
$nexp 1241
Error : Object "%s" is a non-default intrinsic type.  All objects in this equivalence set must be the same type and kind type.
.PP
From the Fortran standard:  "If an \fIequivalence-object\fR is of an 
intrinsic type other than default integer, default real, double precision real,
default complex, default logical or default character, all of the objects in
the equivalence set must be of the same type with the same kind type parameter 
value."
.ME
$
$ Error : 1242
$msg  1242 "%s" is a not a character or numeric sequence derived type, so all objects in the equivalence set must be the same type.
$nexp 1242
Error : "%s" is a not a character or numeric sequence derived type, so all objects in the equivalence set must be the same type.
.PP
From the Fortran standard:  "If an \fIequivalence-object\fR is of a
derived type that is not a numeric sequence or character sequence type, all 
of the objects in the equivalence set must be of the same type."
.ME
$
$ Ansi : 1243
$msg  1243 The .LG. operator is an extension to the Fortran standard.
$nexp 1243
Ansi : The .LG. operator is an extension to the Fortran standard.
.PP
The .LG. or <> operator is defined by the IEEE Floating Point standard but
is not defined in the Fortran standard. Support for this operator is
an extension to the Fortran standard.
.ME
$
$ Warning : 1244
$msg  1244 "%s" is type(%s) whose components are typed using -s default32.  Equivalence storage association may not be as expected.
$nexp 1244
Warning : "%s" is type(%s) whose components are typed using -s default32.  Equivalence storage association may not be as expected.
.PP
-s default32 causes all default types to be 32 bit based types rather than
64 bit based types.  In derived types, all components must be on a full word
boundary, so two components declared to be of 32 bit types are separated with
a 64 bit pad.
.ME
$
$ Error : 1245
$msg  1245 Object "%s" was not declared with co-dimensions.
$nexp 1245
Error : Object "%s" was not declared with co-dimensions.
.PP
A reference was encountered with the [..] co-dimension syntax but
the object was not declared with co-dimensions. The following 
example will produce this error.

      integer i(10)
      i(1)[3,4] = 1
      end


.ME
$
$ Error : 1246
$msg  1246 Precompiled procedure "%s" is incompatible with this compiling system.  Recompile with this compiling system.
$nexp 1246
Error : Precompiled procedure "%s" is incompatible with this compiling system.  Recompile with this compiling system.
.PP
The compiler is attempting to read a precompiled procedure for inlining.  The
precompiled procedure was created with an incompatible compiler.  Recompile
the procedure with the current compiler and command line options to 
ensure compatibility.
.ME
$
$ Error : 1247
$msg  1247 Precompiled procedure "%s" must be targeted for the same operating system as this compilation.
$nexp 1247
Error : Precompiled procedure "%s" must be targeted for the same operating system as this compilation.
.PP
The precompiled procedure being inlined must be targetted for the same 
operating system as this compilation.  Target operating systems may not be 
mixed.
.ME
$
$ Error : 1248
$msg  1248 Procedure "%s" and this compilation must both be compiled with "%s", or both must be compiled without the option.
$nexp 1248
Error : Procedure "%s" and this compilation must both be compiled with "%s", or both must be compiled without the option.
.PP
If the current compilation unit is being compiled with the listed option ,
each module it uses or each precompiled procedure it inlines must be 
compiled with the same options.  If the current compilation unit is
being compiled without the listed option, each module it uses or each
precompiled procedure it inlines must be compiled without the option.
.ME
$
$ Limit : 1249
$msg  1249 Module "%s" was compiled in this compilation, but the compiler can no longer find the module.
$nexp 1249
Limit : Module "%s" was compiled in this compilation, but the compiler can no longer find the module.
.PP
When a module is compiled, the compiler keeps the module information table 
in a temporary file during compilation.  When the module is specified in a 
USE statement the compiler attempts to read the module information table
from the temporary file.  Something has happened to the temporary file and
the compiler cannot read up the module.
.ME
$
$ Internal : 1250
$msg  1250 Expected to find "%s" in the global name table, but srch_global_name_tbl returned not found.
$nexp 1250
Internal : Expected to find "%s" in the global name table, but srch_global_name_tbl returned not found.
.PP
At certain points in compilation the global name table is searched for
names that were put in earlier during compilation.  This error is issued
when the expected name is not found.  This error should never happen.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Error : 1251
$msg  1251 The optional pad amount specified on the -apad[n] command line option must be between 0 and 4096.  %d is specified.
$nexp 1251
Log_Error : The optional pad amount specified on the -apad[n] command line option must be between 0 and 4096.  %d is specified.
.PP
An optional pad amount may be specified on the -apad[n] command line option.
This number must be a integer literal constant greater than zero and less than
4096.  The number specified is not within this range.
.ME
$
$ Log_Error : 1252
$msg  1252 The binary output file "%s" is the same as the binary output file created for inlinefrom file "%s".
$nexp 1252
Log_Error : The binary output file "%s" is the same as the binary output file created for inlinefrom file "%s".
.PP
The inlining information is stored in the binary output file.  When x.f
is specified with -Oinlinefrom=x.f, the compiler creates a file called x.o
which holds the inlining information.  If the following command line is
specified  -Oinlinefrom=x.f x.f, then x.o, created during the inlinefrom call
to the compiler is overwritten by the actual call to compile x.f.  A method
around this would be to specify an alternate binary file using -b file.o.
For example:

     -Oinlinefrom=x.f -b out.o x.f

.ME
$
$ Ansi : 1253
$msg  1253 The %s statement is an extension to the Fortran standard.
$nexp 1253
Ansi : The %s statement is an extension to the Fortran standard.
.PP
The AUTOMATIC statement is an extension to the Fortran standard.
The VOLATILE statement is an extension to the Fortran standard.
The IMPLICIT UNDEFINED statement is an extension to the Fortran standard.
The IMPLICIT AUTOMATIC statement is an extension to the Fortran standard.
The IMPLICIT STATIC statement is an extension to the Fortran standard.
.ME
$
$ Ansi : 1254
$msg  1254 The %s attribute is an extension to the Fortran standard.
$nexp 1254
Ansi : The %s attribute is an extension to the Fortran standard.
.PP
The AUTOMATIC attribute is an extension the Fortran standard.
The VOLATILE attribute is an extension the Fortran standard.
.ME
$
$ Error : 1255
$msg  1255 "%s" must not have the AUTOMATIC attribute as it is an array, pointer, character or a derived type function result.
$nexp 1255
Error : "%s" must not have the AUTOMATIC attribute as it is an array, pointer, character or a derived type function result.
.PP
The AUTOMATIC attribute must not be given to a function result that is
array valued or pointer valued, or that is of type character or derived type.
.ME
$
$ Error : 1256
$msg  1256 Object "%s" has the %s attribute, so it must not be equivalenced to an object in a common block.
$nexp 1256
Error : Object "%s" has the %s attribute, so it must not be equivalenced to an object in a common block.
.PP
The user tried to equivalence a saved object to a common block or an object
with the AUTOMATIC attribute to a common block.
.ME
$
$ Error : 1257
$msg  1257 Object "%s" has the %s attribute, so all objects in this equivalence group must have the %s attribute.
$nexp 1257
Error : Object "%s" has the %s attribute, so all objects in this equivalence group must have the %s attribute.
.PP
If one object in an equivalence group has the AUTOMATIC attribute, all objects
in the equivalence group must have the AUTOMATIC object. 
.ME
$
$ Error : 1258
$msg  1258 Module "%s" contains objects whose type is integer(kind=6) or integer*6.  This is no longer supported.
$nexp 1258
Error : Module "%s" contains objects whose type is integer(kind=6) or integer*6.  This is no longer supported.
.PP
A warning was issued in the previous release alerting users that the compiler
will no longer support the integer*6 and integer(kind=6) types.  Objects have
been found of this type in the module being used.  The integer*6 and/or
integer(kind=6) declarations must be changed and the module recompiled.
.ME
$
$ Warning : 1259
$msg  1259 "%s" (which first appeared at line %d) has been given the %s attribute more than once.
$nexp 1259
Ansi : "%s" (which first appeared at line %d) has been given the %s attribute more than once.
.PP
It is nonstandard to declare an object as having the same attribute mutiple
times.
.ME
$
$ Error : 1260
$msg  1260 Prefix-spec %s is specified twice for this subprogram.
$nexp 1260
Error : Prefix-spec %s is specified twice for this subprogram.
.PP
The same prefix-spec may not be specified more than once for a subprogram.
A prefix-spec may be RECURSIVE, PURE, ELEMENTAL and/or type-spec.  
type-spec is a valid type specification such as INTEGER, CHARACTER*(10) or
TYPE (derived_type_name).
.ME
$
$ Error : 1261
$msg  1261 RECURSIVE and ELEMENTAL must not be specified for the same subprogram.
$nexp 1261
Error : RECURSIVE and ELEMENTAL must not be specified for the same subprogram.
.PP
A constraint in the Fortran standard prohibits prefix-specs
RECURSIVE and ELEMENTAL from being specified for the same program unit.
.ME
$
$ Error : 1262
$msg  1262 A %s statement is not allowed within %s subprogram "%s".
$nexp 1262
Error : A %s statement is not allowed within %s subprogram "%s".
.PP
The following statements are not allowed within PURE subprograms.

  print statement
  open statement
  close statement
  backspace statement
  endfile statement
  rewind statement
  inquire statement
  stop statement
  pause statement

This is a constraint to pure procedures (12.6).  By definition an elemental
procedure is a pure procedure, so these constraints apply to an elemental
procedure as well.
.ME
$
$ Error : 1263
$msg  1263 A %s statement whose io-unit is an external-file-unit or *, is not allowed in %s subprogram "%s".
$nexp 1263
Error : A %s statement whose io-unit is an external-file-unit or *, is not allowed in %s subprogram "%s".
.PP
A constraint to pure procedures (12.6) prohibits read and write statements whose
io-unit is an external-file-name or * to be specified in a pure subprogram.
By definition an elemental procedure is a pure procedure, so this constraint
applies to elemental procedures as well.
.ME
$
$ Error : 1264
$msg  1264 Variable "%s" in %s subprogram "%s" must not be given the %s attribute.
$nexp 1264
Error : Variable "%s" in %s subprogram "%s" must not be given the %s attribute.
.PP
Variables in a pure subprogram must not be given the SAVE or data-initialization
attributes.  By definition an elemental procedure is a pure procedure, so
this constraint applies to elemental procedures as well.
.ME
$
$ Error : 1265
$msg  1265 Non-pointer dummy argument "%s" to %s FUNCTION "%s" must have INTENT(IN) specified for it.
$nexp 1265
Error : Non-pointer dummy argument "%s" to %s FUNCTION "%s" must have INTENT(IN) specified for it.
.PP
The specification part of a pure FUNCTION shall specify that all dummy arguments
have INTENT(IN) except procedure arguments (dummy procedures) and arguments with
the POINTER attribute.

By definition all elemental FUNCTIONS are pure, so this applies to elemental
FUNCTIONS as well.
.ME
$
$ Error : 1266
$msg  1266 Non-pointer dummy argument "%s" to %s SUBROUTINE "%s" must have an intent specified for it.
$nexp 1266
Error : Non-pointer dummy argument "%s" to %s SUBROUTINE "%s" must have an intent specified for it.
.PP
The specification part of a pure subroutine shall specify the intents of all
dummy arguments except procedure arguments (dummy procedures), alternate return
indicators and arguments with the POINTER attribute.

By definition, elemental procedures are pure procedures, so this applies to
elemental subroutines also.
.ME
$
$ Error : 1267
$msg  1267 "%s" is a dummy argument to elemental subprogram "%s", so it must be a non-pointer scalar dummy argument.
$nexp 1267
Error : "%s" is a dummy argument to elemental subprogram "%s", so it must be a non-pointer scalar dummy argument.
.PP
A constraint in the Fortran standard requires all dummy arguments to
elemental subprograms to be non-pointer and scalar.  The dummy arguments
must not be dummy procedures either.
.ME
$
$ Error : 1268
$msg  1268 "%s" is an elemental function, so its function result "%s" must be scalar and cannot be a pointer.
$nexp 1268
Error : "%s" is an elemental function, so its function result "%s" must be scalar and cannot be a pointer.
.PP
A constraint in the Fortran standard requires function results for an elemental 
function to be scalar.  They must not be pointers.
.ME
$
$ Error : 1269
$msg  1269 An alternate return specifier is not allowed as a dummy argument to elemental SUBROUTINE "%s".
$nexp 1269
Error : An alternate return specifier is not allowed as a dummy argument to elemental SUBROUTINE "%s".
.PP
A constraint in the Fortran standard states that a dummy argument to
an elemental subroutine must not be *.  * is the alternate return specifier.
.ME
$
$ Error : 1270
$msg  1270 "%s" must not be modified or used as a pointer target inside of a %s subprogram, because it is in common, a dummy argument, host associated, or use associated.
$nexp 1270
Error : "%s" must not be modified or used as a pointer target inside of a %s subprogram, because it is in common, a dummy argument, host associated, or use associated.
.PP
A PURE or ELEMENTAL procedure must be free of side effects: that is, it
must not modify data visible outside the procedure. This ensures that it is
safe to call such a procedure in a FORALL assignment which might optimize
by evaluating in any order.

This imposes constraints on how the procedure uses variables in common,
variables accessed by host or use association, dummy variables with
INTENT(IN), and (in a function) dummy variables with the POINTER attribute.
The procedure must not modify such a variable; must not
use such a variable as the target of a pointer assignment; and must not use it
as an actual argument associated with a dummy argument which has INTENT(OUT),
INTENT(INOUT), or the POINTER attribute.

In addition, if the variable is a derived type containing a pointer (directly
or via a component of derived type), the procedure must not assign it to
another variable of derived type, because that would have the effect of a
pointer assignment.
.ME
$
$ Error : 1271
$msg  1271 "%s" is a dummy procedure to pure subprogram "%s".  It must be specified with the PURE attribute.
$nexp 1271
Error : "%s" is a dummy procedure to pure subprogram "%s".  It must be specified with the PURE attribute.
.PP
A constraint to PURE procedures, states that the specification-part of a
pure subprogram shall specify that all dummy arguments that are procedure
arguments are pure.  In other words if there is a dummy procedure specified for
a pure subprogram, that dummy procedure must have an explicit interface and
that interface must specify it as pure.

Dummy procedures must not be specified in elemental subprograms.
.ME
$
$ Error : 1272
$msg  1272 "%s" is an internal subprogram to %s subprogram "%s".  It must be given the %s prefix-spec.
$nexp 1272
Error : "%s" is an internal subprogram to %s subprogram "%s".  It must be given the %s prefix-spec.
.PP
A constraint to PURE procedures in the Fortran standard states that all
internal subprograms in a pure subprogram shall be pure.  In other words,
if an external subprogram is a pure subprogram, all its internal subprograms
must also be declared as pure subprograms.

By definition an elemental subprogram is pure, so the above constraint also
applies to elemental subprograms.
.ME
$
$ Error : 1273
$msg  1273 "%s" must not be argument associated with "%s" in a %s subprogram.
$nexp 1273
Error : "%s" must not be argument associated with "%s" in a %s subprogram.
.PP

A constraint to PURE procedures, prohibits all dummy arguments to a
function subprogram and all dummy arguments with the INTENT(IN) attribute 
with a subroutine subprogram, as weel as a common, host associated or
use associated variable from being used as an actual argument associated
with a dummy argument with INTENT(out) or INTENT(inout) or with the POINTER
attribute.

By definition, an elemental subprogram is pure, so the above constraint also
applies to all dummy arguments within elemental subprograms.
.ME
$
$ Error : 1274
$msg  1274 Procedure "%s" must be %s, because it is referenced in a %s subprogram.
$nexp 1274
Error : Procedure "%s" must be %s, because it is referenced in a %s subprogram.
.PP
A constraint to PURE procedures states that any procedure referenced in a
pure subprogram, including one referenced via a defined operation or assignment
shall be pure.  A related constraint states that any procedure that is neither 
an intrinsic procedure nor a statement function and is referenced in a context
requiring it to be pure, must have an explicit interface in the same scope as
the reference.

By definition an elemental procedure is also a pure procedure, so all 
constraints that apply to pure procedures, also apply to elemental procedures.
.ME
$
$ Warning : 1275
$msg  1275 Common block "%s" is used in multiple program units and has different lengths in the different program units.
$nexp 1275
Warning : Common block "%s" is used in multiple program units and has different lengths in the different program units.
.PP
During cross compilation semantics, the compiler has detected the same common
block being used in multiple program units.  The length of the common block
varies in the program units.
.ME
$
$ Warning : 1276
$msg  1276 Common block "%s" is used in multiple program units.  It must be in %s storage in all uses.
$nexp 1276
Warning : Common block "%s" is used in multiple program units.  It must be in %s storage in all uses.
.PP
During cross compilation semantics, a common block was used in multiple program 
units.  If the common block is in AUXILIARY storage in one program unit, it
must be in AUXILIARY storage in all program units.  If the common block is
in TASK COMMON storage in one program unit, it must be in TASK COMMON storage
in all program units.
.ME
$
$ Error : 1277
$msg  1277 Procedure "%s" is %s at line %s.  It must have an explicit interface specified.
$nexp 1277
Error : Procedure "%s" is %s at line %s.  It must have an explicit interface specified.
.PP
12.3.1.1 The Fortran standard requires an explicit interface in the following
         situations:

   A procedure other than a statement function shall have an explicit interface
   if the procedure is elemental or the procedure has
       (a) An optional or volatile dummy argument
       (b) A dummy argument that is an assumed-shape array, a pointer or a
           target
       (c) An array-valued result (functions only.)
       (d) A result that is a pointer (functions only)
       (e) A result whose character length parameter value is not assumed and
           not constant


   During global semantics the compiler has detected a call to an external
   procedure and has found an explicit interface for that procedure in
   another program unit during compilation.  The explicit interface for that
   procedure describes the procedure as having one or more of the above
   characteristics.  These characteristics require that an explicit interface
   be specified for this program unit in all program units that reference this
   procedure.
.ME
$
$ Warning : 1278
$msg  1278 Procedure "%s" is defined at line %s.  Dummy argument "%s" is scalar.  This argument is an array argument.
$nexp 1278
Warning : Procedure "%s" is defined at line %s.  Dummy argument "%s" is scalar.  This argument is an array argument.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

The compiler is comparing two definitions or a definition and a reference to 
the listed procedure.  If the compiler is comparing two definitions, then
the compiler has found that in one definition, a dummy argument is a scalar,
but the corresponding dummy argument in the second definition is an array
argument.  The arguments must be the same.  If the compiler is comparing
a reference with its definition, then it has found a scalar dummy argument
associated with an array actual argument or vice versa.  Again, the arguments
must either both be scalar or both be arrays.  (Note:  In a reference, an
array element is considered a scalar.)
.ME
$
$ Warning : 1279
$msg  1279 Procedure "%s" is defined at line %s.  The type of this argument does not agree with dummy argument "%s".
$nexp 1279
Warning : Procedure "%s" is defined at line %s.  The type of this argument does not agree with dummy argument "%s".
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

The type of two corresponding dummy arguments for the same procedure
must agree.  The type of an actual arguments associated with a dummy
argument must agree.
.ME
$
$ Warning : 1280
$msg  1280 Directive "%s" is being replaced by "%s".  "%s" will no longer be available in the next release.
$nexp 1280
Warning : Directive "%s" is being replaced by "%s".  "%s" will no longer be available in the next release.
.PP
Directive MODINLINE is the same as directive INLINABLE.  Directive NOMODINLINE
is the same as directive NOININABLE.  We are removing !DIR$ MODINLINE and
!DIR$ NOMODINLINE because !DIR$ INLINABLE/NOINLINABLE is less specific.
MODINLINE/NOMODINLINE applies only to module procedures.  INLINABLE/NOINLINABLE
can apply to all external procedures.
.ME
$
$ Error : 1281
$msg  1281 This use of the COPY_ASSUMED_SHAPE directive is not allowed.
$nexp 1281
Error : This use of the COPY_ASSUMED_SHAPE directive is not allowed.
.PP
The COPY_ASSUMED_SHAPE directive can be used in two ways. With an argument
list, it specifies a group of conformant assumed shape dummy arguments
that are to be copied to contiguous arrays. Without a list, all assumed
shape dummy arguments are assumed to be conformant. It is not allowed to
use both the directive with a list and one without a list.
.ME
$
$ Error : 1282
$msg  1282 "%s" is defined as a %s at line %s and as a %s in this program unit.
$nexp 1282
Error : "%s" is defined as a %s at line %s and as a %s in this program unit.
.PP
The scope of a global name is an entire compilation unit, so a global (or
external) name must only be declared once.

The compiler has found 2 separate program unit definitions for this object
during this compilation.  Even if they both define the item as a FUNCTION, a
message is still issued because this is a duplicate definition.

Something similar to the following has been found:

     function f()
     f = 2.0
     end function

     ...

     subroutine f()    ! A message is issued because f is both a function and
                       ! a subroutine.
     end subroutine
.ME
$
$ Error : 1283
$msg  1283 Global name "%s" is declared in an interface block as a %s at line %s, but is defined as a %s in this program unit.
$nexp 1283
Error : Global name "%s" is declared in an interface block as a %s at line %s, but is defined as a %s in this program unit.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block for
this program unit.  These should be the same.
.ME
$
$ Warning : 1284
$msg  1284 Procedure "%s" is defined at line %s and has %d dummy argument(s).  This interface has %d dummy argument(s) specified.
$nexp 1284
Warning : Procedure "%s" is defined at line %s and has %d dummy argument(s).  This interface has %d dummy argument(s) specified.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block for
this program unit.  These should be the same.

The number of dummy arguments differs between the actual program unit
definition and an interface block for this program unit.
.ME
$
$ Error : 1285
$msg  1285 The %s attribute is specified in either the program unit or interface block definition for "%s", but not in both.
$nexp 1285
Error : The %s attribute is specified in either the program unit or interface block definition for "%s", but not in both.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block for
this program unit.  These should be the same.

Attributes checked include pure, elemental and recursive.
.ME
$
$ Warning : 1286
$msg  1286 Type and/or rank for dummy argument "%s" to %s "%s" defined at line %s does not agree with this interface block.
$nexp 1286
Warning : Type and/or rank for dummy argument "%s" to %s "%s" defined at line %s does not agree with this interface block.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block for
this program unit.  These should be the same.

The type and rank of all dummy arguments must agree.
.ME
$
$ Warning : 1287
$msg  1287 Type and/or rank for result "%s" to function "%s" defined at line %s does not agree with this interface block.
$nexp 1287
Warning : Type and/or rank for result "%s" to function "%s" defined at line %s does not agree with this interface block.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block for
this program unit.  These should be the same.

The type and rank for the function result should be the same.
.ME
$
$ Error : 1288
$msg  1288 Global name "%s" is defined as a %s at line %s, but declared in this interface block as a %s.
$nexp 1288
Error : Global name "%s" is defined as a %s at line %s, but declared in this interface block as a %s.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block for
this program unit.  These should be the same.
.ME
$
$ Error : 1289
$msg  1289 A %s directive cannot be specified within a DO PARALLEL loop.
$nexp 1289
Error : A %s directive cannot be specified within a DO PARALLEL loop.
.PP
Nesting of another DO PARALLEL directive within a DO loop that was
specified as a DO PARALLEL loop is not allowed. The CASE directive
is also not allowed in this context.
.ME
$
$ Warning : 1290
$msg  1290 Type and/or rank for result "%s" to function "%s" in the interface block at line %s differs with this definition.
$nexp 1290
Warning : Type and/or rank for result "%s" to function "%s" in the interface block at line %s differs with this definition.
.PP
   During global semantics for this compilation, the compiler found that
   the actual program unit definition disagrees with an interface block for
   this program unit.  These should be the same.
   
   The type and rank for the function result should be the same.
.ME
$
$ Warning : 1291
$msg  1291 Type and/or rank for dummy argument "%s" to %s "%s" in the interface block at line %s differs with this definition.
$nexp 1291
Warning : Type and/or rank for dummy argument "%s" to %s "%s" in the interface block at line %s differs with this definition.
.PP
   During global semantics for this compilation, the compiler found that
   the actual program unit definition disagrees with an interface block for
   this program unit.  These should be the same.
   
   The type and rank of all dummy arguments must agree.
.ME
$
$ Warning : 1292
$msg  1292 The interface block for procedure "%s" at line %s has %d dummy argument(s).  The definition has %d dummy argument(s).
$nexp 1292
Warning : The interface block for procedure "%s" at line %s has %d dummy argument(s).  The definition has %d dummy argument(s).
.PP
   During global semantics for this compilation, the compiler found that
   the actual program unit definition disagrees with an interface block for
   this program unit.  These should be the same.
   
   The number of dummy arguments differs between the actual program unit
   definition and an interface block for this program unit.
.ME
$
$ Warning : 1293
$msg  1293 Program unit "%s" is defined as a %s at line %s, but is defined or referenced as a %s here.
$nexp 1293
Warning : Program unit "%s" is defined as a %s at line %s, but is defined or referenced as a %s here.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must only be declared once.  Any references to this global name, must be
correct and match the definition of this name.

The compiler has found a program unit definition that does not match its 
reference.

Something similar to one of the following has been found:
     program p
     end program

     function f()

     ...

     call p()          ! A message is issued because P is a program but is
                       !   referenced as a subroutine here.
     end function
.ME
$
$ Warning : 1294
$msg  1294 Function "%s" is defined at line %s. Type and rank for result "%s" differ at this definition or reference.
$nexp 1294
Warning : Function "%s" is defined at line %s. Type and rank for result "%s" differ at this definition or reference.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

The type and rank for the function result should be the same.
.ME
$
$ Warning : 1295
$msg  1295 "%s" is defined or referenced at line %s and here.  The number of arguments do not match.  Expected %d, but found %d.
$nexp 1295
Warning : "%s" is defined or referenced at line %s and here.  The number of arguments do not match.  Expected %d, but found %d.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
   
The number of dummy arguments differs between the actual program unit
definition and the number of actual arguments specified on this reference.

If the definition has optional arguments, an this is a reference, an explicit
interface should be specified for this reference in this program unit.  
.ME
$
$ Warning : 1296
$msg  1296 Subroutine "%s" defined at line %s has an alternate return dummy argument, so this actual argument must be a user label.
$nexp 1296
Warning : Subroutine "%s" defined at line %s has an alternate return dummy argument, so this actual argument must be a user label.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

An explicit interface or the Subroutine definition defines this dummy argument 
as an alternate return argument (*), but the call site does not supply a user 
label as the corresponding actual argument. 
.ME
$
$ Caution : 1297
$msg  1297 Procedure "%s" is defined at line %s with dummy procedure "%s".  This argument is a data object, constant or expression.
$nexp 1297
Caution : Procedure "%s" is defined at line %s with dummy procedure "%s".  This argument is a data object, constant or expression.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

There is a mismatch between a dummy argument and an actual argument.  If the
dummy argument is a data object, the actual argument must be a data object.
If the dummy argument is a procedure, the actual argument must be a procedure.
If these are both definitions, then both dummy arguments must agree.
.ME
$
$ Warning : 1298
$msg  1298 Procedure "%s" is defined at line %s. The type and rank of dummy function "%s" must agree with procedure argument "%s".
$nexp 1298
Warning : Procedure "%s" is defined at line %s. The type and rank of dummy function "%s" must agree with procedure argument "%s".
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

There is a mismatch between a dummy argument and an actual argument.
The type of actual arguments associated with dummy arguments must agree.
If these are both function definitions, then the type and rank of the function
result of the dummy procedures must agree.  If the dummy procedure is being
compared to an actual procedure then the type and rank of the function result
must agree.
.ME
$
$ Warning : 1299
$msg  1299 "%s" is defined/referenced at line %s with %s "%s" as an argument. This argument must be the same type of program unit.
$nexp 1299
Warning : "%s" is defined/referenced at line %s with %s "%s" as an argument. This argument must be the same type of program unit.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

If the dummy argument is a function, then the actual argument must be a 
function.  The same rules apply for a subroutine.  If this is comparing two
references then both actual arguments must be the same.  If this is comparing
two definitions then both dummy arguments must be the same.
.ME
$
$ Caution : 1300
$msg  1300 "%s" is referenced at line %s and defined here. Argument "%s" is a dummy procedure. The actual argument is not.
$nexp 1300
Caution : "%s" is referenced at line %s and defined here. Argument "%s" is a dummy procedure. The actual argument is not.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

There is a mismatch between a dummy argument and an actual argument.  If the
dummy argument is a data object, the actual argument must be a data object.
If the dummy argument is a procedure, the actual argument must be a procedure.
If these are both definitions, then both dummy arguments must agree.
Note:  In this context, data object can also mean a constant value or an
expression, neither of which is a procedure.
.ME
$
$ Caution : 1301
$msg  1301 Procedure "%s" is also referenced at line %s.  The type of argument %d does not agree.
$nexp 1301
Caution : Procedure "%s" is also referenced at line %s.  The type of argument %d does not agree.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

The type of arguments associated with dummy arguments must agree.
.ME
$
$ Ansi : 1302
$msg  1302 An assumed size character array used as an internal file is an extension to the Fortran standard.
$nexp 1302
Ansi : An assumed size character array used as an internal file is an extension to the Fortran standard.
.PP
The Fortran standard only allows whole array references of assumed size
arrays as arguments to procedures where the upper bound is not needed, or
as an argument to LBOUND. This compiler allows an internal file in a WRITE or
READ statement to be an assumed size character array as an extension to the
standard.
.ME
$
$ Error : 1303
$msg  1303 Only assumed shape dummy arguments are allowed on the COPY_ASSUMED_SHAPE directive.
$nexp 1303
Error : Only assumed shape dummy arguments are allowed on the COPY_ASSUMED_SHAPE directive.
.PP
An object that was not an assumed shape dummy argument was specified on the
COPY_ASSUMED_SHAPE directive. Generally, this message results from the
compiler encountering a scalar variable on the directive.
.ME
$
$ Caution : 1304
$msg  1304 The COPY_ASSUMED_SHAPE directive was encountered but there are no assumed shape dummy arguments.
$nexp 1304
Caution : The COPY_ASSUMED_SHAPE directive was encountered but there are no assumed shape dummy arguments.
.PP
The COPY_ASSUMED_SHAPE directive without an argument list, requests that
all assumed shape dummy arguments get copied to temporary arrays to aid
in loop optimization. This message was issued because there weren't any
assumed shape dummy arguments.
.ME
$
$ Caution : 1305
$msg  1305 This character literal has been blank padded to the length of the dummy argument.
$nexp 1305
Caution : This character literal has been blank padded to the length of the dummy argument.
.PP
The compiler determined that a character literal actual argument was shorter
than the associated dummy argument. The literal was blank padded to the
necessary length.
.ME
$
$ Ansi : 1306
$msg  1306 Blank padding of a character literal actual argument is an extension to the Fortran standard.
$nexp 1306
Ansi : Blank padding of a character literal actual argument is an extension to the Fortran standard.
.PP
The compiler determined that a character literal actual argument was shorter
than the associated dummy argument. The literal was blank padded to the
necessary length. This is an extension to the Fortran standard.
.ME
$
$ Error : 1307
$msg  1307 The kind (%d) of this actual argument does not match that of its associated dummy argument (%d).
$nexp 1307
Error : The kind (%d) of this actual argument does not match that of its associated dummy argument (%d).
.PP
A difference was detected between the kind type parameter of the actual
argument and the kind type parameter of the dummy argument supplied in an
explicit interface for the called routine.
.ME
$
$ Error : 1308
$msg  1308 In a real constant with a D, E or Q following the decimal field, the D, E or Q must be followed by an exponent.
$nexp 1308
Error : In a real constant with a D, E or Q following the decimal field, the D, E or Q must be followed by an exponent.
.PP
The compiler detected a missing exponent field in a real constant.  The
syntax for a real constant is

        [sign] real_literal_constant

real_literal_constant is significand [exponent_letter exponent] [_kind_param]

     or

digit_string exponent_letter exponent [_kind_param]

significand is digit_string.[digit_string]

  or

digit_string

exponent_letter is E or exponent is signed_digit_string
.ME
$
$ Error : 1309
$msg  1309 The kind parameter suffix is not valid on a double or quad precision real constant form.
$nexp 1309
Error : The kind parameter suffix is not valid on a double or quad precision real constant form.
.PP
The compiler detected a kind parameter following a D or Q exponent.

The syntax for a real constant is

     [digit_str].digit_str[exponent_letter exponent]
     [_kind_param]

exponent_letter is D, E or Q; exponent is signed_digit_string with the following
constraint:  if both kind_param and exponent_letter are present,
exponent_letter must be E.
.ME
$
$ Log_Summary : 1310
$msg  1310 f90: Compile time:  %s seconds
$nexp 1310
Log_Summary : f90: Compile time:  %s seconds
.PP
This message reports the time, in seconds, that elapsed during the
compilation of the program.
.ME
$
$ Error : 1311
$msg  1311 This argument to an ELEMENTAL call does not conform to the other arguments.
$nexp 1311
Error : This argument to an ELEMENTAL call does not conform to the other arguments.
.PP
The Fortran standard states that: "For
those elemental functions that have more than one argument, all actual
arguments shall be conformable."  For subroutines, it states that: "either all
actual arguments shall be scalar, or all actual arguments associated with
INTENT(OUT) and INTENT(INOUT) dummy arguments shall be arrays of the same
shape and the remaining actual arguments shall be conformable with them."
Two arrays are conformable if they have the same shape; a scalar is
conformable with any array.
.ME
$
$ Error : 1312
$msg  1312 This DO PARALLEL directive is not allowed within a parallel CASE region.
$nexp 1312
Error : This DO PARALLEL directive is not allowed within a parallel CASE region.
.PP
A DO PARALLEL directive can only be used within a parallel region bounded
by the PARALLEL/ENDPARALLEL directives. They cannot be specified within 
a CASE parallel region.
.ME
$
$ Log_Warning : 1313
$msg  1313 Command line option "%s" overrides "%s". 
$nexp 1313
Log_Warning : Command line option "%s" overrides "%s". 
.PP
The two specified command line options conflict with each other and should
not be specified on the same command line.

  -ei and -e0 conflict.  The compiler chooses the last option that is
                         specified.  (The rightmost wins rule.)
.ME
$
$ Error : 1314
$msg  1314 Object "%s" is declared both %s and %s.
$nexp 1314
Error : Object "%s" is declared both %s and %s.
.PP
On a tasking directive statement, a variable is listed in more than one
scoping list. The scoping list are PRIVATE, GETFIRST, and SHARED.
.ME
$
$ Internal : 1315
$msg  1315 An internal inlining data structure has overflowed.   The compilation cannot continue.
$nexp 1315
Internal : An internal inlining data structure has overflowed.   The compilation cannot continue.
.PP
An internal data structure has overflowed.  The data structure may be able to 
be increased in size.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Internal : 1316
$msg  1316 Symbol table field %s is NULL and should not be at this location.
$nexp 1316
Internal : Symbol table field %s is NULL and should not be at this location.
.PP
There is a problem with the internal symbol tables. 
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Warning : 1317
$msg  1317 SAFEVL is not allowed on the IVDEP directive on this platform.  This IVDEP directive will be ignored.
$nexp 1317
Warning : SAFEVL is not allowed on the IVDEP directive on this platform.  This IVDEP directive will be ignored.
.PP
The SAFEVL clause is not allowed on the IVDEP directive on this platform.
This IVDEP directive will be ignored.  Ie:  Treated as a comment.
.ME
$
$ Error : 1318
$msg  1318 "%s" is specified on the CACHE_BYPASS directive.  It must have the dimension attribute.
$nexp 1318
Error : "%s" is specified on the CACHE_BYPASS directive.  It must have the dimension attribute.
.PP
All objects specified on the CACHE_BYPASS directive must be declared as arrays
in the same scoping unit or be arrays that are host or use associated into 
the scope.
.ME
$
$ Error : 1319
$msg  1319 An array name must be specified on the CACHE_BYPASS directive.  A subobject or an expression is not allowed.
$nexp 1319
Error : An array name must be specified on the CACHE_BYPASS directive.  A subobject or an expression is not allowed.
.PP
The CACHE_BYPASS directive requires the name of an array.  The compiler has
detected an expression or a an array name followed by a subscript or 
substring reference.  This is not allowed.
.ME
$
$ Error : 1320
$msg  1320 "%s" is specified on the CACHE_BYPASS directive.  Its type must be integer, logical or real with a kind type of 8.
$nexp 1320
Error : "%s" is specified on the CACHE_BYPASS directive.  Its type must be integer, logical or real with a kind type of 8.
.PP
Currently, the only supported array types for the CACHE_BYPASS directive are
64 bit integer, real and logical.
.ME
$
$ Internal : 1321
$msg  1321 Attr list table entry %d holds attr entry %d, which is being compressed out.
$nexp 1321
Internal : Attr list table entry %d holds attr entry %d, which is being compressed out.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1322
$msg  1322 The compiler has detected errors in procedure "%s".  No inline information file will be created for this procedure.
$nexp 1322
Error : The compiler has detected errors in procedure "%s".  No inline information file will be created for this procedure.
.PP
The compiler detected errors in the procedure; therefore, no inline information
file will be created for this procedure.  Errors can cause the information in
the inline information file to be unreliable.
.ME
$
$ Ansi : 1323
$msg  1323 The kind type of all the arguments to the intrinsic are not identical. 
$nexp 1323
Ansi : The kind type of all the arguments to the intrinsic are not identical. 
.PP
The standard requires that all the arguments to MIN/MAX must have
identical type and kind type.    The compiler will allow differing
kind types and promote the smaller kind type arguments to the largest
kind type argument.
.ME
$
$ Internal : 1324
$msg  1324 Maximum number of loops (%d) specified for a given line has been exceeded.
$nexp 1324
Internal : Maximum number of loops (%d) specified for a given line has been exceeded.
.PP
BLK_LOOP_NUM for the current DO loop is already at its maximum size.  A larger
value would overflow that space alloted for BLK_LOOP_NUM in the Block Stack.

This message should never be generated.  Please notify your product
support organization with this error message number and any supporting
information.  This message does not indicate a problem with your code.
You may be able to change your code, so that the compiler does not try to
issue this message.
.ME
$
$ Inline : 1325
$msg  1325 Routine %s was not inlined because a store into a constant will occur.
$nexp 1325
Inline : Routine %s was not inlined because a store into a constant will occur.
.PP
The user is attempting to inline a call site that has an invalid argument 
mapping.   The actual argument is a constant and the callee does a store
into the dummy argument associated with the constant.

eg.      subroutine sam(i)
         j = 4
         i = j   !this will create a store into a constant when inlined
         end

         program nono
         call sam(3)
         end
.ME
$
$ Inline : 1326
$msg  1326 Routine %s was not inlined because the routine contains an alternate RETURN.
$nexp 1326
Inline : Routine %s was not inlined because the routine contains an alternate RETURN.
.PP
The routine being inlined contains an alternate RETURN.  Therefore, this
routine cannot be expanded inline.

eg.

           subroutine boo(*)
           print *, 'in boo'
           return 1
           end

           program b
           call boo(*3)  !this call will not get inlined
           print *, 'should never print this'
3          continue
           end
.ME
$
$ Inline : 1327
$msg  1327 Routine %s was not inlined because the routine calls the PRESENT intrinsic.
$nexp 1327
Inline : Routine %s was not inlined because the routine calls the PRESENT intrinsic.
.PP
Routines containing a call to the PRESENT intrinsic cannot be inlined.

eg.


program tt
call sam(i)  !This call will not be inlined.
end

subroutine sam(j)
print *, present(j)
end
.ME
$
$ Inline : 1328
$msg  1328 Routine %s was not inlined because a corresponding actual and dummy argument do not have identical type and kind-type.
$nexp 1328
Inline : Routine %s was not inlined because a corresponding actual and dummy argument do not have identical type and kind-type.
.PP
Each corresponding actual and dummy argument must have identical type and
kind-type.   If not, the call site will not be expanded inline.

eg.

subroutine sam(i)
integer (8) i
print *, i
end

program nono
integer (4) j
call sam(j)    !will not get expanded inlined
end
.ME
$
$ Inline : 1329
$msg  1329 Routine %s was not inlined because the routine calls the NUMARG intrinsic.
$nexp 1329
Inline : Routine %s was not inlined because the routine calls the NUMARG intrinsic.
.PP
A routine containing a call to the NUMARG intrinsic cannot be expanded inline.

eg.

program boo
call sam(3,i)  !this call site will not be expanded inline
end

subroutine sam(j,k)
print *, NUMARG()
end
.ME
$
$ Inline : 1330
$msg  1330 Routine %s was not inlined because a scalar actual argument is being mapped to an array dummy argument.
$nexp 1330
Inline : Routine %s was not inlined because a scalar actual argument is being mapped to an array dummy argument.
.PP
If the inliner encounters a scalar actual argument being passed to an array
dummy argument, the call site will not be inlined.

eg.

program boo
call sam(a)   !this call site will not be expanded inline
end

subroutine sam(b)
dimension b(10)
print *, b(1)
end
.ME
$
$ Inline : 1331
$msg  1331 Routine %s was not inlined because the routine contains ASSIGN statements.
$nexp 1331
Inline : Routine %s was not inlined because the routine contains ASSIGN statements.
.PP
If a routine contains an ASSIGN statement, it will not be expanded inline.

eg.

program boo
call sam()   !this call site will not be inlined
end

subroutine sam()
assign 10 to L
j = k
if (j .eq. 1) goto L
r = q
10 continue
r = s
end
.ME
$
$ Inline : 1332
$msg  1332 Routine %s was not inlined because the routine is RECURSIVE.
$nexp 1332
Inline : Routine %s was not inlined because the routine is RECURSIVE.
.PP
If a routine is declared RECURSIVE, the inliner will not attempt to inline it.

eg.

subroutine sam()
call joe()        !this call site will not be inlined
end

RECURSIVE subroutine joe()
if <some condition> call joe()
end
.ME
$
$ Inline : 1333
$msg  1333 Routine %s was not inlined because the routine being called is a dummy procedure.
$nexp 1333
Inline : Routine %s was not inlined because the routine being called is a dummy procedure.
.PP
If the inliner encouters a call to a dummy procedure, there will no attempt to
inline that dummy procedure call.

eg.

subroutine boo(bubble)
external bubble
call bubble()   !this call site will not be inlined
end

subroutine bil()
external tank
call boo(tank)
end
.ME
$
$ Inline : 1334
$msg  1334 Routine %s was not inlined because it has OPTIONAL dummy arguments.
$nexp 1334
Inline : Routine %s was not inlined because it has OPTIONAL dummy arguments.
.PP
If a routine contains OPTIONAL dummy arguments, the inliner will never expand 
that routine inline.

eg.

subroutine slug(a,b)
OPTIONAL :: b
print *, b
end

program boo 
call slug(x,y)   !slug can never be expanded inline
end

.ME
$
$ Inline : 1335
$msg  1335 Routine %s was not inlined because an INLINE directive is not in effect.
$nexp 1335
Inline : Routine %s was not inlined because an INLINE directive is not in effect.
.PP
This message is issued only when -Oinline1 is on the command line.   At level one
of inlining, the only way to get inlining to occur is with directives.
The two directives that will cause inlining at this level are:

!dir$ INLINE          and
!dir$ INLINEALWAYS
.ME
$
$ Inline : 1336
$msg  1336 Routine %s was not inlined because the call was not within a loop.
$nexp 1336
Inline : Routine %s was not inlined because the call was not within a loop.
.PP
This message is only issued with -Oinline2 on the command line.   A call site
will only be inlined if it exists within a DO loop.
.ME
$
$ Inline : 1337
$msg  1337 Routine %s was not inlined because it contains a Fortran pointer in static storage.
$nexp 1337
Inline : Routine %s was not inlined because it contains a Fortran pointer in static storage.
.PP
If a routine contains a Fortran pointer anywhere in static storage, the inliner
will not inline the routine.   

eg.

subroutine boo()
common // a
pointer a
print *, 'in boo'
end

subroutine bo()
save   a
pointer a
print *, 'in bo'
end

program nono
call boo()     !this call site will not be inlined
call bo()      !this call site will not be inlined
end
.ME
$
$ Inline : 1338
$msg  1338 Routine %s was not inlined because a NOINLINE directive is in effect.
$nexp 1338
Inline : Routine %s was not inlined because a NOINLINE directive is in effect.
.PP
The user has placed a !DIR$ NOINLINE directive in their source which is
preventing this call site from being inlined.

eg.


program this
dimension a(10)
!dir$ NOINLINE
call sam()       !this call site will not be inlined
end

subroutine sam()
print *, 'in sam'
end
.ME
$
$ Inline : 1339
$msg  1339 Routine %s is not inlined because an INLINENEVER directive has been specified.
$nexp 1339
Inline : Routine %s is not inlined because an INLINENEVER directive has been specified.
.PP
This routine will not be expanded inline because the name appears in an
INLINENEVER directive.   If the INLINENEVER directive apprears in the
definition of the routine with the "name" of that routine specified on the 
directive, no call to that routine will ever get expanded
inline.   If the INLINENEVER directive does not appear in the definition
of a routine, then calls to the "names" specified on the INLINENEVER directive
will not be inlined.

eg.


subroutine this()
!dir$ INLINENEVER this
print *, 'in this'
end

subroutine that()
print *, 'in that'
call this()        ! call site will not be inlined
end

program boo
!dir$ INLINENEVER that
call this()        ! call site will not be inlined
call that()        ! call site will not be inlined
end
.ME
$
$ Inline : 1340
$msg  1340 Routine %s was not inlined because a dummy argument of the routine being inlined is a dummy procedure.
$nexp 1340
Inline : Routine %s was not inlined because a dummy argument of the routine being inlined is a dummy procedure.
.PP
A dummy argument of the routine being inlined is a dummy procedure.   The 
inliner will not inline this routine.


eg.

subroutine boo(b)
external b
print *, b(3.0)
end


program big
intrinsic tan
call boo(tan)  !this call site will not be inlined
end
.ME
$
$ Inline : 1341
$msg  1341 Routine %s was not inlined because the routine has a dummy argument that is referenced in a child routine.
$nexp 1341
Inline : Routine %s was not inlined because the routine has a dummy argument that is referenced in a child routine.
.PP
A routine which has a dummy argument that is referenced in a child routine
cannot be inlined.



eg.

subroutine boo(i)
     call sam()     !this call site will not be expanded inline
     contains 

        subroutine sam()
            print *, i
        end subroutine
end subroutine
        
.ME
$
$ Inline : 1342
$msg  1342 Routine %s was not inlined because there are an unequal number of actual and dummy arguments.
$nexp 1342
Inline : Routine %s was not inlined because there are an unequal number of actual and dummy arguments.
.PP
The number of actual and dummy arguments must be identical to inline a call site.


eg.

subroutine boo(a)
print *, a       
end

program this
call boo(x,y)   !this call site will not be inlined
end

.ME
$
$ Inline : 1343
$msg  1343 Routine %s was not inlined because a maximum of 256 actual arguments can be in the call list.
$nexp 1343
Inline : Routine %s was not inlined because a maximum of 256 actual arguments can be in the call list.
.PP
The user has coded more than 256 actual arguments at this call site.   The
call site cannot be inlined.
.ME
$
$ Inline : 1344
$msg  1344 Routine %s was not inlined because the compiler was unable to locate the routine to expand it inline.
$nexp 1344
Inline : Routine %s was not inlined because the compiler was unable to locate the routine to expand it inline.
.PP
The compiler was unable to locate a template for the routine being called in
order to expand it inline.   The reasons this may have occured:

1) The routine had compilation errors in it when the template was being created.
2) The user did not direct the compile as to where to find this routine for
   inlining.
3) The user never actually created a template for the routine.
.ME
$
$ Inline : 1345
$msg  1345 Routine %s was not inlined because the routine references a dummy argument not from the ENTRY taken.
$nexp 1345
Inline : Routine %s was not inlined because the routine references a dummy argument not from the ENTRY taken.
.PP
The user has taken and entry point into a routine and somewhere in that routine
referenced a dummy argument from some other entry point.   This is not legal
and the compiler will not inline such a call.

eg.

subroutine boo()
common // a
print *, a
if (a .gt. 0.0) goto 10
entry alt(b)
10 continue
print *, b
end

program nono
common // a
call boo()        ! this call site will not be inlined
end

.ME
$
$ Inline : 1346
$msg  1346 Routine %s was not inlined because there is a USE of a module that has not been defined yet.
$nexp 1346
Inline : Routine %s was not inlined because there is a USE of a module that has not been defined yet.
.PP
If a routine is inlined which contains a USE statement.   The module that
is being USEd must have already been compiled and available.

eg.

program boo
call s()          ! this call site will not get inlined because the declaration
                  ! of module z must occur before the call, since the 
                  ! statement use z is inlined into boo at the call site.
end

module z
integer i
end 

subroutine s()
use z
print *, i
end
.ME
$
$ Inline : 1347
$msg  1347 Routine %s was not inlined because it is too large to expand inline.
$nexp 1347
Inline : Routine %s was not inlined because it is too large to expand inline.
.PP
This particular routine contains too much text to be expanded inline.
.ME
$
$ Caution : 1348
$msg  1348 QUAD PRECISION is not supported on this platform. DOUBLE PRECISION will be used.
$nexp 1348
Caution : QUAD PRECISION is not supported on this platform. DOUBLE PRECISION will be used.
.PP
This machine does not have support for a REAL precision that is greater than
DOUBLE PRECISION. 
.ME
$
$ Internal : 1349
$msg  1349 Constant table entry %d had a CN_POOL_IDX of zero.
$nexp 1349
Internal : Constant table entry %d had a CN_POOL_IDX of zero.
.PP
This message means there is an invalid entry in the constant table.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Warning : 1350
$msg  1350 The %s directive is obsolete.  Support will be removed in the next major release.
$nexp 1350
Warning : The %s directive is obsolete.  Support will be removed in the next major release.
.PP
Support for the listed directive will be removed in the following release.
Please remove references to this directive from your code.
.ME
$
$ Warning : 1351
$msg  1351 Storage block "%s" will not be padded (-a pad), because one or more objects in the storage block are equivalenced.
$nexp 1351
Warning : Storage block "%s" will not be padded (-a pad), because one or more objects in the storage block are equivalenced.
.PP
The -a pad feature causes padding between objects of common and static storage
blocks.  If any objects are equivalenced, padding will not happen, as it may
break the equivalency.
.ME
$
$ Warning : 1352
$msg  1352 The static storage block will not be padded (-a pad), because one or more objects in the storage block are equivalenced.
$nexp 1352
Warning : The static storage block will not be padded (-a pad), because one or more objects in the storage block are equivalenced.
.PP
The -a pad feature causes padding between objects of common and static storage
blocks.  If any objects are equivalenced, padding will not happen, as it may
break the equivalency.
.ME
$
$ Log_Warning : 1353
$msg  1353 Command line option conflict detected between "%s" and "%s".  "%s" is selected.
$nexp 1353
Log_Warning : Command line option conflict detected between "%s" and "%s".  "%s" is selected.
.PP
There is a conflict between the two options specified on the command line,
so the compiler has chosed one of the options.  The message details which
option is chosen.
.ME
$
$ Warning : 1354
$msg  1354 Unimplemented compiler directive: %s.
$nexp 1354
Warning : Unimplemented compiler directive: %s.
.PP
Temporary message.  This should never be received.
.ME
$
$ Inline : 1355
$msg  1355 Routine %s was not inlined because it has dummy argument(s) which are Cray pointers.
$nexp 1355
Inline : Routine %s was not inlined because it has dummy argument(s) which are Cray pointers.
.PP
This routine was not inlined because a dummy argument is a Cray pointer.
.ME
$
$ Warning : 1356
$msg  1356 Expected a valid compiler directive.
$nexp 1356
Warning : Expected a valid compiler directive.
.PP
During parsing of a compiler directive line, the compiler found an
unknown character.  The line was flushed.
.ME
$
$ Inline : 1357
$msg  1357 Routine %s was not inlined because this function's result is referenced in a child routine.
$nexp 1357
Inline : Routine %s was not inlined because this function's result is referenced in a child routine.
.PP
If function "FUNC" result is referenced in a child routine, "FUNC" can 
never be inlined.

eg.

         program start
         j = if(10)                      ! this call will not get inlined
         print *, "j should be 10  ", j
         end program

         function if(i)
         integer if
         if = i
         call z()
         contains
           subroutine z()
           print *, "if should be 10  ", if     ! hosted function result
           end subroutine
         end function

.ME
$
$ Inline : 1358
$msg  1358 Routine %s was not inlined because the routine contains a LOC of a variable in COMMON.
$nexp 1358
Inline : Routine %s was not inlined because the routine contains a LOC of a variable in COMMON.
.PP
This routine cannot be expanded inline because it contains a LOC intrinsic which
has a COMMON block variable as its argument.
LANL requires that all Cray pointers be forced to memory at each and every
call site regardless of whether the Cray pointer is in the call list or not.
This makes inlining of routines containing Cray pointers dangerous in some
cases.
.ME
$
$ Inline : 1359
$msg  1359 Routine %s was not inlined because it contains Cray pointers which are in COMMON.
$nexp 1359
Inline : Routine %s was not inlined because it contains Cray pointers which are in COMMON.
.PP
Routines containing Cray pointers which exist in a COMMON block will not be
inlined.
.ME
$
$ Error : 1360
$msg  1360 More than one %s clause has been specified for this %s directive.
$nexp 1360
Error : More than one %s clause has been specified for this %s directive.
.PP
Many clauses to C$ and C$PAR compiler directives may only be specified
once. 

C$DOACROSS

	IF, CHUNK (or BLOCKED), MP_SCHEDTYPE, AFFINITY, NEST, and ONTO
	may only be specified once.
.ME
$
$ Error : 1361
$msg  1361 The ONTO clause is not allowed with the %s directive unless a NEST clause is seen first.
$nexp 1361
Error : The ONTO clause is not allowed with the %s directive unless a NEST clause is seen first.
.PP
For the DOACROSS, PDO, and PARALLEL DO directives, the NEST clause 
must be specified before the ONTO clause.
.ME
$
$ Error : 1362
$msg  1362 Object "%s" is specified in more than one scoping list.
$nexp 1362
Error : Object "%s" is specified in more than one scoping list.
.PP
An object in a parallel region must not be scoped in more than one way.
Below, object 'A' is in both the SHARE list and the LASTLOCAL list. This
is not allowed.

C$DOACROSS SHARE(A,B), LASTLOCAL(A)
      do 100 B = 1,10
      A = B
100   continue
.ME
$
$ Error : 1363
$msg  1363 Objects in the REDUCTION clause must be scalar references.
$nexp 1363
Error : Objects in the REDUCTION clause must be scalar references.
.PP
Only scalar variables or array elements are allowed in the REDUCTION 
list of the DOACROSS directive.
.ME
$
$ Error : 1364
$msg  1364 The CHUNK expression must be a scalar INTEGER expression.
$nexp 1364
Error : The CHUNK expression must be a scalar INTEGER expression.
.PP
The CHUNK (or BLOCKED) expression to the DOACROSS directive must
be a scalar integer expression. The CHUNK expression to the SCHEDULE
clause of the !$OMP DO and !$OMP PARALLEL DO directives must also
be a scalar integer expression.
.ME
$
$ Error : 1365
$msg  1365 Variable "%s" must be declared in a COMMON block in order to use PE dimensions.
$nexp 1365
Error : Variable "%s" must be declared in a COMMON block in order to use PE dimensions.
.PP
The F-- prototype only supports pe dimension syntax on
COMMON block objects.
.ME
$
$ Error : 1366
$msg  1366 References with PE dimensions are not allowed as actual arguments.
$nexp 1366
Error : References with PE dimensions are not allowed as actual arguments.
.PP
The F-- prototype does not support PE dimension references as arguments
to user or intrinsic calls.
.ME
$
$ Internal : 1367
$msg  1367 Bounds entry %d has a variant problem with field %s.
$nexp 1367
Internal : Bounds entry %d has a variant problem with field %s.
.PP
The compiler detected a variant problem.  A field is being accessed in the
bounds table, but the wrong variant is active.  The bounds table variants
are regular array entries and distribution entries.

This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 1368
$msg  1368 Arguments to the ONTO clause must be INTEGER constants greater than zero.
$nexp 1368
Error : Arguments to the ONTO clause must be INTEGER constants greater than zero.
.PP
The ONTO clause of the DOACROSS, PDO, PARALLEL DO directives, must 
contain only integer constants or the character '*'. The integer constants
must be greater than zero.
.ME
$
$ Error : 1369
$msg  1369 The number of ONTO constants must equal the number of NEST variables.
$nexp 1369
Error : The number of ONTO constants must equal the number of NEST variables.
.PP
For the DOACROSS, PDO, and PARALLEL DO directives, the number of integer
constants, or '*' specifiers must be equal to the number of loop control
variable specified in the associated NEST clause.
.ME
$
$ Error : 1370
$msg  1370 The %s clause is not allowed with the %s mp directive.
$nexp 1370
Error : The %s clause is not allowed with the %s mp directive.
.PP
A clause was encountered that was not supported on the mp directive
specified.
.ME
$
$ Error : 1371
$msg  1371 The argument to the THREAD clause must be a scalar INTEGER expression.
$nexp 1371
Error : The argument to the THREAD clause must be a scalar INTEGER expression.
.PP
The THREAD clause, used with the DOACROSS, PDO, and PARALLEL DO directives,
can have only one scalar INTEGER expression argument.
.ME
$
$ Error : 1372
$msg  1372 Arguments to the DATA clause must be array elements.
$nexp 1372
Error : Arguments to the DATA clause must be array elements.
.PP
To be supplied.
.ME
$
$ Error : 1373
$msg  1373 Arguments to the THREAD clause must be constants.
$nexp 1373
Error : Arguments to the THREAD clause must be constants.
.PP
to be supplied.
.ME
$
$ Error : 1374
$msg  1374 A subobject reference is not allowed in this context.
$nexp 1374
Error : A subobject reference is not allowed in this context.
.PP
There are a number of contexts where a subobject reference is not allowed.
That is, the variable being referenced must be referenced as an unqualified
name, such as X or ARRAY.  In particular, the name must not have any attached
subscript list nor may it contain structure component (%) symbols.
 
Some examples of such contexts are DO variables and in compiler directives.
For example, when a tasking compiler directive defines scope or context for
a parallel region, it must be for whole variables, not variable subobjects.
The following code fragment is not allowed.

         TYPE X
            INTEGER I
         END TYPE 
   
         TYPE(X) :: K
   
   CMIC$ DO ALL SHARED(K%I)

.ME
$
$ Warning : 1375
$msg  1375 The variable name list must contain at least two names.
$nexp 1375
Warning : The variable name list must contain at least two names.
.PP
The indicated list of names must contain at least two names.
.ME
$
$ Error : 1376
$msg  1376 Objects in the LASTTHREAD clause must be simple scalar variables.
$nexp 1376
Error : Objects in the LASTTHREAD clause must be simple scalar variables.
.PP
Only scalar variable names can be used in the LASTTHREAD clause of the
DOACROSS, PARALLEL DO, and PDO directives.
.ME
$
$ Error : 1377
$msg  1377 The ONTO clause can only be specifed when the count of objects in the NEST clause is greater than 1.
$nexp 1377
Error : The ONTO clause can only be specifed when the count of objects in the NEST clause is greater than 1.
.PP
The ONTO clause is intended for use with nested loops. If the NEST clause
has only one object, an ONTO clause is not allowed.
.ME
$
$ Error : 1378
$msg  1378 Invalid argument to the %s directive.
$nexp 1378
Error : Invalid argument to the %s directive.
.PP
Only certain integer values are allowed for the PREFETCH and PREFETCH_MANUAL 
directives.

C*$* PREFETCH (n1, [, n2] )

	n1 and n2 must be
		0 - prefetching off
		1 - conservative prefetching
		2 - aggresive prefetching

C*$* PREFETCH_MANUAL (n)

	n must be
		0 - ignore manual directives
		1 - respect manual directives
.ME
$
$ Error : 1379
$msg  1379 The DO-variable was not specified in the %s list preceding this loop nest. 
$nexp 1379
Error : The DO-variable was not specified in the %s list preceding this loop nest. 
.PP
The INTERCHANGE directive has the form:

    \*CC*$* INTERCHANGE(\fR \fIDO-variable-list\fR \*C)\fR

and the BLOCKABLE directive has the form:

    \*CC*$* BLOCKABLE(\fR \fIDO-variable-list\fR \*C)\fR

where each name in the \fIDO-variable-list\fR must be the name of a
DO-variable in the loop nest following the directive.  The 
\fIDO-variable-list\fR must contain at least 2 DO-variable names.  The
loop nest following a directive \*CINTERCHANGE\fR directive must be
perfectly nested.

This message is issued when the indicated DO-variable name is not contained
in the \fIDO-variable-list\fR of the \*CINTERCHANGE\fR or \*CBLOCKABLE\fR
directive that precedes the loop nest containing the current iterative DO
loop.
.ME
$
$ Error : 1380
$msg  1380 %s loops are not perfectly nested. 
$nexp 1380
Error : %s loops are not perfectly nested. 
.PP
The current nest of iterative DO loops is expected to be perfectly nested
because the nest is the subject of an \*CINTERCHANGE\fR, \*CDOACROSS\fR,
\*CPDO\fR, or \*CPARALLEL DO\fR, directive.  To be perfectly nested, a set of 
DO loops must have sequential DO statements at the head of the loop nest 
(that is, no other statements may appear between any of the DO statements) 
and the loop ending statements must also be sequential.  Multiple loops that 
end on a single statement are still considered to be perfectly nested so 
long as the DO statements are sequential.  

This message is issued either when a statement appears between two of the
DO statements at the head of the loop nest or between two of the loop 
ending statements at the bottom of the loop nest.
.ME
$
$ Error : 1381
$msg  1381 A statement must not appear between the %s directive and the DO loop that follows it.
$nexp 1381
Error : A statement must not appear between the %s directive and the DO loop that follows it.
.PP
The named directive must be immediately followed by a DO loop.  No statement
can come between the directive and the DO loop that follows it.  This message
is issued because a statement other than a DO statement followed the named
directive.
.ME
$
$ Error : 1382
$msg  1382 The argument to the PREFETCH_REF_DISABLE directive must be an array name.
$nexp 1382
Error : The argument to the PREFETCH_REF_DISABLE directive must be an array name.
.PP
The PREFETCH_REF_DISABLE directive is used to disable prefetching of
all references to the array specified on the directive. An name was
encountered that was not a valid array name.
.ME
$
$ Error : 1383
$msg  1383 The SIZE argument to the %s directive must be a constant.
$nexp 1383
Error : The SIZE argument to the %s directive must be a constant.
.PP
The SIZE argument to the PREFETCH_REF_DISABLE and PREFETCH_REF directives is 
used for volume analysis by the compiler. It must be a constant.
.ME
$
$ Error : 1384
$msg  1384 Invalid LEVEL value for this PREFETCH_REF directive.
$nexp 1384
Error : Invalid LEVEL value for this PREFETCH_REF directive.
.PP
For the PREFETCH_REF directive, the LEVEL clause tells the compiler
the level in memory hierarchy to prefetch.
	level = 1	prefetch from L2 to L1 cache
	level = 2	prefetch from memory to L1 cache

No other values are allowed.
.ME
$
$ Error : 1385
$msg  1385 The autotasking directive %s must be specified within a do loop.
$nexp 1385
Error : The autotasking directive %s must be specified within a do loop.
.PP
The autotasking directive pair WAIT/SEND must be specified within the
scope of a do loop.  They must also be within a DOALL or DOPARALLEL region.
.ME
$
$ Error : 1386
$msg  1386 The second argument to the %s directive must be L1cacheline, L2cacheline, page, or a power of 2 constant.
$nexp 1386
Error : The second argument to the %s directive must be L1cacheline, L2cacheline, page, or a power of 2 constant.
.PP
The second argument to the FILL_SYMBOL or ALIGN_SYMBOL directive must
be a constant with a power of 2 value (1, 2, 4, 8, etc. ...) or one
of the keywords, L1cacheline, L2cacheline, or page.
.ME
$
$ Error : 1387
$msg  1387 A(n) %s directive has already been specified for the current loop nest.
$nexp 1387
Error : A(n) %s directive has already been specified for the current loop nest.
.PP
This message is issued when more than one \*CINTERCHANGE\fR directive or
\*CBLOCKABLE\fR directive applies to a single loop nest.  This message is
typically issued when more than one such directive precedes a loop, such as:

       \*CC*$* INTERCHANGE(i, j, k)\fR
       \*CC*$* INTERCHANGE(j, k, m)\fR
 
       \*CDO j = 1, 5\fR
       \*C  ...\fR

or when one of these directives precedes a loop nest and another directive
of the same kind appears between two DO statements that are within range of
the first directive, such as: 

       \*CC*$* INTERCHANGE(i, j, k)\fR
 
       \*CDO j = 1, 5\fR
         \*CDO i = 1, 5\fR

       \*CC*$* INTERCHANGE(m, k)\fR

           \*CDO k = 1, 5\fR
             \*CDO m = 1, 5\fR
               \*C  ...\fR
             \*CEND DO\fR
           \*CEND DO\fR
         \*CEND DO\fR
       \*CEND DO\fR


NOTE:  There are also !DIR$ forms of these directives.  The same rules apply.
.ME
$
$ Inline : 1388
$msg  1388 Routine %s was not inlined because it is a function with alternate entries.
$nexp 1388
Inline : Routine %s was not inlined because it is a function with alternate entries.
.PP
The user is attempting to inline a function with alternate entries.  The
inliner cannot determine if the code has actually only defined the 
result name of the entry point taken.

eg.

       FUNCTION IBA()
10     CONTINUE
       IBA = 3
       RETURN
       ENTRY IDA()   ! This call will not inline.
       IDA = 1
       GOTO 10
       END
.ME
$
$ Error : 1389
$msg  1389 The DO loop nesting depth does not match the number of DO-variables in the BLOCKABLE directive DO-variable list.
$nexp 1389
Error : The DO loop nesting depth does not match the number of DO-variables in the BLOCKABLE directive DO-variable list.
.PP
This message is issued when the number of DO-variables specified in the 
DO-variable list of the BLOCKABLE directive is greater than the nesting 
depth of the nest of DO loops that follows the BLOCKABLE directive.  For
example, this message is issued for the first END DO of the following 
program fragment:

     \*CC*$* BLOCKABLE(i, j, k)\fR

     \*CDO j = 1, 3\fR
       \*CDO i = 1, 3\fR
         \*C...\fR
       \*CEND DO\fR
     \*CEND DO\fR
.ME
$
$ Warning : 1390
$msg  1390 Cray character pointee "%s" will be treated as an assumed-length character variable.
$nexp 1390
Warning : Cray character pointee "%s" will be treated as an assumed-length character variable.
.PP
A Cray character pointee was encountered that was declared with explicit
character length. The character length of a pointee is only determined
by the assignment to the associated Cray character pointer. The
pointee will be treated as an assumed-length character variable. The 
explicit length specification will be ignored.

The Cray pointer data type is an extension to the Fortran standard.
.ME
$
$ Log_Warning : 1391
$msg  1391 Source file "%s" contains no Fortran statements.
$nexp 1391
Log_Warning : Source file "%s" contains no Fortran statements.
.PP
To be a valid Fortran program, the source file must contain at least an END
statement.  The source file is either zero-sized (completely empty) or 
contains only comments and/or blank lines.  Such an actually or effectively
empty source does not constitute a Fortran program.
.ME
$
$ Ansi : 1392
$msg  1392 Intrinsics which return a data type other than integer are not allowed in specification expressions.
$nexp 1392
Ansi : Intrinsics which return a data type other than integer are not allowed in specification expressions.
.PP
The Fortran standard does not allow intrinsics which return a data type other 
than integer in specification expressions.
.ME
$
$ Warning : 1393
$msg  1393 Initializing multiple array elements with a single Hollerith or character constant will be removed in the next release.
$nexp 1393
Warning : Initializing multiple array elements with a single Hollerith or character constant will be removed in the next release.
.PP
The extension that allows multiple word-length array elements to be initialized
in a DATA statement by breaking up a single Hollerith or character constant is
an outmoded, obscure, and error prone extension.  Consequently, starting with
the next release of the compiler, this extension will no longer be provided.
A Hollerith or character constant will correspond to a single array element 
in the target list of the DATA statement.
.ME
$
$ Error : 1394
$msg  1394 Only COMMON block names and COMMON block variables are allowed as arguments to the COPYIN directive.
$nexp 1394
Error : Only COMMON block names and COMMON block variables are allowed as arguments to the COPYIN directive.
.PP
Each item in a C$COPYIN directive must be a member of a local COMMON block. 
It can be a variable, an array, an individual element of an array, or the 
entire COMMON block. 

Note: The C$COPYIN directive cannot be executed from inside a parallel region. 

For example,

C$COPYIN x,y, /foo/, a(i)

propagates the values for x and y, all the values in the COMMON block foo, 
and the ith element of array a. All these items must be members of 
local COMMON blocks. Note that this directive is translated into executable 
code, so in this example i is evaluated at the time this statement 
is executed. 
.ME
$
$ Error : 1395
$msg  1395 The C$COPYIN directive cannot be used within a parallel region.
$nexp 1395
Error : The C$COPYIN directive cannot be used within a parallel region.
.PP
Each item in a C$COPYIN directive must be a member of a local COMMON block.
It can be a variable, an array, an individual element of an array, or the
entire COMMON block.

The C$COPYIN directive cannot be executed from inside a parallel region.

For example,

C$COPYIN x,y, /foo/, a(i)

propagates the values for x and y, all the values in the COMMON block foo,
and the ith element of array a. All these items must be members of local
COMMON blocks. Note that this directive is translated into executable code,
so in this example i is evaluated at the time this statement is executed.

.ME
$
$ Error : 1396
$msg  1396 Only array variable names can be specified on the %s directive.
$nexp 1396
Error : Only array variable names can be specified on the %s directive.
.PP
The C$DYNAMIC, or C$REDISTRIBUTE directive must have one or more array 
names as arguments.
.ME
$
$ Error : 1397
$msg  1397 This must be a scalar INTEGER expression.
$nexp 1397
Error : This must be a scalar INTEGER expression.
.PP
This argument to a directive must be a scalar integer expression.
.ME
$
$ Error : 1398
$msg  1398 Too %s ONTO values.
$nexp 1398
Error : Too %s ONTO values.
.PP
The ONTO clause of the DISTRIBUTE, DISTRIBUTE_RESHAPE, and 
REDISTRIBUTE directives, if it is specified, must have exactly the same 
number of values as there are BLOCK or CYCLIC distribution 
specifications. You do not specify an ONTO value for the '*' 
distribution specification.
.ME
$
$ Warning : 1399
$msg  1399 This intrinsic will not be supported in the 3.2 release and beyond.
$nexp 1399
Warning : This intrinsic will not be supported in the 3.2 release and beyond.
.PP
This intrinsic is not part of the standard and is being phased out.
Please change your code.
.ME
$
$ Error : 1400
$msg  1400 An allocatable array is not allowed in this context.
$nexp 1400
Error : An allocatable array is not allowed in this context.
.PP
An allocatable array has been specified to an inquiry intrinsic within a
specification expression.  This is not allowed.
.ME
$
$ Log_Summary : 1401
$msg  1401 openf95: %d source lines
$nexp 1401
Log_Summary : openf95: %d source lines
.PP
This message reports the number of lines of source code read from the input
file and from any \*CINCLUDE\fR files specified on \*CINCLUDE\fR lines.
.ME
$
$ Log_Summary : 1402
$msg  1402 openf95: Open64 Fortran Version %s (%s) %s
$nexp 1402
Log_Summary : openf95: Open64 Fortran Version %s (%s) %s
.PP
This identifies which version and release of the compiler is being used.
.ME
$
$ Log_Summary : 1403
$msg  1403 openf95: %d Error(s), %d Warning(s), %d Other message(s), %d ANSI(s)
$nexp 1403
Log_Summary : openf95: %d Error(s), %d Warning(s), %d Other message(s), %d ANSI(s)
.PP
This message gives a summary of messages issued during compilation.
.ME
$
$ Warning : 1404
$msg  1404 The STACK directive must not be specified inside an interface body or an interface block.
$nexp 1404
Warning : The STACK directive must not be specified inside an interface body or an interface block.
.PP
The STACK directive must not be specified inside an interface body or an
interface block.  The directive would have no meaning in this location.
.ME
$
$ Warning : 1405
$msg  1405 The STACK directive must not be specified in the specification part of a MODULE.
$nexp 1405
Warning : The STACK directive must not be specified in the specification part of a MODULE.
.PP
The STACK directive must not be specified in the specification part of a
MODULE.  Default storage in the specification part of a MODULE is always
static storage and must not be changed with the STACK directive.
.ME
$
$ Internal : 1406
$msg  1406 Overflow of file_id_list in cif_flush_include_recs.
$nexp 1406
Internal : Overflow of file_id_list in cif_flush_include_recs.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Warning : 1407
$msg  1407 "%s" has the %s attribute, support for declaration as a %s is deferred (identifier first appeared at line %d)
$nexp 1407
Warning : "%s" has the %s attribute, support for declaration as a %s is deferred (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object. Because the
object has the given attribute, it must not be declared to be the new item.
Although not allowed at this time, this will be allowed in a future release.
.ME
$
$ Error : 1408
$msg  1408 "%s" is a %s, support for a declaration with the %s attribute is deferred (identifier first appeared at line %d)
$nexp 1408
Error : "%s" is a %s, support for a declaration with the %s attribute is deferred (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.  This
object must not be given the specified attribute. Although not allowed
at this time, it will be allowed in a future release.
.ME
$
$ Inline : 1409
$msg  1409 Routine %s was not inlined because the routine contains a !DIR$ INTEGER= directive.
$nexp 1409
Inline : Routine %s was not inlined because the routine contains a !DIR$ INTEGER= directive.
.PP
This directive could potentially change the types of dummy arguments
which could produce incorrect results when the routine is inlined.
.ME
$
$ Internal : 1410
$msg  1410 The length of the keyword at index %d in the %s table is %d, which is greater than the maximum of 31.
$nexp 1410
Internal : The length of the keyword at index %d in the %s table is %d, which is greater than the maximum of 31.
.PP
All the items in the keyword table must be less than 31 characters, because
of token size limits.   Check the table in use at the time the message was
issued.

This message should never be generated and signifies a bad compiler or a bad
installation.  Please notify your product support organization with this
error message number and any supporting information.  This message does not
indicate a problem with your code.
.ME
$
$ Error : 1411
$msg  1411 The %s directive cannot be specified within a %s.
$nexp 1411
Error : The %s directive cannot be specified within a %s.
.PP
An improper use of a compiler directive was detected. Many directives
have regions of code that they cannot be specified in. An example would
be the use of a C$PAR PDO directive specified within a critical section
bounded by C$PAR CRITICAL SECTION / C$PAR END CRITICAL SECTION.
.ME
$
$ Error : 1412
$msg  1412 The %s directive must be specified within a %s.
$nexp 1412
Error : The %s directive must be specified within a %s.
.PP
An improper use of a compiler directive was detected. Many directives
can only be specifed within certain regions of code. An example would
be that a C$PAR PDO directive can only be specified within a parallel
region bounded by C$PAR PARALLEL / C$PAR END PARALLEL.
.ME
$
$ Warning : 1413
$msg  1413 This numeric constant is out of range.
$nexp 1413
Warning : This numeric constant is out of range.
.PP
A numeric constant was found to be out of range.  Either an integer constant
is too large or a real constant has an exponent whose magnitude is too large.
A too-large integer constant is promoted to a larger type if possible;
otherwise, the constant is clipped at the maximum or minimum representable
value. Note that in the Fortran standard, "-" is not part of the constant
itself, so (for example) "-32768_2" is the operator "-", followed by the
positive integer "32768" which is too large for the type "integer(kind=2)".
.ME
$
$ Ansi : 1414
$msg  1414 The symbolic constant "N$PES" is an extension to the Fortran standard.
$nexp 1414
Ansi : The symbolic constant "N$PES" is an extension to the Fortran standard.
.PP
N$PES is an extension to the Fortran standard.  It is a special symbolic
constant that is predefined by the compiler to be of type INTEGER; no
attributes may be given to N$PES.  It may be used as a symbolic constant in
places where a symbolic constant is legal.  The value of N$PES is set by a
compiler command line option, a load time option, or a runtime option.
.ME
$
$ Error : 1415
$msg  1415 The AUTOSCOPE clause is not supported on this platform.
$nexp 1415
Error : The AUTOSCOPE clause is not supported on this platform.
.PP
The AUTOSCOPE clause is not supported on this platform.  Any unscoped 
variables will be assumed to be SHARED.
.ME
$
$ Error : 1416
$msg  1416 The order of the loop indices must correspond to the order in this NEST clause.
$nexp 1416
Error : The order of the loop indices must correspond to the order in this NEST clause.
.PP
The NEST clause of the PDO, PARALLEL DO, and DOACROSS directives must
use the same order for it's arguments as the order of the loop control
variables of the nested loops.

C$DOACROSS ... NEST(i,j,k) ...

       do i = 1,10 
       do k = 1,10
       do j = 1,10
       enddo
       enddo
       enddo

The sample above would cause this message to be issued.
.ME
$
$ Error : 1417
$msg  1417 This AFFINITY list item does not match the NEST list.
$nexp 1417
Error : This AFFINITY list item does not match the NEST list.
.PP
The DO loop control variables specified in the AFFINITY clause of
a DOACROSS, PDO, or PARALLEL DO directive must match the order
of the list in the NEST clause.
.ME
$
$ Error : 1418
$msg  1418 ONTO is not allowed for DATA affinity.
$nexp 1418
Error : ONTO is not allowed for DATA affinity.
.PP
The ONTO clause cannot be used when a DATA affinity is specified on 
DOACROSS, PDO, or PARALLEL DO directives.
.ME
$
$ Error : 1419
$msg  1419 Array "%s" is an assumed-size pointee.  It must not be declared in a module.
$nexp 1419
Error : Array "%s" is an assumed-size pointee.  It must not be declared in a module.
.PP
An array that is declared with the assumed-size specifier must not be
specified in a module program unit.
.ME
$
$ Error : 1420
$msg  1420 An interface body cannot access named entities from the host, thus derived type "%s" is undefined.
$nexp 1420
Error : An interface body cannot access named entities from the host, thus derived type "%s" is undefined.
.PP
A NOTE from the Fortran standard states that "An interface body does not
access the named entities by host association, but it may access entities by
USE association."  The compiler has encountered an object used as a derived
type, but there is no definition for the derived type within the definition
for the interface body.  Because the compiler found the derived type in the
interface bodies host, the compiler (correctly or incorrectly) assumes that the
user is attempting to host associate the derived type into the interface body.
This is not allowed.  The best way to do this would be to move the type
definition to a module and use the module in both places.  An alternative
method would be to declare the derived type in both places, taking care that
the derived type declarations meet the requirements for matching derived type
declarations.  (Two different type declarations are considered the same if
they have the same name, both have the SEQUENCE attribute, and have components
that do not have PRIVATE accessibility and agree in order, name, and
attributes.)
.ME
$
$ Internal : 1421
$msg  1421 Local name entry %d has been compressed out during interface compression.  It should not be.
$nexp 1421
Internal : Local name entry %d has been compressed out during interface compression.  It should not be.
.PP
An entry in the local name table was compressed out during interface block
compression.  This entry should not be compressed out.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Error : 1422
$msg  1422 The SAFE_DISTANCE= value on the CONCURRENT directive must be a scalar integer constant greater than or equal to one.
$nexp 1422
Error : The SAFE_DISTANCE= value on the CONCURRENT directive must be a scalar integer constant greater than or equal to one.
.PP
A safe distance value for the \*CCONCURRENT\fR compiler directive must be a 
scalar integer constant expression so that the compiler can evaluate it at
compile time.  The expression must evaluate to an integer value of greater
than or equal to one.
.ME
$
$ Ansi : 1423
$msg  1423 Implicit typing is confirmed for object "%s".  The Fortran standard requires typing before reference with IMPLICIT NONE.
$nexp 1423
Ansi : Implicit typing is confirmed for object "%s".  The Fortran standard requires typing before reference with IMPLICIT NONE.
.PP
The Fortran standard requires that the type of an object be declared before 
that object is referenced when IMPLICIT NONE is specified in the scoping
unit.   In this test, there is a reference to the object before it is typed.
.ME
$
$ Error : 1424
$msg  1424 A type must be declared for "%s" before it is referenced, initialized or declared a constant because of IMPLICIT NONE.
$nexp 1424
Error : A type must be declared for "%s" before it is referenced, initialized or declared a constant because of IMPLICIT NONE.
.PP
If IMPLICIT NONE is specified in a scope, the Fortran standard requires that
a type be declared for an object before the object is referenced, 
initialized, specified as an object in a namelist group or declared as a
constant.
.ME
$
$ Inline : 1425
$msg  1425 Routine %s was not inlined because the function result types do not match.
$nexp 1425
Inline : Routine %s was not inlined because the function result types do not match.
.PP
The function result type of the caller and callee do not match.   Thus,
the compiler cannot expand this function inline.
.ME
$
$ Error : 1426
$msg  1426 "%s" has been referenced or defined in a prior statement in this scope.  It may not be given the PARAMETER attribute.
$nexp 1426
Error : "%s" has been referenced or defined in a prior statement in this scope.  It may not be given the PARAMETER attribute.
.PP
The object being declared has been referenced or defined.  A object must be
given the PARAMETER attribute before being referenced or defined.
.ME
$
$ Error : 1427
$msg  1427 "%s" is a Cray character pointer.  All its pointees must be character, but "%s" is not character.
$nexp 1427
Error : "%s" is a Cray character pointer.  All its pointees must be character, but "%s" is not character.
.PP
A Cray pointer may have more than one pointee, but all pointees must be
either character or non-character.  A mix is not allowed.
.ME
$
$ Error : 1428
$msg  1428 "%s" is a Cray pointer.  All its pointees must be non-character, but "%s" is typed as character.
$nexp 1428
Error : "%s" is a Cray pointer.  All its pointees must be non-character, but "%s" is typed as character.
.PP
A Cray pointer may have multiple pointees.  However, all the pointees must
either be character or non-character.  They must not be mixed.
.ME
$
$ Warning : 1429
$msg  1429 The %s command line option overrides the %s directive, so the directive is ignored.
$nexp 1429
Warning : The %s command line option overrides the %s directive, so the directive is ignored.
.PP
The specified command line option is incompatible with the specified directive.
The directive is ignored and treated as if it is a comment line.
.ME
$
$ Error : 1430
$msg  1430 %s array "%s" cannot be declared in the LOCAL clause of this %s directive.
$nexp 1430
Error : %s array "%s" cannot be declared in the LOCAL clause of this %s directive.
.PP
Localized ALLOCATABLE or POINTER arrays are not supported on mp directives
such as DOACROSS, PDO, PARALLEL DO. They can not be specified
in a LOCAL clause.  Also, Cray Pointees are not supported in a LOCAL clause.
.ME
$
$ Error : 1431
$msg  1431 The argument to the %s clause of the %s directive must be an integer constant or variable.
$nexp 1431
Error : The argument to the %s clause of the %s directive must be an integer constant or variable.
.PP
The argument to this clause on the directive must be an integer constant
or an integer variable.  

   POINT  clause on the SEND directive
   POINT  clause on the WAIT directive
.ME
$
$ Error : 1432
$msg  1432 The argument to the %s clause of the %s directive must be an integer constant.
$nexp 1432
Error : The argument to the %s clause of the %s directive must be an integer constant.
.PP
The argument to this clause on the directive must be an integer constant.

   SPAN  clause on the WAIT directive
.ME
$
$ Error : 1433
$msg  1433 The argument to the %s clause of the %s directive must be a logical expression.
$nexp 1433
Error : The argument to the %s clause of the %s directive must be a logical expression.
.PP
The argument to this clause on the directive must be a logical expression.

   IF  clause on the SEND directive
.ME
$
$ Error : 1434
$msg  1434 The storage size needed for this expression exceeds %s bytes, the maximum storage size available.
$nexp 1434
Error : The storage size needed for this expression exceeds %s bytes, the maximum storage size available.
.PP
The storage needed for this expression exceeds the memory size (in bytes) of this
machine.  The expression could contain array constructors or be the result
of a function call.
.ME
$
$ Error : 1435
$msg  1435 The storage size needed for "%s" exceeds %s bytes, the maximum storage size available.
$nexp 1435
Error : The storage size needed for "%s" exceeds %s bytes, the maximum storage size available.
.PP
The storage needed for this item exceeds the memory size (in bytes) of this
machine.
.ME
$
$ Warning : 1436
$msg  1436 The %s clause is not supported and will be ignored.
$nexp 1436
Warning : The %s clause is not supported and will be ignored.
.PP
The compiler encountered a clause on a tasking directive that is recognized but
not supported. This occurs because the clause is not relevant to the supported
hardware or because support for the clause is deferred until a future release.
.ME
$
$ Inline : 1437
$msg  1437 Routine %s was not inlined because a LOC() of a constant will be generated.
$nexp 1437
Inline : Routine %s was not inlined because a LOC() of a constant will be generated.
.PP
A situation has been encountered where substituting a constant actual
argument in the place of a dummy argument will cause a LOC() of a constant.
The optimizer cannot handle such a construct.
.ME
$
$ Caution : 1438
$msg  1438 This argument produces a %s to a temporary variable.
$nexp 1438
Caution : This argument produces a %s to a temporary variable.
.PP
A function or subroutine call has an argument that must be
copied in or in/out to a temporary variable. If the
message mentions a 'possible' copy in or out, then a runtime
check is performed to see if a copy is necessary for a POINTER
or ALLOCATABLE argument.
.ME
$
$ Error : 1439
$msg  1439 Dummy argument "%s" must not appear in a specification expression.
$nexp 1439
Error : Dummy argument "%s" must not appear in a specification expression.
.PP
Dummy arguments of elemental procedures must not appear in a specification
expression, except as the argument to BIT_SIZE, KIND, LEN or a numeric
inquiry intrinsic.
.ME
$
$ Error : 1440
$msg  1440 Common block name "/%s/", not the object name "%s" must be specified on the %s directive.
$nexp 1440
Error : Common block name "/%s/", not the object name "%s" must be specified on the %s directive.
.PP
Arguments to directives SECTION_GP and SECTION_NON_GP must be common block
names or variables in static storage.  A name of an object in a common block
must not be specified.  Rather, use the common block name.  For example:

    COMMON  /BLK/ A,B

!*$*SECTION_GP /BLK/              ! correct
!*$*SECTION_GP (A)                ! illegal
.ME
$
$ Error : 1441
$msg  1441 "%s" has the %s attribute, therefore it must not be specified with compiler directive %s (identifier first appeared at line %d)
$nexp 1441
Error : "%s" has the %s attribute, therefore it must not be specified with compiler directive %s (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.  
The specified attribute and directive are incompatible, therefore the object
cannot be declared to be both.
.ME
$
$ Error : 1442
$msg  1442 "%s" is a %s, therefore it must not be declared again with compiler directive %s (identifier first appeared at line %d)
$nexp 1442
Error : "%s" is a %s, therefore it must not be declared again with compiler directive %s (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.
The object must not be declared with the specified compiler directive.
.ME
$
$ Error : 1443
$msg  1443 "%s" has been declared and used as a dummy argument.  It must not be declared again with compiler directive %s.
$nexp 1443
Error : "%s" has been declared and used as a dummy argument.  It must not be declared again with compiler directive %s.
.PP
The object being declared is a referenced or defined dummy argument, which
prohibits it from being declared with the specified compiler directive.
.ME
$
$ Error : 1444
$msg  1444 "%s" has been used as a variable, therefore it must not be declared again with compiler directive %s.
$nexp 1444
Error : "%s" has been used as a variable, therefore it must not be declared again with compiler directive %s.
.PP
The object being declared is used as a variable, which prohibits it from
being declared with the specified compiler directive.
.ME
$
$ Warning : 1445
$msg  1445 The %s directive does not affect autotasking under the -pfa command line option.
$nexp 1445
Warning : The %s directive does not affect autotasking under the -pfa command line option.
.PP
The TASK and NOTASK compiler directives are not fully implemented
on this platform. They control the recognition of other
tasking CMIC$ directives, but do not have an affect on 
autotasking under the -pfa command line option.
.ME
$
$ Error : 1446
$msg  1446 %s variable "%s" cannot be declared in the PRIVATE clause of this %s directive.
$nexp 1446
Error : %s variable "%s" cannot be declared in the PRIVATE clause of this %s directive.
.PP
Privatized ALLOCATABLE or POINTER variables are not supported on mp directives
DOALL, and PARALLEL. They can not be specified in a PRIVATE clause.

Also, Cray pointees cannot be specified with the PRIVATE clause.
.ME
$
$ Error : 1447
$msg  1447 "%s" is already a symbolic constant, therefore it must not be specified with compiler directive %s.
$nexp 1447
Error : "%s" is already a symbolic constant, therefore it must not be specified with compiler directive %s.
.PP
N$PES is a special symbolic constant.  It is compiler defined as type INTEGER
and the type must not be changed.  No attributes can be given to N$PES, nor can
N$PES be specified on any compiler directive.  It may be used as a symbolic
constant in places where a symbolic constant is legal.  The value of N$PES is
set by a compiler command line option, a load time option or a runtime option.
.ME
$
$ Error : 1448
$msg  1448 "%s" has been use associated, therefore it must not be declared again with compiler directive %s.
$nexp 1448
Error : "%s" has been use associated, therefore it must not be declared again with compiler directive %s.
.PP
After an object has been use associated, it cannot be specified in any 
specification statements or in any declarative compiler directives such
as ALIGN_SYMBOL, FILL_SYMBOL, NAME, SECTION_GP, SECTION_NON_GP, VFUNCTION or
SYMMETRIC.
.ME
$
$ Error : 1449
$msg  1449 "%s" is host associated, therefore it must not be specified with the %s compiler directive.
$nexp 1449
Error : "%s" is host associated, therefore it must not be specified with the %s compiler directive.
.PP
An object is host associated if it is declared in the host scope and used in
the local scope.  After an object is host associated into a scope, it must 
not be redeclared.  It also must not be specified on a declarative directive.
.ME
$
$ Error : 1450
$msg  1450 "%s" is typed as variable length character, therefore it must not be declared again with compiler directive %s.
$nexp 1450
Error : "%s" is typed as variable length character, therefore it must not be declared again with compiler directive %s.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is typed as a variable length character entity, which
prohibits it from being declared one a declarative compiler directive.
.ME
$
$ Error : 1451
$msg  1451 "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be specified with compiler directive %s.
$nexp 1451
Error : "%s" is an explicit-shape array with nonconstant bounds, therefore it must not be specified with compiler directive %s.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is an explicit-shape array with nonconstant bounds, 
which prohibits it from being specified on a declarative compiler directive.
.ME
$
$ Error : 1452
$msg  1452 "%s" is specified with the %s directive, therefore it must not be typed as variable length character.
$nexp 1452
Error : "%s" is specified with the %s directive, therefore it must not be typed as variable length character.
.PP
The compiler detected a conflict in declarations for this object.  The
object being declared is specified with a directive which prohibits it from
being typed as a variable length character.
.ME
$
$ Error : 1453
$msg  1453 "%s" is defined in an explicit interface, therefore it must not be declared again with compiler directive %s.
$nexp 1453
Error : "%s" is defined in an explicit interface, therefore it must not be declared again with compiler directive %s.
.PP
If an explicit interface is declared for a procedure, all information describing
the procedure must be specified inside the explicit interface, with the 
exception of the \*COPTIONAL\fR, \*CPRIVATE\fR and \*CPUBLIC\fR attributes.
The procedure may be specified as a dummy argument.  This procedure may
also be specified on the \*CINLINE\fR directive.
.ME
$
$ Error : 1454
$msg  1454 "%s" has been used as a function, therefore it must not be declared again with compiler directive %s.
$nexp 1454
Error : "%s" has been used as a function, therefore it must not be declared again with compiler directive %s.
.PP
The object being declared has already been used as a function, so no further
declarations may be made for this object.
.ME
$
$ Error : 1455
$msg  1455 "%s" has been used as a subroutine, therefore it must not be declared again with compiler directive %s.
$nexp 1455
Error : "%s" has been used as a subroutine, therefore it must not be declared again with compiler directive %s.
.PP
The object being declared has already been used as a subroutine, so no further
declarations may be made for this object.
.ME
$
$ Error : 1456
$msg  1456 Only elemental intrinsics of type integer or character are allowed in an initialization expression.
$nexp 1456
Error : Only elemental intrinsics of type integer or character are allowed in an initialization expression.
.PP
The standard says that a primary of an initialization expression may be
an elemental intrinsic function reference of type integer or character
where each argument is an initialization expression of type integer or
character.
.ME
$
$ Error : 1457
$msg  1457 "%s" is specified with the %s directive, so it must not be declared again with the %s directive.
$nexp 1457
Error : "%s" is specified with the %s directive, so it must not be declared again with the %s directive.
.PP
The compiler detected a conflict in declarations for this object.  
This object must not be specified on both directives.
.ME
$
$ Error : 1458
$msg  1458 "%s" is specified with the %s directive, so it must not be declared as a %s.
$nexp 1458
Error : "%s" is specified with the %s directive, so it must not be declared as a %s.
.PP
The compiler detected a conflict in declarations for this object.
The specified directive stops this object from being declared with the
attribute.

.ME
$
$ Error : 1459
$msg  1459 "%s" is specified with the %s directive, therefore it must not be specified with the %s attribute (identifier first appeared at line %d)
$nexp 1459
Error : "%s" is specified with the %s directive, therefore it must not be specified with the %s attribute (identifier first appeared at line %d)
.PP
The compiler detected a conflict in declarations for this object.
The specified directve stops this object from being 

.ME
$
$ Warning : 1460
$msg  1460 A call to start_pes_() has been generated by the compiler.
$nexp 1460
Warning : A call to start_pes_() has been generated by the compiler.
.PP
When using the -ufmm option, the compiler now generates a 
call to start_pes_(0). Please remove any user calls to 
START_PES() in your code.
.ME
$
$ Error : 1461
$msg  1461 This use of construct name "%s" is not allowed.
$nexp 1461
Error : This use of construct name "%s" is not allowed.
.PP
To be supplied.
.ME
$
$ Error : 1462
$msg  1462 This use of label "%s" is not allowed.
$nexp 1462
Error : This use of label "%s" is not allowed.
.PP
To be supplied.
.ME
$
$ Error : 1463
$msg  1463 "%s", specified with the %s directive, is a procedure.  Statement function actual arguments must be scalar data objects.
$nexp 1463
Error : "%s", specified with the %s directive, is a procedure.  Statement function actual arguments must be scalar data objects.
.PP
All actual arguments to a statement function must be scalar data objects.
The following attributes declare an object to be a procedure, which is not a
data object.
.ME
$
$ Error : 1464
$msg  1464 "%s" is specified with the %s directive.  It must not be declared as an explicit-shape array with nonconstant bounds.
$nexp 1464
Error : "%s" is specified with the %s directive.  It must not be declared as an explicit-shape array with nonconstant bounds.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive, so it must not be declared as an
explicit-shape array with nonconstant bounds.
.ME
$
$ Error : 1465
$msg  1465 "%s" is specified with the %s directive.  It must not be an array whose bounds are dependent on a symbolic constant.
$nexp 1465
Error : "%s" is specified with the %s directive.  It must not be an array whose bounds are dependent on a symbolic constant.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive, so it must not be an array whose
bounds are declared with a symbolic constant expression.
.ME
$
$ Error : 1466
$msg  1466 "%s" is specified with the %s directive, therefore it must not be a procedure in an interface block.
$nexp 1466
Error : "%s" is specified with the %s directive, therefore it must not be a procedure in an interface block.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive, so it must not be declared as a 
procedure in an interface block.
.ME
$
$ Error : 1467
$msg  1467 "%s" is specified with the %s directive, therefore it must not be used as an external function name.
$nexp 1467
Error : "%s" is specified with the %s directive, therefore it must not be used as an external function name.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive, so it must not be used as an external
function name.
.ME
$
$ Error : 1468
$msg  1468 "%s" is specified with the %s directive, therefore it must not be used as a subroutine name in a CALL statement.
$nexp 1468
Error : "%s" is specified with the %s directive, therefore it must not be used as a subroutine name in a CALL statement.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive, so it must not be used as a subroutine
name in a CALL statement.
.ME
$
$ Error : 1469
$msg  1469 "%s" is specified with the %s directive, therefore it must not be used as a derived-type name.
$nexp 1469
Error : "%s" is specified with the %s directive, therefore it must not be used as a derived-type name.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive, so it must not be used as a derived-type
name.
.ME
$
$ Error : 1470
$msg  1470 "%s" is specified with the %s directive, so it is not a constant.  It must not be used in an initialization expression.
$nexp 1470
Error : "%s" is specified with the %s directive, so it is not a constant.  It must not be used in an initialization expression.
.PP
The compiler has detected a conflict in declarations.  The object has been
declared with the specified directive.  It must not be used in an 
initialization expression because it is not a constant.
.ME
$
$ Error : 1471
$msg  1471 "%s" has been referenced or declared in this scope already.  It must not be declared as the function result.
$nexp 1471
Error : "%s" has been referenced or declared in this scope already.  It must not be declared as the function result.
.PP
If a result name is specified on the FUNCTION statement, the name must
not have previously been referenced or declared.   A previous reference
is possible in the following example:

         CHARACTER*(RSLT()) FUNCTION FUN() RESULT(RSLT)

A previous declaration would be if the result name was the same as a dummy
argument name.
.ME
$
$ Error : 1472
$msg  1472 This END CRITICAL directive must have the same name as the matching CRITICAL directive.
$nexp 1472
Error : This END CRITICAL directive must have the same name as the matching CRITICAL directive.
.PP
If the CRITICAL section is named, the paired END CRITICAL must also
be named.
.ME
$
$ Error : 1473
$msg  1473 Object %s must be a variable to be in the %s clause of the %s directive.
$nexp 1473
Error : Object %s must be a variable to be in the %s clause of the %s directive.
.PP
Only data objects are allowed in following clauses to OpenMP directives.
PRIVATE
SHARED
FIRSTPRIVATE
COPYIN
REDUCTION
LASTPRIVATE
.ME
$
$ Error : 1474
$msg  1474 DO, SECTIONS, and SINGLE directives are not allowed to be nested.
$nexp 1474
Error : DO, SECTIONS, and SINGLE directives are not allowed to be nested.
.PP
DO, SECTIONS, and SINGLE directives that bind to the same PARALLEL directive
are not allowed to be nested one inside the other. The PARALLEL DO and
PARALLEL SECTIONS directives can be viewed as a PARALLEL directive followed
by the appropriate work sharing directive. Therefore DO, SECTIONS, and
SINGLE directives cannot be nested directly within a PARALLEL DO or
PARALLEL SECTIONS region.
.ME
$
$ Error : 1475
$msg  1475 It is illegal to specify a CHUNK in the SCHEDULE clause when RUNTIME schedule type is specified.
$nexp 1475
Error : It is illegal to specify a CHUNK in the SCHEDULE clause when RUNTIME schedule type is specified.
.PP
In the SCHEDULE clause of OpenMP tasking directives, a CHUNK 
can only be specifed when the TYPE is STATIC, DYNAMIC, or GUIDED.
It can not be specified with RUNTIME.
.ME
$
$ Error : 1476
$msg  1476 Variable "%s" is specified in more than one !$OMP directive clause.
$nexp 1476
Error : Variable "%s" is specified in more than one !$OMP directive clause.
.PP
Each variable specified in clauses to !$OMP directives may appear
explicitly in only one clause, except that a variable may be
specified as both FIRSTPRIVATE and LASTPRIVATE.
.ME
$
$ Error : 1477
$msg  1477 It is illegal to declare a scope attribute for pointee "%s".
$nexp 1477
Error : It is illegal to declare a scope attribute for pointee "%s".
.PP
Cray pointees cannot have scope declared for them in OpenMP tasking
directives.
.ME
$
$ Error : 1478
$msg  1478 %s, "%s", may not be specified in FIRSTPRIVATE or LASTPRIVATE clauses.
$nexp 1478
Error : %s, "%s", may not be specified in FIRSTPRIVATE or LASTPRIVATE clauses.
.PP
Fortran pointers, allocatable arrays and Cray pointers may be specified 
in only the PRIVATE and SHARED clauses of OpenMP tasking directives. 
They may not be specified in either the FIRSTPRIVATE or LASTPRIVATE clause.
.ME
$
$ Error : 1479
$msg  1479 Common block "%s" must be declared before being specified with the THREADPRIVATE directive.
$nexp 1479
Error : Common block "%s" must be declared before being specified with the THREADPRIVATE directive.
.PP
The !$OMP THREADPRIVATE directive must appear in the declaration section
of the routine after the COMMON block has been declared.
.ME
$
$ Error : 1480
$msg  1480 Only named variables are allowed in the list of a FLUSH directive.
$nexp 1480
Error : Only named variables are allowed in the list of a FLUSH directive.
.PP
The !$OMP FLUSH directive has an optional list. This list should contain
only named variables.
.ME
$
$ Error : 1481
$msg  1481 Blank common, "//", must not be declared in a %s directive.
$nexp 1481
Error : Blank common, "//", must not be declared in a %s directive.
.PP
Blank common, specified as //, is not allowed in the COMMON,
TASK COMMON or THREADPRIVATE directives.   These directives must specify
named common blocks.
.ME
$
$ Error : 1482
$msg  1482 %s arrays cannot be specified as PRIVATE, FIRSTPRIVATE, or LASTPRIVATE.
$nexp 1482
Error : %s arrays cannot be specified as PRIVATE, FIRSTPRIVATE, or LASTPRIVATE.
.PP
Assumed size and assumed shape arrays cannot be specified in the
PRIVATE, FIRSTPRIVATE, or LASTPRIVATE clauses of OpenMP directives.
.ME
$
$ Error : 1483
$msg  1483 Object %s must be a scalar variable to be in the REDUCTION clause of the %s directive.
$nexp 1483
Error : Object %s must be a scalar variable to be in the REDUCTION clause of the %s directive.
.PP
Only named scalar, intrinsic typed variables may appear in the list of variables
for the REDUCTION clause. Subobjects, array elements, pointers, and common
blocks are not allowed to be reduction variables.
.ME
$
$ Error : 1484
$msg  1484 %s "%s" is not allowed in the %s clause.
$nexp 1484
Error : %s "%s" is not allowed in the %s clause.
.PP
Fortran pointers, allocatable arrays, and Cray pointers are only allowed
in the SHARED and PRIVATE clauses. They are disallowed in REDUCTION lists,
FIRSTPRIVATE, LASTPRIVATE, and COPYIN clauses.
.ME
$
$ Error : 1485
$msg  1485 Common block "/%s/" is host or use associated.  It must not be specified with the THREADPRIVATE directive.
$nexp 1485
Error : Common block "/%s/" is host or use associated.  It must not be specified with the THREADPRIVATE directive.
.PP
If a common block is specified on a THREADPRIVATE directive, it must be
specified with the directive at all declarations.  The specified common block 
is host or use associated into this scope, but it is not specified in its
declaring scope with the THREADPRIVATE directive.   THREADPRIVATE may be
specified with a use associated common block only as a confirming declaration.
ie:  It is specified with THREADPRIVATE in the declaring module.  Thus the
directive can be used as a method of determining if the common block is
declared in the module with THREADPRIVATE.
.ME
$
$ Error : 1486
$msg  1486 Storage block "/%s/" must be declared as a common block before being specified with the THREADPRIVATE directive.
$nexp 1486
Error : Storage block "/%s/" must be declared as a common block before being specified with the THREADPRIVATE directive.
.PP
Only common blocks can be specified with the THREADPRIVATE directive.  The
same storage block, must not be specified with the TASKCOMMON or AUXILIARY
directives.  It must not be specified with the TASKCOMMON statement.
.ME
$
$ Error : 1487
$msg  1487 A variable subobject is not allowed on the %s compiler directive.
$nexp 1487
Error : A variable subobject is not allowed on the %s compiler directive.
.PP
Variable subobjects (array elements or sections, character substrings,
structure component references) are not allowed on the following directives:

	\*CSUPPRESS\fR
		Only variable names are allowed.

	\*CCACHE_ALIGN\fR
		Only variable names and common blocks are allowed.

	\*CALIGN_SYMBOL\fR
	\*CFILL_SYMBOL\fR
		Only common block variables and automatic variables are
		allowed.   A common block or module name may also be specified.
                If a module name is specified, that applies the directive to
                all non COMMON storage in that module.

	\*CSECTION_GP\fR
	\*CSECTION_NON_GP\fR
		Only common block variables and SAVE variables are allowed.
		A common block or module name may also be specified.
                If a module name is specified, that applies the directive to
                all non COMMON storage in that module.
.ME
$
$ Error : 1488
$msg  1488 "%s", a member of common block "/%s/" must not be equivalenced because directive %s has been specified for the block.
$nexp 1488
Error : "%s", a member of common block "/%s/" must not be equivalenced because directive %s has been specified for the block.
.PP
If the ALIGN_SYMBOL or FILL_SYMBOL directive is specified for a common 
block, no members of the common block may be equivalenced.
.ME
$
$ Error : 1489
$msg  1489 "%s", a member of module "%s" must not be equivalenced because directive %s has been specified for the module.
$nexp 1489
Error : "%s", a member of module "%s" must not be equivalenced because directive %s has been specified for the module.
.PP
If the ALIGN_SYMBOL or FILL_SYBMOL directive is specified for a module,
then all static objects in the module that are not specified in common
blocks are affected by the directive.  Anything with the ALIGN_SYMBOL or
FILL_SYMBOL directive must not be equivalenced.
.ME
$
$ Error : 1490
$msg  1490 Storage block or module "%s" has the %s directive specified for it, so the %s directive must not also be specified.
$nexp 1490
Error : Storage block or module "%s" has the %s directive specified for it, so the %s directive must not also be specified.
.PP
The ALIGN_SYMBOL and FILL_SYMBOL directives are mutually exclusive.  If
on directive is specified for a common block or module, the other must not
be specified.
.ME
$
$ Error : 1491
$msg  1491 If compiler directive %s is specified for a module name, it must be for the current module being compiled.
$nexp 1491
Error : If compiler directive %s is specified for a module name, it must be for the current module being compiled.
.PP
The SECTION_GP, SECTION_NON_GP, ALIGN_SYMBOL and FILL_SYMBOL compiler directives
may be specified for a module.  But they can only be specified for the
current module being compiled.  The directive then applies to all static
non-common storage in the module
.ME
$
$ Error : 1492
$msg  1492 Dummy argument "%s" has the INTENT(IN) attribute. It must be definable to be declared in a %s clause.
$nexp 1492
Error : Dummy argument "%s" has the INTENT(IN) attribute. It must be definable to be declared in a %s clause.
.PP
Dummy arguments that have the INTENT(IN) attribute are not
definable. All variables that are specified in the PRIVATE,
FIRSTPRIVATE, LASTPRIVATE, or REDUCTION clauses of OpenMP
directives must be definable.
.ME
$
$ Error : 1493
$msg  1493 Variable "%s" is in a %s procedure and cannot be defined. It must be definable to be specified in a %s clause.
$nexp 1493
Error : Variable "%s" is in a %s procedure and cannot be defined. It must be definable to be specified in a %s clause.
.PP
All variables specified in the PRIVATE, FIRSTPRIVATE, LASTPRIVATE, or
REDUCTION clauses of OpenMP directives must be definable.

A constraint to PURE procedures in the Fortran standard, prohibits the
following dummy arguments from being defined within a PURE subprogram:  all 
dummy arguments to a function subprogram and all dummy arguments with the 
INTENT(IN) attribute with a subroutine subprogram.

A constraint also prohibits the name of a common, host associated or
use associated variable from appearing in a statement that would change the
variable's value.  The variable can be used but not redefined inside a pure
subprogram.

By definition, an elemental subprogram is pure, so the above constraints also
apply to dummy arguments and variables within elemental subprograms.
.ME
$
$ Warning : 1494
$msg  1494 Variable "%s" is referenced but not defined in this program unit.
$nexp 1494
Warning : Variable "%s" is referenced but not defined in this program unit.
.PP
The compiler has detected a variable that is referenced in this program unit
but never defined.  This variable is not a dummy argument, in a common 
block or use associated, thus if it is referenced in this program unit,
it also needs to be defined in this program unit.
.ME
$
$ Inline : 1495
$msg  1495 Routine %s was not inlined because it is a module procedure and NOMODINLINE is in effect.
$nexp 1495
Inline : Routine %s was not inlined because it is a module procedure and NOMODINLINE is in effect.
.PP
There is no information  available to inline because the module procedure in 
question is under the control of NOMODINLINE.
NOMODINLINE could have been specified via the command line or thru the use
of a NOMODINLINE compiler directive.

.ME
$
$ Error : 1496
$msg  1496 "%s" is not a module in this scope, therefore it must not be specified on the implicit use option as a module-name.
$nexp 1496
Error : "%s" is not a module in this scope, therefore it must not be specified on the implicit use option as a module-name.
.PP
The name specified on the implicit use command line option as a module name
is already known to this scope as something other than a module name.
The \fImodule_name\fR can only be a module name.
.ME
$
$ Error : 1497
$msg  1497 "%s" is specified with the %s directive.  It must be a common block name, a module name, or in static storage.
$nexp 1497
Error : "%s" is specified with the %s directive.  It must be a common block name, a module name, or in static storage.
.PP
Only statically allocated variables may be specified with the SECTION_GP
and SECTION_NON_GP compiler directives.   (Using the SAVE statement, will
force a variable to be statically allocated.)  A common block or module name
may also be specified.  If a module name is specified, that applies the
directive to all non COMMON storage in that module.
.ME
$
$ Error : 1498
$msg  1498 Module name "%s", not the object name "%s" must be specified on the %s directive.
$nexp 1498
Error : Module name "%s", not the object name "%s" must be specified on the %s directive.
.PP
Kay - to be supplied
.ME
$
$ Error : 1499
$msg  1499 The value for work distribution %s must be a positive integer.
$nexp 1499
Error : The value for work distribution %s must be a positive integer.
.PP
For the DO ALL and DO PARALLEL compiler directives, the value 
specified for work distributions CHUNKSIZE and NUMCHUNKS must
be an integer value greater than zero.
.ME
$
$ Error : 1500
$msg  1500 The overall size of the dummy argument array is greater than the size of this actual argument.
$nexp 1500
Error : The overall size of the dummy argument array is greater than the size of this actual argument.
.PP
The overall size of an array dummy argument must be less than or equal
to the size of the associated actual argument array when they are
sequence associated. If the type of the array is character, then
the total length of the character dummy argument array must
be less than or equal to the total length of the character actual
argument array sequence.
.ME
$
$ Error : 1501
$msg  1501 "%s" has been referenced in the function character length expression.  It must not be declared with directive %s.
$nexp 1501
Error : "%s" has been referenced in the function character length expression.  It must not be declared with directive %s.
.PP
The compiler detected a conflict between a use and a declaration for an object.
The object being declared was referenced in the function character length
expression, which prohibits it from being declared with the specified
compiler directive.
.ME
$
$ Error : 1502
$msg  1502 Common block "/%s/" is specified in a %s directive, therefore it must be specified in a COMMON statement.
$nexp 1502
Error : Common block "/%s/" is specified in a %s directive, therefore it must be specified in a COMMON statement.
.PP
If a common block is specified in a \*CCDIR$ (!DIR$)\fR \*CCACHE_ALIGN\fR 
statement, a \*C$OMP THREADPRIVATE\fR directive, or with one of the 
following \*!*$*\fR directives (\*SECTION_GP, SECTION_NON_GP\fR), the
common block must also be declared in a \*CCOMMON\fR statement.
.ME
$
$ Error : 1503
$msg  1503 Illegal branch %s a %s region.
$nexp 1503
Error : Illegal branch %s a %s region.
.PP
It is illegal to branch into or out of the structured blocks created
by OpenMP directives PARALLEL, DO, SECTIONS, SINGLE, PARALLEL DO,
PARALLEL SECTIONS, MASTER, CRITICAL, and ORDERED.  This includes GOTO 
statements as well as ERR=, EOF= or EOR= branches from IO statements 
and alternate return branches from subroutine calls.
.ME
$
$ Error : 1504
$msg  1504 Illegal branch %s a %s region.
$nexp 1504
Error : Illegal branch %s a %s region.
.PP
It is illegal to branch into or out of the structured blocks created by -mp
directives DOACROSS, PSECTION, SECTION, PDO, PARALLEL DO, PARALLEL,
CRITICAL SECTION, and SINGLE PROCESS. This includes GOTO statements as well as
ERR=, EOF= or EOR= branches from IO statements and alternate return branches
from subroutine calls.
.ME
$
$ Error : 1505
$msg  1505 "%s" is specified with the %s directive, therefore it must be a dummy argument.
$nexp 1505
Error : "%s" is specified with the %s directive, therefore it must be a dummy argument.
.PP
If an object is specified with the IGNORE_TYPE_AND_KIND directive, it must be
declared as a dummy argument.
.ME
$
$ Error : 1506
$msg  1506 An ORDERED directive can only appear in the dynamic extent of a DO or PARALLEL DO directive.
$nexp 1506
Error : An ORDERED directive can only appear in the dynamic extent of a DO or PARALLEL DO directive.
.PP
An ORDERED OpenMP directive was encountered that did not bind
to an enclosing DO or PARALLEL DO directive. This was detected
because the ORDERED directive was within the static extent of
a PARALLEL directive. A directive can never bind to any directive
outside the closest enclosing PARALLEL directive. The PARALLEL
SECTIONS directive implies a PARALLEL directive.
.ME
$
$ Error : 1507
$msg  1507 It is illegal for an ORDERED directive to bind to a DO directive that does not have the ORDERED clause specified.
$nexp 1507
Error : It is illegal for an ORDERED directive to bind to a DO directive that does not have the ORDERED clause specified.
.PP
An ORDERED directive must bind to an enclosing DO or PARALLEL DO directive.
The ORDERED clause must be specified on that directive.
.ME
$
$ Error : 1508
$msg  1508 The %s directive must be specified within the declaration part of a module.
$nexp 1508
Error : The %s directive must be specified within the declaration part of a module.
.PP
The compiler has detected the specified directive within the scope of a 
PROGRAM, BLOCKDATA, external SUBROUTINE or external FUNCTION.  This directive
must only be specified in the declaration part of a module.

.ME
$
$ Error : 1509
$msg  1509 Do loop control variable "%s" is in a parallel region and must be in the PRIVATE list if autoscope is not specified.
$nexp 1509
Error : Do loop control variable "%s" is in a parallel region and must be in the PRIVATE list if autoscope is not specified.
.PP
All user variables used in a parallel region or DOALL loop must be in either
the SHARED or PRIVATE list if AUTOSCOPE is not specified. Do loop control
variables cannot be scoped SHARED, so they must be specified in the
PRIVATE list.
.ME
$
$ Error : 1510
$msg  1510 Variable "%s" must have its data scope explicitly declared because DEFAULT(NONE) was specified.
$nexp 1510
Error : Variable "%s" must have its data scope explicitly declared because DEFAULT(NONE) was specified.
.PP
The use of the DEFAULT(NONE) clause on the !$OMP PARALLEL, !$OMP PARALLEL DO,
and !$OMP PARALLEL SECTIONS directives means that all variables encountered
within these regions be explicitly scoped.
.ME
$
$ Error : 1511
$msg  1511 The expression in an IF clause must be a scalar Fortran logical expression.
$nexp 1511
Error : The expression in an IF clause must be a scalar Fortran logical expression.
.PP
If an IF clause is present in an !$OMP PARALLEL, !$OMP PARALLEL DO,
or !$OMP PARALLEL SECTIONS directive, it must have a scalar Fortran
logical expression as it argument.
.ME
$
$ Error : 1512
$msg  1512 Variable "%s" was privatized in the enclosing PARALLEL region. It cannot be privatized again.
$nexp 1512
Error : Variable "%s" was privatized in the enclosing PARALLEL region. It cannot be privatized again.
.PP
Variables that are privatized in a parallel region cannot be privatized
again on an enclosed work-sharing directive. As a result, variables
that appear in the PRIVATE, FIRSTPRIVATE, LASTPRIVATE and RDUCTION clauses
on a work-sharing directive must have shared scope in the enclosing
parallel region. Work-sharing directives are !$OMP DO, !$OMP SECTIONS,
and !$OMP SINGLE.
.ME
$
$ Error : 1513
$msg  1513 The %s directive must appear immediately after the end of the Do loop.
$nexp 1513
Error : The %s directive must appear immediately after the end of the Do loop.
.PP
If used, the !$OMP END DO, !$OMP END PARALLEL DO, or the !DIR$ META END DO
directive must appear immediately after the DO loop.
.ME
$
$ Error : 1514
$msg  1514 The DO loop iteration variable must be of type integer when within an OpenMP work-sharing construct.
$nexp 1514
Error : The DO loop iteration variable must be of type integer when within an OpenMP work-sharing construct.
.PP
The DO loop iteration variable must be of type integer when the DO loop
is within a !$OMP DO or !$OMP PARALLEL DO work-sharing construct.
.ME
$
$ Ansi : 1515
$msg  1515 Procedure "%s" has multiple explicit interfaces declared in the same scope.  This is nonstandard.
$nexp 1515
Ansi : Procedure "%s" has multiple explicit interfaces declared in the same scope.  This is nonstandard.
.PP
The compiler allows an interface body that describes the program unit
being compiled, if the two explicit interfaces agree completely.  The
keyword (dummy argument) names and number must be the same.  The kind,
type and rank of each dummy argument must be the same.  If the
procedure is a function the kind, type, rank and result name must
be the same.  This is not allowed by the Fortran standard.
.ME
$
$ Error : 1516
$msg  1516 Procedure "%s" has multiple explicit interfaces declared in this scope.  The interfaces must agree completely.
$nexp 1516
Error : Procedure "%s" has multiple explicit interfaces declared in this scope.  The interfaces must agree completely.
.PP
The compiler allows an interface body that describes the program unit
being compiled, if the two explicit interfaces agree completely.  The
keyword (dummy argument) names and number must be the same.  The kind,
type and rank of each dummy argument must be the same.  If the
procedure is a function the kind, type, rank and result name must
be the same.  The compiler has detected a difference.
.ME
$
$ Error : 1517
$msg  1517 Invalid %s clause.
$nexp 1517
Error : Invalid %s clause.
.PP
A directive was encountered with an unrecognized clause.
.ME
$
$ Warning : 1518
$msg  1518 The %s is an extension to the OpenMP standard. It should have the %s sentinal.
$nexp 1518
Warning : The %s is an extension to the OpenMP standard. It should have the %s sentinal.
.PP
The mp clauses AFFINITY and NEST are allowed to be used with OpenMP
directives but should be used with the !$SGI sentinal so that the
code remains portable. The following code fragment illustrates how
they should be used.

!$OMP DO
!$SGI+ NEST (i)
      do i = 1,100
         a(i) = 0
      enddo

Also the mp directives DISTRIBUTE, DISTRIBUTE_RESHAPE, REDISTRIBUTE,
DYNAMIC, and PAGE_PLACE can be specified with the !$SGI sentinal, but
they should not be specified with the !$OMP sentinal.
.ME
$
$ Error : 1519
$msg  1519 The autotasking directive WAIT must not be specified within a %s region.
$nexp 1519
Error : The autotasking directive WAIT must not be specified within a %s region.
.PP
!MIC$ WAIT must be specified within a DOALL or DOPARALLEL region.  It must
not be allowed within a CASE or GUARD region.
.ME
$
$ Error : 1520
$msg  1520 The autotasking directive %s must be specified within a DOPARALLEL or DOALL region.
$nexp 1520
Error : The autotasking directive %s must be specified within a DOPARALLEL or DOALL region.
.PP
The autotasking directives WAIT and SEND must be specified within a DOALL or
DOPARALLEL region.
.ME
$
$ Error : 1521
$msg  1521 All WAIT/SEND pairs within a loop except one must be numbered.  The numbers must be unique.
$nexp 1521
Error : All WAIT/SEND pairs within a loop except one must be numbered.  The numbers must be unique.
.PP
Within a loop containing more than one section of dependent code, all
WAIT/SEND pairs except one must be numbered.  If the point value is an
integer variable, its value must be unique for each WAIT/SEND pair.
.ME
$
$ Error : 1522
$msg  1522 Object "%s" must not be used as an argument to the KIND intrinsic before being typed.
$nexp 1522
Error : Object "%s" must not be used as an argument to the KIND intrinsic before being typed.
.PP
An object used as an argument to the KIND intrinsic must be typed before
being used.  The compiler has detected an object being typed after it is
referenced as an argument to the KIND intrinsic.
.ME
$
$ Error : 1523
$msg  1523 A WAIT/SEND pair must both have the same POINT value or neither of them should have a POINT value.
$nexp 1523
Error : A WAIT/SEND pair must both have the same POINT value or neither of them should have a POINT value.
.PP
The compiler has detected a mismatch for the POINT value in a WAIT/SEND pair.
If a POINT value is specified for the WAIT directive, the same POINT value
must be specified for the SEND directive.  If no POINT value is specified
for the WAIT directive, then no POINT value should be specified for the 
SEND directive.
.ME
$
$ Warning : 1524
$msg  1524 COMMON block %s is increasing in length due to the inline expansion of routine %s.
$nexp 1524
Warning : COMMON block %s is increasing in length due to the inline expansion of routine %s.
.PP
A routine is being inlined which happens to contain an identical COMMON
block in the caller.   The length of the COMMON block in the callee is
greater than the length of the COMMON block in the caller.    Thus,
the length of the merged COMMON block is the length of the longer of the
two.
.ME
$
$ Error : 1525
$msg  1525 Multiple spans within a loop are not allowed.
$nexp 1525
Error : Multiple spans within a loop are not allowed.
.PP
All spans specified within a loop must be the same.  The compiler has
detected different spans.
.ME
$
$ Error : 1526
$msg  1526 The maximum number of wait/send directive pairs for this loop is %d and has been exceeded.
$nexp 1526
Error : The maximum number of wait/send directive pairs for this loop is %d and has been exceeded.
.PP
The limit on the total number of unspanned WAIT/SEND directive pairs
within a DOALL/PARALLEL loop is 65.  This number includes one unnumbered 
WAIT/SEND directive pair and 64 uniquely numbered WAIT/SEND directive pairs.
If an unnumbered WAIT/SEND pair is not used, the limit is 64.  If this 
limit is exceeded, compiler errors will result.

For spanned WAIT/SEND directive pairs, the limit is "64/span value".  For
example, for a span value of 4, the limit is 16, including one unnumbered
WAIT/SEND pair, and 15 uniquely numbered WAIT/SEND pairs.  Furthermore, the
POINTs associated with each WAIT/SEND pair must fall within the
 1 <= n <= 15 range.  This limit is the same, even if an unnumbered WAIT/SEND
pair is not used.  If this limit is exceeded, compiler errors will result.
.ME
$
$ Error : 1527
$msg  1527 This %s POINT does not match a %s POINT in this loop.
$nexp 1527
Error : This %s POINT does not match a %s POINT in this loop.
.PP
The compiler has detected a SEND or a WAIT directive without a matching
WAIT or SEND directive.  The directives are matched on the POINT value or
lack of a POINT value.
.ME
$
$ Error : 1528
$msg  1528 Constant point values must not exceed %d, which is the maximum number of wait/send directive pairs.
$nexp 1528
Error : Constant point values must not exceed %d, which is the maximum number of wait/send directive pairs.
.PP
If the point values are constant values the value must not exceed the 
maximum number of allowed wait/send directive pairs.  The value is
calculated as follows:

The limit on the total number of unspanned WAIT/SEND directive pairs
within a DOALL/PARALLEL loop is 65.  This number includes one unnumbered 
WAIT/SEND directive pair and 64 uniquely numbered WAIT/SEND directive pairs.
If an unnumbered WAIT/SEND pair is not used, the limit is 64.  If this 
limit is exceeded, compiler errors will result.
   
For spanned WAIT/SEND directive pairs, the limit is "64/span value".  For
example, for a span value of 4, the limit is 16, including one unnumbered
WAIT/SEND pair, and 15 uniquely numbered WAIT/SEND pairs.  Furthermore, the
POINTs associated with each WAIT/SEND pair must fall within the
1 <= n <= 15 range.  This limit is the same, even if an unnumbered WAIT/SEND
pair is not used.  If this limit is exceeded, compiler errors will result.
.ME
$
$ Error : 1529
$msg  1529 Object "%s" is already a module procedure within this module, so it must not be declared again as a module procedure.
$nexp 1529
Error : Object "%s" is already a module procedure within this module, so it must not be declared again as a module procedure.
.PP
The object being declared is already a module procedure.  A module procedure
must not be declared more than once in a module.
.ME
$
$ Warning : 1530
$msg  1530 The %s directive is obsolete and will be removed in the next major release.
$nexp 1530
Warning : The %s directive is obsolete and will be removed in the next major release.
.PP
The MAXCPUS directive is obsolete and will be removed in the next major 
release of the compiler.  (3.2 on PVP's).  The MAXCPUS clause on the 
PARALLEL or DO ALL directives should be used instead. 
.ME
$
$ Error : 1531
$msg  1531 This initialization expression has a non-constant value.  It must evaluate to a constant value at compile time.
$nexp 1531
Error : This initialization expression has a non-constant value.  It must evaluate to a constant value at compile time.
.PP
An initialization expression, by definition, must evaluate to a constant value
at compile time.  This initialization expression does not evaluate to a constant
value.  Major uses of Initialization expressions are component declarations
and parameter declarations.
.ME
$
$ Error : 1532
$msg  1532 If SPAN is specified, it must be an integer constant value in the range 1 to 64.
$nexp 1532
Error : If SPAN is specified, it must be an integer constant value in the range 1 to 64.
.PP
The SPAN argument to the WAIT directive must be an integer constant in the
range 1 to 64.  The SPAN argument is optional.   If SPAN is specified for any
WAIT directive within the range of a DOALL/DOPARALLEL directive, the same
SPAN  must be specified for all WAITs within that range.
.ME
$
$ Error : 1533
$msg  1533 The argument must be default integer type.
$nexp 1533
Error : The argument must be default integer type.
.PP
The argument must be of default integer type. 
.ME
$
$ Internal : 1534
$msg  1534 All specifics that are intrinsic, must follow all non-inrinsic specifics.  Intrinsic %s is out of order.
$nexp 1534
Internal : All specifics that are intrinsic, must follow all non-inrinsic specifics.  Intrinsic %s is out of order.
.PP
The compiler has found an unexpected ordering for specifics within a
generic interface.  The compiler did not get the ordering correct.  Please
report this problem.  You may be able to reorder some specifics or USE
statements as a work around.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Log_Error : 1535
$msg  1535 "-O %d" is specified, therefore "-O %s" must not be specified.
$nexp 1535
Log_Error : "-O %d" is specified, therefore "-O %s" must not be specified.
.PP
If an optimization level is specified on the command line using \*C-O num\fR, 
none of the following options may be specified on the command line:

    -O scalar0  -O vector0  -O task0
    -O scalar1  -O vector1  -O task1
    -O scalar2  -O vector2  -O task2
    -O scalar3  -O vector3  -O task3
.ME
$
$ Log_Warning : 1536
$msg  1536 The optimzation level should be %s, because the debugging level is %d.
$nexp 1536
Log_Warning : The optimzation level should be %s, because the debugging level is %d.
.PP
The optimization level is set too high for the debug level.  Lower the
optimization level using the \*C-O\fR command-line option.
.ME
$
$ Error : 1537
$msg  1537 A component reference is not allowed in an EQUIVALENCE statement.
$nexp 1537
Error : A component reference is not allowed in an EQUIVALENCE statement.
.PP
Component references are not allowed in an EQUIVALENCE statement.
.ME
$
$ Warning : 1538
$msg  1538 Array "%s" is specified on the -O reshape command line option.  It is not an array in scope "%s".
$nexp 1538
Warning : Array "%s" is specified on the -O reshape command line option.  It is not an array in scope "%s".
.PP
The compiler has found an object with the same name as an array specified on
the reshape dimension command line.  It is not an array.
.ME
$
$ Error : 1539
$msg  1539 Array "%s" must be an explicit shape constant or variable sized array to be specified with -O reshape.
$nexp 1539
Error : Array "%s" must be an explicit shape constant or variable sized array to be specified with -O reshape.
.PP
If an array is specified with the reshape dimensions command line option the
array must be an explicit shape constant size array or an explicit shape
variable sized array.
.ME
$
$ Log_Error : 1540
$msg  1540 The -O inlinefrom= option must be specified when the -O inlinepgm= option is specified.
$nexp 1540
Log_Error : The -O inlinefrom= option must be specified when the -O inlinepgm= option is specified.
.PP
The -O inlinepgm= option requires the -O inlinefrom= option.
.ME
$
$ Error : 1541
$msg  1541 Support for passing a DISTRIBUTE_RESHAPE array to an assumed-shape dummy argument is deferred.
$nexp 1541
Error : Support for passing a DISTRIBUTE_RESHAPE array to an assumed-shape dummy argument is deferred.
.PP
The association of an assumed-shape array dummy argument with an array
actual argument that has been specified in a DISTRIBUTE_RESHAPE 
compiler directive is not supported in this release of the compiler. The support
has been deferred until a future release.
.ME
$
$ Warning : 1542
$msg  1542 Initializing a named common block member in a program unit other than a block data is not legal for this architecture.
$nexp 1542
Warning : Initializing a named common block member in a program unit other than a block data is not legal for this architecture.
.PP
An object is being initialized either by a \*CDATA\fR statement or by 
initialization on a type declaration statement.  The object is a member of a
named common block.  The Fortran standard states that if an object is a member
of a named common block it should only be initialized in a block data program
unit.

Initializing a named common block member in a program unit other than a block 
data program unit could lead to multiple initializations for the same common 
block.  Multiple initializations of the same common block are not allowed on
this architecture.
.ME
$
$ Inline : 1543
$msg  1543 Routine %s was not inlined because the routine is not a leaf routine in the call graph.
$nexp 1543
Inline : Routine %s was not inlined because the routine is not a leaf routine in the call graph.
.PP
Routines which are not leaf routines in the call graph computed for this
program are not expanded inline.   A leaf routine is a routine which
calls no other routines.
.ME
$
$ Error : 1544
$msg  1544 The loop that follows this %s directive cannot be a DO WHILE or a DO loop without loop control.
$nexp 1544
Error : The loop that follows this %s directive cannot be a DO WHILE or a DO loop without loop control.
.PP
The DO loop that follows a !$OMP DO or !$OMP PARALLEL DO directive must
be an iterative DO loop. It cannot be a DO WHILE or a DO loop without
loop controls.
.ME
$
$ Inline : 1545
$msg  1545 Routine %s was not inlined because the rank of the actual and dummy arguments are not identical.
$nexp 1545
Inline : Routine %s was not inlined because the rank of the actual and dummy arguments are not identical.
.PP
When mapping an actual argument to a dummy argument the ranks must be
identical.

eg.

program boo
dimension a(10,10)
call sam(a)            ! will not inline
end


subroutine sam(b)
dimension b(100)
print *, b
end
.ME
$
$ Inline : 1546
$msg  1546 Routine %s was not inlined because the extents are not identical in all dimensions.
$nexp 1546
Inline : Routine %s was not inlined because the extents are not identical in all dimensions.
.PP
The extents must be identical in each dimension of the associated
actual and dummy argument for inlining to take place.

eg.
program boo
dimension a(11,10)
call sam(a)     ! will not inline because first dimension extents not equal
end

subroutine sam(b)
dimension b(10,10)
print *, b
end
.ME
$
$ Error : 1547
$msg  1547 Module name "%s", not the variable name "%s" must be specified on the %s directive.
$nexp 1547
Error : Module name "%s", not the variable name "%s" must be specified on the %s directive.
.PP
Specific non-common variables within a module must not be specified 
individually with the SECTION_GP and SECTION_NON_GP directives. 
The SECTION_GP and SECTION_NON_GP directives may be applied to
non-common variables within a module by specifing the module name
with the directive.  Then all non-common static storage within 
the module will have the SECTION_GP or SECTION_NON_GP directive 
applied to it.
.ME
$
$ Log_Warning : 1548
$msg  1548 %s is no longer the most aggressive form of inlining.  Please see explain for this message number.
$nexp 1548
Log_Warning : %s is no longer the most aggressive form of inlining.  Please see explain for this message number.
.PP
The most aggressive form of inlining is now obtained thru -Oinline4.
-Oinline3 is a new form of inlining.  -Oinline3 invokes leaf routine
inlining.   A leaf routine is a routine which calls no other routines.
With -Oinline3 only leaf routines are expanded inline in the program.
.ME
$
$ Warning : 1549
$msg  1549 Macro "%s" is used within its own definition.
$nexp 1549
Warning : Macro "%s" is used within its own definition.
.PP
A macro name cannot be used within its own definition as this
would cause an unending recursive macro expansion. This warning
means that the specified macro remains undefined.
.ME
$
$ Warning : 1550
$msg  1550 Too few arguments in invocation of macro "%s".
$nexp 1550
Warning : Too few arguments in invocation of macro "%s".
.PP
The number of arguments in this macro invocation does not match
the definition. This warning means that the macro expansion
did not occur.
.ME
$
$ Warning : 1551
$msg  1551 Too many arguments in invocation of macro "%s".
$nexp 1551
Warning : Too many arguments in invocation of macro "%s".
.PP
The number of arguments in this macro invocation does not match
the definition. This warning means that the macro expansion
did not occur.
.ME
$
$ Error : 1552
$msg  1552 "%s" has the ALLOCATABLE attribute, therefore it must be specified as a deferred-shape co-array.
$nexp 1552
Error : "%s" has the ALLOCATABLE attribute, therefore it must be specified as a deferred-shape co-array.
.PP
If an object is declared to be an allocatable co-array, it must be
declared to be a deferred-shape co-array. The following are two correct ways of
declaring A to be an allocatable co-array.

         ALLOCATABLE :: A(:)[:]

         REAL, ALLOCATABLE :: A
         DIMENSION A(:)[:]

The following are not legal.

         ALLOCATABLE :: A(:)[8]

         REAL, ALLOCATABLE :: A
         DIMENSION A(:)[8]


.ME
$
$ Inline : 1553
$msg  1553 Routine %s was not inlined because the actual argument is a structure reference.
$nexp 1553
Inline : Routine %s was not inlined because the actual argument is a structure reference.
.PP
The compiler cannot support mappings where the actual argument is the whole
derived type.
.ME
$
$ Inline : 1554
$msg  1554 Routine %s was not inlined because the actual argument is a character constant.
$nexp 1554
Inline : Routine %s was not inlined because the actual argument is a character constant.
.PP
The inliner cannot expand character constants actual arguments.
.ME
$
$ Inline : 1555
$msg  1555 Routine %s was not inlined because it contains DATA statements.
$nexp 1555
Inline : Routine %s was not inlined because it contains DATA statements.
.PP
Routines containing static initialization such as DATA statements cannot be
expanded inline.
.ME
$
$ Inline : 1556
$msg  1556 Routine %s was not inlined because the routine contains a parallel region.
$nexp 1556
Inline : Routine %s was not inlined because the routine contains a parallel region.
.PP
This routine was not expanded inline because the routine contains a parallel
region and the call site that is being inlined already exists within a 
parallel region.   Parallel regions cannot exists within other parallel
regions.
.ME
$
$ Error : 1557
$msg  1557 Illegal placement of the NULL intrinsic.
$nexp 1557
Error : Illegal placement of the NULL intrinsic.
.PP
The NULL intrinsic can appear in the following places:

1) right side of a pointer assignment
2) initialization for an object in a declaration
3) default initialization for a component
4) in a structure constructor
5) as an actual argument
6) in a DATA statement  
.ME
$
$ Error : 1558
$msg  1558 This ALLOCATE shape specifier has missing %s.
$nexp 1558
Error : This ALLOCATE shape specifier has missing %s.
.PP
The compiler encountered a malformed ALLOCATE shape specifier.
If the ':' is used, then both the lower and upper
bound must be specified.
All of the following examples will produce this message.

      ALLOCATE ( a(:) )
      ALLOCATE ( a(1:) )
      ALLOCATE ( a(:10) )


.ME
$
$ Error : 1559
$msg  1559 Pointers must be initialized with the NULL intrinsic.
$nexp 1559
Error : Pointers must be initialized with the NULL intrinsic.
.PP
Pointers can only be intialized statically with the NULL intrinsic.
.ME
$
$ Error : 1560
$msg  1560 Invalid CHUNK value.
$nexp 1560
Error : Invalid CHUNK value.
.PP
The value of the CHUNK argument to the OpenMP SCHEDULE clause
must be greater than zero.
.ME
$
$ Error : 1561
$msg  1561 "%s" is must be a locally declared variable to be specified in the %s list of the %s directive.
$nexp 1561
Error : "%s" is must be a locally declared variable to be specified in the %s list of the %s directive.
.PP
An object other than a variable is in a \*CSHARED\fR or \*CPRIVATE\fR list
on a compiler directive statement.  The variable must also be locally
declared.  The variable cannot be host associated or use associated.
.ME
$
$ Error : 1562
$msg  1562 Illegal pointer assignment.
$nexp 1562
Error : Illegal pointer assignment.
.PP
This is not a valid pointer assignment statement. 
.ME
$
$ Ansi : 1563
$msg  1563 The "* <char-length> [,]" form of character declaration is obsolesent.
$nexp 1563
Ansi : The "* <char-length> [,]" form of character declaration is obsolesent.
.PP
This feature was declared obsolescent in the Fortran 95 standard.
.PP
Instead of the form  * <char-length> [,] for character declarations use the 
form:   * (<char-length>) [,]       OR    (LEN=<char-length>) [,]
.ME
$
$ Error : 1564
$msg  1564 Function "%s" is a %s function.  It must not be declared CHARACTER*(*).
$nexp 1564
Error : Function "%s" is a %s function.  It must not be declared CHARACTER*(*).
.PP
A constraint in the Fortran standard states that a function name declared with 
an asterisk char-len-param-value shall not be array-valued, pointer-valued, 
recursive or pure.

From 12.7.1. an elemental sub-program is a pure sub-program
.ME
$
$ Ansi : 1565
$msg  1565 Assumed length character functions are obsolescent.
$nexp 1565
Ansi : Assumed length character functions are obsolescent.
.PP
This feature was declared obsolescent in the Fortran 95 standard.
.PP
From the Fortran standard:
.PP
Assumed character length for functions is an irregularity in the language since
elsewhere in Fortran the philosophy is that the attributes of a function result
depend only on the actual arguments of the invocation and on any data 
accessible by the function through host or use association.  Some uses of this
facility can be replaced with an automatic character length function, where the
length of the function result is declared in a specification expression.  Other
uses can be replaced by the use of a subroutine whose arguments correspond to
the function result and the function arguments.  Note that dummy arguments of
a function may be assumed character length.
.ME
$
$ Warning : 1566
$msg  1566 Assumed length character function "%s" cannot be invoked.  There is no way to match caller/callee characteristics.
$nexp 1566
Warning : Assumed length character function "%s" cannot be invoked.  There is no way to match caller/callee characteristics.
.PP
From the Fortran standard:

An interface body may be specified for a dummy or external function whose
result has a character length parameter of * only if the function is not 
invoked.  This is because this characteristic has to be specified to be the
same in the interface body as in the procedure definition, but in order
to invoke such a procedure, the calling routine is required to specify a
length other than *.
.ME
$
$ Ansi : 1567
$msg  1567 Transfer of control to an END IF statement from outside the IF construct is an extension to the Fortran standard.
$nexp 1567
Ansi : Transfer of control to an END IF statement from outside the IF construct is an extension to the Fortran standard.
.PP
Instead of branching to the \*CEND IF\fR statement from outside its \*CIF\fR construct, 
branch to the statement following the \*CEND IF\fR.  This may require program logic
changes if the statement following the \*CEND IF\fR is not a valid branch target
statement. 
.PP
This feature was declared obsolescent in the Fortran 90 standard and
deleted in Fortran 95. This compiler supports the feature as an extension.
.ME
$
$ Ansi : 1568
$msg  1568 The %s statement is an extension to the Fortran standard.
$nexp 1568
Ansi : The %s statement is an extension to the Fortran standard.
.PP
This feature was deleted in Fortran
95. The compiler supports the feature as an extension.
.PP
The \*CASSIGN\fR statement allows a label to be dynamically assigned to an 
integer variable, and the assigned \*CGO TO\fR statement allows "indirect 
branching" through this variable.  This hinders the readability of the program
flow, especially if the integer variable also is used in arithmetic operations.
The two totally different usages of the integer variable can be an obscure 
source of error.
.PP
These statements have commonly been used to simulate internal procedures 
that can now be coded directly.
.PP
In most cases, the functionality of a \*CPAUSE\fR statement can be achieved in
a portable manner with the use of a \*CREAD\fR statement that awaits some 
input data.
.ME
$
$ Ansi : 1569
$msg  1569 A DO loop variable or expression of type default real or double precision real is an extension to the Fortran standard.
$nexp 1569
Ansi : A DO loop variable or expression of type default real or double precision real is an extension to the Fortran standard.
.PP
A real or double precision real variable or \*CDO\fR loop expression was
declared deleted in Fortran 95.
This compiler supports the feature as an extension.
.PP
Use an integer
variable  or expression instead.
.ME
$
$ Log_Error : 1570
$msg  1570 The -O stream command line option must not be specifed with the %s command line option.
$nexp 1570
Log_Error : The -O stream command line option must not be specifed with the %s command line option.
.PP
-Ostream, -Ostream and -Ostream must not be specified with the
-Z option.
.ME
$
$ Ansi : 1571
$msg  1571 Positioning the DATA statement amongst executable statements is an obsolescent feature.
$nexp 1571
Ansi : Positioning the DATA statement amongst executable statements is an obsolescent feature.
.PP
This feature was declared obsolescent in Fortran 95.
.PP
From the Fortran standard:
.PP
The statement ordering rules of FORTRAN 66, and hence FORTRAN 77 and Fortran 90
for compatibility, allowed DATA statements to appear anywhere in a program
unit after the specification statements.  The ability to position DATA
statements amongst executable statements is very rarely used, is unnecessary
and is a potential source of error.
.ME
$
$ Error : 1572
$msg  1572 Pointer assignment for components of derived type co-arrays is not supported.
$nexp 1572
Error : Pointer assignment for components of derived type co-arrays is not supported.
.PP
In the initial implementation of Fortran with co-arrays, POINTER
components of co-array derived type variables are treated as
if they were ALLOCATABLE objects. This means that pointer assignment
is not allowed for these components. 
.ME
$
$ Error : 1573
$msg  1573 The MOLD argument is not a valid argument to the NULL intrinsic in this context.
$nexp 1573
Error : The MOLD argument is not a valid argument to the NULL intrinsic in this context.
.PP
The MOLD argument is not allowed in initialization or DATA statements.
.ME
$
$ Error : 1574
$msg  1574 The MOLD argument must have the POINTER attribute.
$nexp 1574
Error : The MOLD argument must have the POINTER attribute.
.PP
MOLD must have the pointer attribute.
.ME
$
$ Error : 1575
$msg  1575 This argument to the THIS_IMAGE intrinsic must be a co-array. 
$nexp 1575
Error : This argument to the THIS_IMAGE intrinsic must be a co-array. 
.PP
Only a co-array may be specified to the THIS_IMAGE intrinsic
as the optional argument ARRAY.
.ME
$
$ Error : 1576
$msg  1576 The final co-array bound must be '*'.
$nexp 1576
Error : The final co-array bound must be '*'.
.PP
Co-array bounds declarations must be assumed size. The total
size of the co-array is always equal to the number of images
and so the final bound must always be specified as '*'.
.ME
$
$ Error : 1577
$msg  1577 "%s" is an automatic variable.  It must not have the co-array DIMENSION attribute.
$nexp 1577
Error : "%s" is an automatic variable.  It must not have the co-array DIMENSION attribute.
.PP
Automatic variable are not permitted to be co-arrays.
.ME
$
$ Error : 1578
$msg  1578 Variable "%s" has a co-array subobject.  Co-array subobjects must not be specified in %s statements.
$nexp 1578
Error : Variable "%s" has a co-array subobject.  Co-array subobjects must not be specified in %s statements.
.PP
A co-array subobject must not be specified in an EQUIVALENCE or DATA statement.
.ME
$
$ Error : 1579
$msg  1579 Component "%s" of derived type "%s" has the co-array DIMENSION attribute.  This is not permitted.
$nexp 1579
Error : Component "%s" of derived type "%s" has the co-array DIMENSION attribute.  This is not permitted.
.PP
Co-arrays may be of derived type but components of derived types are not 
permitted to be co-arrays.  In other words, the square bracket notation
is not allowed in a component declaration statement.
.ME
$
$ Error : 1580
$msg  1580 Pure or elemental subprogram "%s" must not contain "%s", which is a co-array variable or intrinsic.
$nexp 1580
Error : Pure or elemental subprogram "%s" must not contain "%s", which is a co-array variable or intrinsic.
.PP
A pure procedure is not allowed to contain any co-array Fortran features.
If the message refers to the USE statement, then the a variable with the
co-array DIMENSION attribute is being use associated.  The message also
can refer to a host associated variable with the co-array DIMENSION 
attribute.  None of the co-array Fortran intrinsics can be called in a
pure or elemental procudure either.

By definition an elemental subprogram is pure, so the above constraint also
applies to elemental subprograms.
.ME
$
$ Error : 1581
$msg  1581 All statements must be contained within a program unit and followed by END.
$nexp 1581
Error : All statements must be contained within a program unit and followed by END.
.PP
The compiler has detected a trailing statement following all program units.  All
valid Fortran statements must be contained within a program unit.  A program
unit should start with BLOCKDATA, MODULE, PROGRAM, SUBROUTINE or FUNCTION,
although the program unit statement is optional.   A program unit ends with
an END statement.  The END statement is not optional.
.ME
$
$ Ansi : 1582
$msg  1582 Fixed source form is an obsolescent feature in Fortran 95.
$nexp 1582
Ansi : Fixed source form is an obsolescent feature in Fortran 95.
.PP
Fixed source form is an obsolescent feature in the Fortran standard.  Free 
format is the preferred method.
.ME
$
$ Error : 1583
$msg  1583 Support for %s for %s is deferred.
$nexp 1583
Error : Support for %s for %s is deferred.
.PP
The support some features of co-array Fortran is deferred in
the initial prototype release.
.ME
$
$ Error : 1584
$msg  1584 This actual argument must be a co-array in order to be associated with a co-array dummy argument.
$nexp 1584
Error : This actual argument must be a co-array in order to be associated with a co-array dummy argument.
.PP
In order to ensure that copy-in or copy-out is not needed for a co-array
dummy argument, the actual arument must be the name of a co-array
or a subobject of a co-array. 
.ME
$
$ Error : 1585
$msg  1585 Only variables with a 64 bit type are currently supported in co-array references.
$nexp 1585
Error : Only variables with a 64 bit type are currently supported in co-array references.
.PP
In the initial prototype of co-array Fortran on the T3E, only 64
bit types are supported in co-array references.
.ME
$
$ Error : 1586
$msg  1586 Illegal branch %s a %s region.
$nexp 1586
Error : Illegal branch %s a %s region.
.PP
It is illegal to branch into or out of the structured blocks created
by the a tasking DO directive.  This includes GOTO statements as well as 
ERR=, EOF= or EOR= branches from IO statements and alternate return 
branches from subroutine calls.
.ME
$
$ Error : 1587
$msg  1587 Co-array %s must have the ALLOCATABLE attribute in order to have a deferred shape in the co-array dimensions.
$nexp 1587
Error : Co-array %s must have the ALLOCATABLE attribute in order to have a deferred shape in the co-array dimensions.
.PP
All co-array dimensions must be explicit shape bounds unless the
co-array has the ALLOCATABLE attribute.
The following is legal.
   integer, allocatable :: a(:)[:]

The following statment will produce this error.
   integer :: a (10)[:]
.ME
$
$ Error : 1588
$msg  1588 The %s statement is not allowed in a parallel or work sharing region.
$nexp 1588
Error : The %s statement is not allowed in a parallel or work sharing region.
.PP
A compiler directive was encountered prior to the current statement
that created a parallel or work sharing region. The current
statement is not allowed in this context.

This code will produce the message.

      SUBROUTINE S(N)

C$OMP PARALLEL

      INTEGER N

C$OMP END PARALLEL

      END

.ME
$
$ Error : 1589
$msg  1589 "%s" must not be specified in a DATA statement.  It is typed as derived type "%s", which is default initialized.
$nexp 1589
Error : "%s" must not be specified in a DATA statement.  It is typed as derived type "%s", which is default initialized.
.PP
From the Fortran 95 standard:  If a nonpointer object or subobject has been 
specified with default initialization in a type definition, it shall not
appear in a data-object-list.  In other words, if an object is typed as a
derived type that has default initialization, the time must not be specified
in a DATA statement.  The default initialization may be overridden by
specifying initialization on the type declaration statement.
.ME
$
$ Error : 1590
$msg  1590 "%s" is an assumed size array with INTENT(OUT).  It must not be typed as %s, because that type is default initialized.
$nexp 1590
Error : "%s" is an assumed size array with INTENT(OUT).  It must not be typed as %s, because that type is default initialized.
.PP
The standard prohibits a dummy argument that is an assumed size array with
the INTENT(OUT) attribute from being typed as a derived type that is default
initialized.
.ME
$
$ Error : 1591
$msg  1591 "%s" must not be equivalenced to an object in a common block, as its type is "%s", which is default initialized. 
$nexp 1591
Error : "%s" must not be equivalenced to an object in a common block, as its type is "%s", which is default initialized. 
.PP
From the Fortran 95 standard.  Equivalence association shall not cause a
derived type object with default initialization to be associated with an
object in a common block.
.ME
$
$ Internal : 1592
$msg  1592 ntr_stor_blk_tbl has been called with an invalid storage block type.  This should never happen.
$nexp 1592
Internal : ntr_stor_blk_tbl has been called with an invalid storage block type.  This should never happen.
.PP
The routine ntr_stor_blk_tbl has been called with an invalid or unknown
storage block type.
.PP
This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that the compiler does not try to issue this
message.
.ME
$
$ Limit : 1593
$msg  1593 A statement and its continuations exceeds the size of an internal source buffer.
$nexp 1593
Limit : A statement and its continuations exceeds the size of an internal source buffer.
.PP
A character array is used to store a complete fortran statement so that
the source preprocessor can scan for macros. Although this array is
quite large, it is possible to overflow this buffer. 
.ME
$
$ Error : 1594
$msg  1594 In an ALLOCATE statement for a co-array, the upper bound for the final co-dimension must always be '*'.
$nexp 1594
Error : In an ALLOCATE statement for a co-array, the upper bound for the final co-dimension must always be '*'.
.PP
To allocate an ALLOCATABLE co-array, the co-dimensions must be specified
with an assumed-size shape specifier, (*). 

      INTEGER, ALLOCATABLE :: A(:)[:]

      ALLOCATE(a(10)[2,*])
.ME
$
$ Error : 1595
$msg  1595 Transfer of control into the FORALL construct starting at line %d is not allowed.
$nexp 1595
Error : Transfer of control into the FORALL construct starting at line %d is not allowed.
.PP
The statement is attempting to transfer control to a statement in the
FORALL construct.  In a FORALL construct, only the FORALL construct 
statement itself can be a branch target.
.ME
$
$ Warning : 1596
$msg  1596 Label %s is defined in the FORALL construct starting at line %d.
$nexp 1596
Warning : Label %s is defined in the FORALL construct starting at line %d.
.PP
The label in the ASSIGN statement is defined on a statement contained in a
FORALL construct.  Transfer of control to the interior of a FORALL construct is
prohibited.
.ME
$
$ Error : 1597
$msg  1597 The %s statement is not allowed in a FORALL construct.
$nexp 1597
Error : The %s statement is not allowed in a FORALL construct.
.PP
Only assignment, pointer assigment, WHERE, and FORALL statements or constructs
are allowed within a FORALL construct.
.ME
$
$ Error : 1598
$msg  1598 The index-name in a FORALL header must be a named scalar variable of type INTEGER.
$nexp 1598
Error : The index-name in a FORALL header must be a named scalar variable of type INTEGER.
.PP
The index-name used in a FORALL statement or construct must be a named
scalar variable of type INTEGER. It cannot be a named constant, a
variable subobject or array element.
.ME
$
$ Error : 1599
$msg  1599 Index-name "%s" is already an index-name for an enclosing FORALL construct.
$nexp 1599
Error : Index-name "%s" is already an index-name for an enclosing FORALL construct.
.PP
Within the scope of a FORALL construct, a nested FORALL statement or FORALL
construct shall not have the same index-name.
.ME
$
$ Error : 1600
$msg  1600 Object "%s" is typed as derived type "%s" with default initialization.  It must not also be a common block object.
$nexp 1600
Error : Object "%s" is typed as derived type "%s" with default initialization.  It must not also be a common block object.
.PP
A constraint in the Fortran standard states:

If a common-block-object is of a derived type, it shall be a sequence type 
with no default initialization.

The compiler has detected a common block object that is of a sequence derived 
type that contains default initialization.
.ME
$
$ Inline : 1601
$msg  1601 Routine %s was not inlined because it has a Co-array dummy argument.
$nexp 1601
Inline : Routine %s was not inlined because it has a Co-array dummy argument.
.PP
In the initial implementation of Co-array fortran, inlining is not
supported when the procedure has co-array dummy arguments.
.ME
$
$ Warning : 1602
$msg  1602 Common block "%s" is used in multiple program units.  It must be specified with the %s directive in all uses: see line %s.
$nexp 1602
Warning : Common block "%s" is used in multiple program units.  It must be specified with %s in all uses: see line %s.
.PP
In this compilation, a common block is used in multiple program units.  If 
the common block is specified with a directive describing storage or how
offsets will be assigned within the block, it must have the same directive
specified in each block.  The directives are ALIGN_SYBMOL, FILL_SYMBOL,
SECTION_GP, SECTION_NON_GP and CACHE_ALIGN.  (Note: not all of these directives
are available on all platforms.)  A Fortran feature that can be used to
prevent these types of problems, is to declare the Common block in a module
and then USE the module where ever the Common block is declared.   In this way,
it is guaranteed that the Common block will be declared the same everywhere
it is used.
.ME
$
$ Caution : 1603
$msg  1603 Common block %s is declared in multiple program units.  One or more common objects differ in type, kind or rank.
$nexp 1603
Caution : Common block %s is declared in multiple program units.  One or more common objects differ in type, kind or rank.
.PP
During a compilation, the compiler keeps track of all common blocks and the
objects in the common block.  The compiler has found at least one object that
differs in kind, type and/or rank from an object in a previous declaration of
the same common block.
.ME
$
$ Error : 1604
$msg  1604 The subscript or stride in a forall-triplet-spec must be a scalar integer expression.
$nexp 1604
Error : The subscript or stride in a forall-triplet-spec must be a scalar integer expression.
.PP
A subscript or stride expression, used in a forall-triplet-spec, must
be a scalar integer expression.
.ME
$
$ Error : 1605
$msg  1605 A subscript or stride must not reference an index-name in the forall-triplet-spec-list in which it appears.
$nexp 1605
Error : A subscript or stride must not reference an index-name in the forall-triplet-spec-list in which it appears.
.PP
A subscript or stride expression, used in a forall-triplet-spec, must not
reference an index-name from the same FORALL header. A nested FORALL
statement or construct may reference the index-names from enclosing FORALL
constructs.
.ME
$
$ Error : 1606
$msg  1606 The stride value in a forall-triplet-spec must not be zero.
$nexp 1606
Error : The stride value in a forall-triplet-spec must not be zero.
.PP
The stride value used in a forall-triplet-spec must not evaluate
to zero.
.ME
$
$ Error : 1607
$msg  1607 The scalar-mask-expr for a FORALL statement must be a scalar logical expression.
$nexp 1607
Error : The scalar-mask-expr for a FORALL statement must be a scalar logical expression.
.PP
If present, the scalar-mask-expr for a FORALL statement or construct
must be a scalar expression of type logical.
.ME
$
$ Error : 1608
$msg  1608 The FORALL index must not be defined while it is active.
$nexp 1608
Error : The FORALL index must not be defined while it is active.
.PP
The name of an active FORALL index appeared in a statement that would change
the it's value.  The FORALL index can be used but not redefined
within the range of the FORALL construct or statement where it appears.
.ME
$
$ Error : 1609
$msg  1609 A masked ELSE WHERE block must not follow an ELSE WHERE block.
$nexp 1609
Error : A masked ELSE WHERE block must not follow an ELSE WHERE block.
.PP
If a WHERE construct contains an ELSE WHERE block, the ELSE WHERE must be the 
last block in the construct.  Thus, a masked ELSE WHERE block can not 
follow an ELSE WHERE block.
.ME
$
$ Error : 1610
$msg  1610 All mask expression within a WHERE construct must have the same shape.
$nexp 1610
Error : All mask expression within a WHERE construct must have the same shape.
.PP
If a WHERE construct contains a WHERE statement, a masked ELSEWHERE 
statement, or another WHERE construct then each mask expression
within the WHERE construct must have the same shape. A mask
expression was encountered that did not have the same shape as
a mask expression of an enclosing WHERE construct.
.ME
$
$ Error : 1611
$msg  1611 Procedure %s is referenced within a %s. It must be a PURE procedure.
$nexp 1611
Error : Procedure %s is referenced within a %s. It must be a PURE procedure.
.PP
Any procedure referenced in the scalar-mask-expr of a FORALL statement
or construct, or referenced in a forall-body-construct, including one
referenced by a defined operation or assignment, shall be a PURE
procedure.
.ME
$
$ Inline : 1612
$msg  1612 Routine %s was not inlined because it was called with a Co-array actual argument.
$nexp 1612
Inline : Routine %s was not inlined because it was called with a Co-array actual argument.
.PP
In the initial implementation of Co-array fortran, inlining is not supported
when the procedure has been called with co-array actual arguments.
.ME
$
$ Inline : 1613
$msg  1613 Routine %s was not inlined because it shares a common block with a Co-array member.
$nexp 1613
Inline : Routine %s was not inlined because it shares a common block with a Co-array member.
.PP
In the initial implementation of Co-array fortran, inlining is not supported
when the procedure shares a common block that has at least one co-array
member.
.ME
$
$ Caution : 1614
$msg  1614 Procedure "%s" is also referenced at line %s.  The type and rank of the function result of argument %d do not agree.
$nexp 1614
Caution : Procedure "%s" is also referenced at line %s.  The type and rank of the function result of argument %d do not agree.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

There is a mismatch between a dummy argument and an actual argument.
The type of actual arguments associated with dummy arguments must agree.
If these are both function definitions, then the type and rank of the function
result of the dummy procedures must agree.  If the dummy procedure is being
compared to an actual procedure then the type and rank of the function result
must agree.
.ME
$
$ Warning : 1615
$msg  1615 Procedure "%s" is defined at line %s.  Dummy argument "%s" is an array argument.  This argument is scalar.
$nexp 1615
Warning : Procedure "%s" is defined at line %s.  Dummy argument "%s" is an array argument.  This argument is scalar.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

The compiler is comparing two definitions or a definition and a reference to 
the listed procedure.  If the compiler is comparing two definitions, then
the compiler has found that in one definition, a dummy argument is an array
argument, but the corresponding dummy argument in the second definition is 
a scalar argument.  The arguments must be the same.  If the compiler is
comparing a reference with its definition, then it has found an array dummy
argument associated with a scalar actual argument or vice versa.  Again, the
arguments must either both be scalar or both be arrays. 
(Note:  In a reference, an array element is considered a scalar.)
.ME
$
$ Caution : 1616
$msg  1616 Procedure "%s" is also referenced at line %s.  Argument %d is scalar.  This argument is array-valued.
$nexp 1616
Caution : Procedure "%s" is also referenced at line %s.  Argument %d is scalar.  This argument is array-valued.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
.ME
$
$ Caution : 1617
$msg  1617 Function "%s" is also referenced at line %s.  The function result type and rank differ for the two references.
$nexp 1617
Caution : Function "%s" is also referenced at line %s.  The function result type and rank differ for the two references.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

If the same function is referenced in several places during compilation, the
function result type and rank should agree.
.ME
$
$ Warning : 1618
$msg  1618 Function "%s" is referenced at line %s.  The function result type and rank differ from this definition.
$nexp 1618
Warning : Function "%s" is referenced at line %s.  The function result type and rank differ from this definition.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

If the same function is referenced in several places during compilation, the
function result type and rank should agree.
.ME
$
$ Caution : 1619
$msg  1619 Procedure "%s" is also referenced at line %s.  Argument %d is array-valued.  This argument is scalar.
$nexp 1619
Caution : Procedure "%s" is also referenced at line %s.  Argument %d is array-valued.  This argument is scalar.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
.ME
$
$ Warning : 1620
$msg  1620 Program unit "%s" is referenced as a %s at line %s, but is defined or referenced as a %s here.
$nexp 1620
Warning : Program unit "%s" is referenced as a %s at line %s, but is defined or referenced as a %s here.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must only be declared once.  Any references to this global name, must be
correct and match the definition of this name.

The compiler has found a program unit referenced and definition that do not
match or two references that do not match.  See message 1293 for an example.
.ME
$
$ Warning : 1621
$msg  1621 "%s" is also referenced at line %s.  Argument %d is a label in one reference but not the other. They should be the same.
$nexp 1621
Warning : "%s" is also referenced at line %s.  Argument %d is a label in one reference but not the other. They should be the same.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
   
A reference to a Subroutine contains a user label as an actual argument.  In 
the other reference, that argument is not a user label.  Corresponding
arguments should be the same thing, either both labels, both program units,
or both data objects.
.ME
$
$ Warning : 1622
$msg  1622  "%s" is referenced at line %s. Argument %d is a user label. The dummy argument must be an alternate return argument.
$nexp 1622
Warning :  "%s" is referenced at line %s. Argument %d is a user label. The dummy argument must be an alternate return argument.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
   
An explicit interface or the Subroutine definition defines this dummy argument 
as an alternate return argument (*), but the call site does not supply a user 
label as the corresponding actual argument. 
.ME
$
$ Warning : 1623
$msg  1623 "%s" is also defined at line %s.  Argument %d must be an alternate return argument in both definitions.
$nexp 1623
Warning : "%s" is also defined at line %s.  Argument %d must be an alternate return argument in both definitions.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
      
This subroutine has more than one explicit interace. (This could be the actual
definition or multiple interface blocks for the Subroutine.)  In both 
definitions, the dummy arguments should be the same, but they are not.  In
one definition, the dummy argument is an alternate return argument.  In the
other definition, it is not.  They should be the same.
.ME
$
$ Error : 1624
$msg  1624 "%s" is also defined at line %s.  The %s attribute is specified in only one of the definitions.  It should be in both.
$nexp 1624
Error :"%s" is also defined at line %s.  The %s attribute is specified in only one of the definitions.  It should be in both.
.PP
During global semantics for this compilation, the compiler found that
the actual program unit definition disagrees with an interface block or 
another program unit definition.  These should be the same.

Attributes checked include pure, elemental and recursive.

NOTE:  For PURE - If PURE is specified on the definition, it does not need
to be specified in the interface body.
.ME
$
$ Error : 1625
$msg  1625 "%s" is also referenced at line %s.  The %s directive is specified in one location, but not the other.
$nexp 1625
Error :"%s" is also referenced at line %s.  The %s directive is specified in one location, but not the other.
.PP
During global semantics for this compilation, the compiler found that
two references in separate program units disagree with each other.
A call to a procedure is made in two separate program units.  In one program
unit the callee is declared with the specified directive.  This directive is
not specified for the callee in the second program unit.  The directives
being checked are NOSIDE EFFECTS and VFUNCTION.
.ME
$
$ Ansi : 1626
$msg  1626 Omitting the field width for edit descriptor "%c" is an extension to the Fortran standard.
$nexp 1626
Ansi : Omitting the field width for edit descriptor "%c" is an extension to the Fortran standard.
.PP
This message is issued when an edit-descriptor appears without
any width (or digits or exponent) field.

Examples:
  (I)
  (F)
  (G)
.ME
$
$ Error : 1627
$msg  1627 Equivalence-objects that are substrings, must not have a length of zero.
$nexp 1627
Error : Equivalence-objects that are substrings, must not have a length of zero.
.PP
A constraint in the Fortran standard states that if the equivalence-object is
a substring, the substring shall not have length zero.
.ME
$
$ Ansi : 1628
$msg  1628 Omitting the field width for edit descriptor "%c" is an extension to the Fortran standard.
$nexp 1628
Ansi : Omitting the field width for edit descriptor "%c" is an extension to the Fortran standard.
.PP
This message is issued when a zero is used for the field width for an
edit descriptor, which the standard states should not have a zero width.

Examples:
  (L0)
  (I0)  in FORTRAN 77 and Fortran 90 only--ok for Fortran95 (and later)

.ME
$
$ Error : 1629
$msg  1629 The following letter(s) were specified in a previous IMPLICIT %s statement: "%s", so must not be specified again.
$nexp 1629
Error : The following letter(s) were specified in a previous IMPLICIT %s statement: "%s", so must not be specified again.
.PP
A letter must only be specified once in an \*CIMPLICIT\fR type statement in a 
scoping unit and only once in an \*CIMPLICIT\fR storage statement in a scoping
unit.

   For example:

      IMPLICIT INTEGER (A)
      IMPLICIT REAL (A,B)          \fR! Illegal

This is illegal, because \*CA\fR was specified in the previous \*CIMPLICIT\fR 
type statement.
.ME
$
$ Log_Error : 1630
$msg  1630 Macro "%s" exceeds limit of %d characters.
$nexp 1630
Log_Error : Macro "%s" exceeds limit of %d characters.
.PP
The given macro has a definition which is longer than the supported
limit. Reducing the length of the macro, perhaps by splitting it 
into several smaller macros, will solve the problem.
.ME
$
$ Warning : 1631
$msg  1631 Unterminated character literal encountered in preprocessing directive.
$nexp 1631
Warning : Unterminated character literal encountered in preprocessing directive.
.PP
The source preprocessor encountered a character literal with no
closing delimiter within a source preprocessing directive.
.ME
$
$ Error : 1632
$msg  1632 The symbolic constant "%s" must not be defined.
$nexp 1632
Error : The symbolic constant "%s" must not be defined.
.PP
Symbolic constants must not be defined.
.ME
$
$ Warning : 1633
$msg  1633 The array subscript for dimension %d does not fall within the defined range.
$nexp 1633
Warning : The array subscript for dimension %d does not fall within the defined range.
.PP
An array reference was encountered where a subscript was out of bounds for
the array. The subscript could be either a single value, or a triplet
section.  The compiler will check array bounds at compile time if -C is
specified and the subscript and bounds values are constant. The BOUNDS
and NOBOUNDS compiler directives will control the issuing of this
message for specific ranges of code or for specific variables. You can
turn the compile-time warning into an error by setting the environment
variable F90_BOUNDS_CHECK_ABORT to "YES" (which also changes run-time
bounds check warnings into fatal errors.)
.PP
The following code shows three cases where this message would be issued.

      integer i(10)
      i(11) = 1
      i(1:11:1) = 1
      i(-1:10:1) = 1
.ME
$
$ Warning : 1634
$msg  1634 The substring start or end value are outside the defined range.
$nexp 1634
Warning : The substring start or end value are outside the defined range.
.PP
A character substring reference has an improper substring designator.  In the
following character substring reference, the substring designators, begin and
end, designate the beginning and ending character positions of the substring:

      CHAR ([begin]:[end])

If the substring has length greater than 0 then begin and end must be greater
than 0 and less than or equal to the number of characters in the entity,
CHAR. If end is less than begin the substring has length 0.
.ME
$
$ Error : 1635
$msg  1635 Argument mismatch:  "%s" and "%s" must both be functions or both be subroutines and have the same number of arguments.
$nexp 1635
Error : Argument mismatch:  "%s" and "%s" must both be functions or both be subroutines and have the same number of arguments.
.PP
An explicit interface has been declared for both the actual and dummy 
procedures.  The compiler has found that one is a function and one is a
subroutine or that the number of arguments is not the same for both the
actual and dummy arguments.
.ME
$
$ Log_Summary : 1636
$msg  1636 %s: "explain %s-message number" gives more information about each message
$nexp 1636
Log_Summary : %s: "explain %s-message number" gives more information about each message
.PP
The explain command gives a more verbose description of the message and why
it was issued.   See man explain for details on the explain command.
For example:  To get more info about message 33 use the command this way:

f90-724 f90: ERROR MAIN__, File = d.f, Line = 1, Column = 14 
  Unknown statement.  Expected assignment statement but found "EOS" instead of "=" or "=>".


explain f90-724

.ME
$
$ Comment : 1637
$msg  1637 Command line option %s has been applied to array "%s".
$nexp 1637
Comment : Command line option %s has been applied to array "%s".
.PP
The specified array has been reshaped because it is specified on the 
reshape command line option or because the generic reshape command line option
has been specified and this array meets the necessary criteria.
.ME
$
$ Error : 1638
$msg  1638 A WHERE assignment statement that is a defined assignment must be elemental.
$nexp 1638
Error : A WHERE assignment statement that is a defined assignment must be elemental.
.PP
If an assignment in a WHERE statement or WHERE construct is a 
defined assignment, the subroutine must be elemental.
.ME
$
$ Error : 1639
$msg  1639 "%s" is an elemental procedure.  It must not be used as an actual argument.
$nexp 1639
Error : "%s" is an elemental procedure.  It must not be used as an actual argument.
.PP
A constraint to the Fortran standard states that a non-intrinsic elemental
procedure must not be used as an actual argument.
.ME
$
$ Ansi : 1640
$msg  1640 The Fortran standard does not allow the END statement to be continued.
$nexp 1640
Ansi : The Fortran standard does not allow the END statement to be continued.
.PP
A constraint in the Fortran standard states that the END statement must not be
continued.
.ME
$
$ Ansi : 1641
$msg  1641 The standard states that ALLOCATABLE, POINTER or SAVE must be specified for "%s" as it is default initialized type "%s".
$nexp 1641
Ansi : The standard states that ALLOCATABLE, POINTER or SAVE must be specified for "%s" as it is default initialized type "%s".
.PP
A constraint to the Fortran standard reads:

"If an object of a type for which component-initialization is specified
appears in the specification-part of a module and does not have the
ALLOCATABLE or POINTER attribute, the object shall have the SAVE attribute."

This constraint refers to objects declared in the specification part of the
module that are not members of a common block and that are not constants.

If the object is defined as a derived-type for which default-initialization
has been specified, then the SAVE attribute must be specified for the object.

This compiler has relaxed this rule and does not require SAVE to be
specified, as objects specified in the specification-part of a module
are treated as SAVEd objects.
.ME
$
$ Error : 1642
$msg  1642 Procedure "%s" is being passed to PURE procedure "%s".  It must also be PURE.
$nexp 1642
Error : Procedure "%s" is being passed to PURE procedure "%s".  It must also be PURE.
.PP
A constraint in the Fortran standard requires that all procedures passed to
a PURE procedure must be PURE.
.ME
$
$ Internal : 1643
$msg  1643 The %s enum has been changed.
$nexp 1643
Internal : The %s enum has been changed.
.PP
The compiler has detected a change in the listed enum.  This enum must not
change in this manner.  

This message should never be generated.  Please notify your product support
organization with this error message number and any supporting information.
This message does not indicate a problem with your code, although you may be
able to change your code so that this error is not encountered.
.ME
$
$ Error : 1644
$msg  1644 Array "%s" must not be statically intialized to be specified with -O reshape.
$nexp 1644
Error : Array "%s" must not be statically intialized to be specified with -O reshape.
.PP
Arrays which have been statically intialize may not be reshaped.
.ME
$
$ Error : 1645
$msg  1645 Common block "/%s/" cannot be specified in both a !$OMP THREADPRIVATE directive and a !*$* SECTION_GP directive.
$nexp 1645
Error : Common block "/%s/" cannot be specified in both a !$OMP THREADPRIVATE directive and a !*$* SECTION_GP directive.
.PP
The !$OMP THREADPRIVATE directive prevents any common block from
being placed in a GP-rel area. Any SECTION_GP directive which
specifies a THREADPRIVATE common block will cause this error message
to be issued.
.ME
$
$ Error : 1646
$msg  1646 Rank of the actual argument "%s" is less than the rank of the dummy argument "%s".
$nexp 1646
Error : Rank of the actual argument "%s" is less than the rank of the dummy argument "%s".
.PP
With the -Oreshape option specified the user cannot map an actual argument
with a lesser rank than the dummy argument it is associated with.
.ME
$
$ Warning : 1647
$msg  1647 "%s" is a CRI Pointee.  It will not be default initialized.
$nexp 1647
Warning : "%s" is a CRI Pointee.  It will not be default initialized.
.PP
CRI Pointees may be declared as derived type, but they will not be 
default initialized, since there is no storage associated with a
CRI Pointee until it is assigned storage.
.ME
$
$ Error : 1648
$msg  1648 The data-stmt-constant must be a named or literal constant or NULL() or a structure-constructor.
$nexp 1648
Error : The data-stmt-constant must be a named or literal constant or NULL() or a structure-constructor.
.PP
KAY - Update
The data-stmt-repeat is defined as follows:

     data-stmt-repeate     is   scalar-int-constant
                                scalar-int-constant-subobject

The following restrictions apply:

    The data-stmt-repeat shall be positive or zero. 

    If the data-stmt-repeat is a named constant, it shall have been declared
    previously in the socping unit or made addciessible by use association 
    or host association.

    In a scalar-constant-subobject that is a data-stmt-repeat any subscript
    shall be an initialization expression.
.ME
$
$ Warning : 1649
$msg  1649 A divisor of zero was detected in an expression.
$nexp 1649
Warning : A divisor of zero was detected in an expression.
.PP
When a divisor of zero is detected by the compiler and
it is used within an expression that does not need to
be evaluated at compile time, this Warning level message
is issued for a possible user error. If the expression
is a constant expression that is evaluated at
compile time, then an Error level message is issued.
.ME
$
$ Error : 1650
$msg  1650 This argument cannot be a constant or protected variable.
$nexp 1650
Error : This argument cannot be a constant or protected variable.
.PP
This actual argument may not be a constant, and it may not be a use-associated
variable with the PROTECTED attribute.
.ME
$
$ Error : 1651
$msg  1651 %s variable %s not SHARED in enclosing parallel region.
$nexp 1651
Error : %s variable %s not SHARED in enclosing parallel region.
.PP
Variables that are privatized in a parallel region cannot be privatized again
on an enclosed work-sharing directive. As a result, variables that appear in
the PRIVATE, FIRSTPRIVATE, LASTPRIVATE and REDUCTION clauses on a work-sharing
directive must have shared scope in the enclosing parallel region. Work-
sharing directives are !$OMP DO, !$OMP SECTIONS, and !$OMP SINGLE.
.ME
$
$ Inline : 1652
$msg  1652 Routine %s was not inlined because it contains assignment of integer to a CRI pointer.
$nexp 1652
Inline : Routine %s was not inlined because it contains assignment of integer to a CRI pointer.
.PP
If a routine contains assignment of an integer constant or variable to a
CRI pointer, this can cause potential alias problems and cause bad code to be
generated.   Inlining of routines containing such assignents is suppressed.
.ME
$
$ Warning : 1653
$msg  1653 The message severity for message number %d must not be changed to %s.  The change in severity will be ignored.
$nexp 1653
Warning : The message severity for message number %d must not be changed to %s.  The change in severity will be ignored.
.PP
Message severity cannot be changed for the following message types:

      Vector, Scalar, Table, Inline, Info, Tasking, Optimization and Stream
      Internal and Limit

      Log_Error, Log_Warning and Log_Summary

Further a message with a severity of Error must not be changed to Warning.
The change in message severity of this number will be ignored.
.ME
$
$ Error : 1654
$msg  1654 Generic interface "%s" must not be specified with the %s directive, because the directive has the GLOBAL clause.
$nexp 1654
Error : Generic interface "%s" must not be specified with the %s directive, because the directive has the GLOBAL clause.
.PP
Generic interfaces can be specified with the INLINE and IPA directives unless
they are specified with the GLOBAL clause.  This is not allowed because a
generic interface name is not an external (global) name.   It is considered
a local name in each program unit.
.ME
$
$ Error : 1655
$msg  1655 The "%s" intrinsic must not be specified with the %s directive.  The intrinsic is not overloaded.
$nexp 1655
Error : The "%s" intrinsic must not be specified with the %s directive.  The intrinsic is not overloaded.
.PP
The INLINE and IPA directives may only be specified for INTRINSICs that are
overloaded.  This intrinsic is not overloaded, so the directives must not
be specified.  The directives can only apply to overloaded intrinsics.
.ME
$
$ Error : 1656
$msg  1656 A compiler directive may not follow a continued Fortran source line.
$nexp 1656
Error : A compiler directive may not follow a continued Fortran source line.
.PP
A compiler directive was encountered following a continued Fortran source
line. Directives cannot be embedded within continued sourece lines. The
following is illegal.

i = 10 &
!$OMP PARALLEL
  & + 10
.ME
$
$ Inline : 1657
$msg  1657 Routine %s was not inlined because it is an ELEMENTAL procedure.
$nexp 1657
Inline : Routine %s was not inlined because it is an ELEMENTAL procedure.
.PP
Routines which have the ELEMENTAL attribute will not be inlined.
.ME
$
$ Log_Error : 1658
$msg  1658 Module output must be going to a .mod file, if the -J option is specified with a path name for module output.
$nexp 1658
Log_Error : Module output must be going to a .mod file, if the -J option is specified with a path name for module output.
.PP
If -J (a path for module output), then module output must be going to a .mod
file.  (Option -em)
.ME
$
$ Log_Warning : 1659
$msg  1659 "-col120" will be translated to -extend_source which allows 132 columns.
$nexp 1659
Log_Warning : "-col120" will be translated to -extend_source which allows 132 columns.
.PP
The f77 commandline option -col120 will be tranlated to the -extend_source
option and 132 characters will be allowed.   
.ME
$
$ Caution : 1660
$msg  1660 Procedure "%s" is defined at line %s with dummy argument "%s".  This argument is a procedure.
$nexp 1660
Caution : Procedure "%s" is defined at line %s with dummy argument "%s".  This argument is a procedure.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.
   
There is a mismatch between a dummy argument and an actual argument.  If the
dummy argument is a data object, the actual argument must be a data object.
If the dummy argument is a procedure, the actual argument must be a procedure.
If these are both definitions, then both dummy arguments must agree.
.ME
$
$ Caution : 1661
$msg  1661 "%s" is referenced at line %s and defined here. Argument "%s" is a dummy argument.  The actual argument is a procedure.
$nexp 1661
Caution : "%s" is referenced at line %s and defined here. Argument "%s" is a dummy argument.  The actual argument is a procedure.
.PP
The scope of a global name is the entire compilation, so a global (or external)
name must be defined and referenced consistently throughout the compilation.
The compiler has found that a reference or definition of this global name
differs with another reference or definition for this name.

There is a mismatch between a dummy argument and an actual argument.  If the
dummy argument is a data object, the actual argument must be a data object.
If the dummy argument is a procedure, the actual argument must be a procedure.
If these are both definitions, then both dummy arguments must agree.
Note:  In this context, data object can also mean a constant value or an
expression, neither of which is a procedure.
.ME
$
$ Ansi : 1662
$msg  1662 The slash form of data initialization on a type declaration statement is nonstandard.
$nexp 1662
Ansi : The slash form of data initialization on a type declaration statement is nonstandard.
.PP
The following type of data initialization is nonstandard.

  character*3 name /"123"/
.ME
$
$ Error : 1663
$msg  1663 The slash form of data initialization must not be used when the PARAMETER attribute is specified.
$nexp 1663
Error : The slash form of data initialization must not be used when the PARAMETER attribute is specified.
.PP
If the parameter attribute is specified, the slash method of data 
initialization must not be used.  
.ME
$
$ Error : 1664
$msg  1664 The argument must be integer and large enough to hold an address.
$nexp 1664
Error : The argument must be integer and large enough to hold an address.
.PP
The size of the integer argument is not large enough to hold an 
address.   

eg.
         INTEGER (4) LOCK
         OMP_SET_LOCK(LOCK)
         END

     If the above test case is compiled with -64 (on MIPS)
     a kind=4 integer is not large enough to hold the address.
.ME
$
$ Error : 1665
$msg  1665 Module or procedure "%s" cannot be written out, because the compiler cannot open file "%s" (%s).
$nexp 1665
Error : Module or procedure "%s" cannot be written out, because the compiler cannot open file "%s" (%s).
.PP
The compiler is unable to open a file to write out the module information
tables or inlining information.  Check the permissions on the file name or 
the directory that the file will be written to.  If this is a module table
and the module is used later on in compilation this will cause cascading
errors, because the compiler will be unable to bring the module information
back in again.
.ME
$
$ Error : 1666
$msg  1666 Label variable "%s" must be scalar and of type Integer (kind=8).
$nexp 1666
Error : Label variable "%s" must be scalar and of type Integer (kind=8).
.PP
An \*CASSIGN\fR statement or an \*Cassigned GO TO\fR statement has a label variable
   (\fIscalar_int_variable\fR) that is not of type integer (kind=8).

   
   The syntax of the \*CASSIGN\fR statement is:

     \*CASSIGN\fR \fIlabel \*CTO\fR \fIscalar_int_variable\fR

   
   The syntax of the \*Cassigned GO TO\fR statement is:

     \*CGO TO\fR \fIscalar_int_variable\*C [ [\fR,\*C] (\fIlabel_list\*C) ]\fR

   
   The \fIscalar_int_variable\fR must be an unqualified name; it cannot be a
   structure component, array element, or substring designator.  The variable
   must be of type default integer, and it must be scalar.  For these statements,
   "type default integer" also means that the integer must be a full word.  This
   message is produced if an option such as \*C-i 32\fR or \*C-s default32\fR is
   specified and the \fIscalar_int_variable\fR is of type default integer because
   these options reduce the bit length of default integers (a Cray T3E address
   is longer than 32 bits).


.ME
$
$ Error : 1667
$msg  1667 External function "%s" is referenced in a bounds specification expression.  It must not be recursive.
$nexp 1667
Error : External function "%s" is referenced in a bounds specification expression.  It must not be recursive.
.PP
The Fortran standard allows specification functions be to specified in 
in array dimension bound declarators or character length declarators.

However, these functions must not have array-valued or pointer-valued results.
They must not be recursive and they must not have any arguments that are
procedures.   Internal functions are also not allowed.   The standard requires
these functions to be PURE.  This compiler allows functions without the PURE
attribute to be specified as an extension to the standard.  However PURE
functions are the safest to use in specification expressions.
.ME
$
$ Error : 1668
$msg  1668 External function "%s" is referenced in a bounds specification expression.  It must not have procedure arguments.
$nexp 1668
Error : External function "%s" is referenced in a bounds specification expression.  It must not have procedure arguments.
.PP
The Fortran standard allows specification functions be to specified in 
in array dimension bound declarators or character length declarators.

However, these functions must not have array-valued or pointer-valued results.
They must not be recursive and they must not have any arguments that are
procedures.   Internal functions are also not allowed.   The standard requires
these functions to be PURE.  This compiler allows functions without the PURE
attribute to be specified as an extension to the standard.  However PURE
functions are the safest to use in specification expressions.
.ME
$
$ Error : 1669
$msg  1669 "%s" is not supported on this platform.
$nexp 1669
Error : "%s" is not supported on this platform.
.PP
The following listed items are not supported on the specified platform.
  Quad precision (ie:  real(kind=16), real*16 
                       complex(kind=16), complex*32        LINUX
.ME
$
$ Warning : 1670
$msg  1670 Macro "%s" redefined without intervening undef directive
$nexp 1670
Warning : Macro "%s" should have been undefined with the undef directive before being redefined.
.ME
$
$ Ansi : 1671
$msg  1671 Identifier exceeding 31 character limit is nonstandard
$nexp 1671
Ansi : Identifier exceeding 31 character limit is nonstandard
.PP
The compiler accepted this identifier although its length exceeds 31
characters. The Fortran standard limits identifer length to 31 characters.
.ME
$
$ Error : 1672
$msg  1672 The NUM_THREADS expression must be a scalar INTEGER expression.
$nexp 1672
Error : The NUM_THREADS expression must be a scalar INTEGER expression.
.PP
The NUM_THREADS expression to the !$OMP PARALLEL directive must
be a scalar integer expression.
.ME
$
$ Error : 1673
$msg  1673 Invalid NUM_THREADS value.
$nexp 1673
Error : Invalid NUM_THREADS value.
.PP
The value of the NUM_THREADS expression to the !$OMP PARALLEL directive
must be greater than zero.
.ME
$
$ Limit : 1674
$msg  1674 Line exceeds compiler limit of %d characters in free source form
$nexp 1674
Limit : Line exceeds compiler limit of %s characters in free source form
.PP
A line in free source form was too long for the compiler to process. You may
avoid the problem by splitting the line, using the statement continuation
character '&'.
.ME
$
$ Warning : 1675
$msg  1675 Intrinsic "%s" is a function, so this call to a subroutine will be treated as "external"
$nexp 1675
Warning : Intrinsic "%s" is a function, so this call to a subroutine will be treated as "external"
.PP
The subroutine name in a "call" statement matches that of an intrinsic function,
possibly an intrinsic which is an extension to the standard. In the absence of
either an "intrinsic" declaration or an "external" declaration, the compiler
will assume it refers to an external subroutine.
.ME
$
$ Error : 1676
$msg  1676 Cannot open file "%s" (%s)
$nexp 1676
Error :  Cannot open file "%s" (%s)
.PP
The compiler is unable to open a file. Check the permissions on the file name
or the directory.
.ME
$
$ Error : 1677
$msg  1677 Invalid reference to target of null pointer constant
$nexp 1677
Error :  Invalid reference to target of null pointer constant
.PP
This pointer has the "parameter" attribute and a value of NULL, so it cannot
appear in a context which refers to the target of the pointer.
.ME
$
$ Error : 1678
$msg  1678 A scoping unit may not access an intrinsic module and a nonintrinsic module of the same name
$nexp 1678
Error :  A scoping unit may not access an intrinsic module and a nonintrinsic module of the same name
.PP
In a scoping unit, the "use" statements for a particular module may not have
both "intrinsic" and "non_intrinsic" keywords. If one "use" statement has one
of those keywords, and another "use" statement has neither keyword, the
latter statement (which prefers a non-intrinsic module over an intrinsic
module of the same name) must access the same module as the former statement.
.ME
$
$ Ansi : 1679
$msg  1679 Using ALLOCATABLE with dummy arguments, function results, and components of derived types is an extension to Fortran 95
$nexp 1679
Ansi :  Using ALLOCATABLE with dummy arguments, function results, and components of derived types is an extension to Fortran 95
.PP
A constraint in the Fortran 95 standard requires the compiler to be able to
issue a warning about the use of ALLOCATABLE with dummy arguments, function
results, and components of derived types. This extension was first described
in ISO document TR15581, and is a standard part of Fortran 2003.
.ME
$
$ Error : 1680
$msg  1680 %s: Cannot initialize a derived type which has an ALLOCATABLE component
$nexp 1680
Error :  %s: Cannot initialize a derived type which has an ALLOCATABLE component
.PP
If a component of a derived type has the ALLOCATABLE attribute, the Fortran
standard forbids default initialization of that component. If a variable
is declared with a derived type having an ALLOCATABLE component or subcomponent,
the standard forbids initialization of that variable in a declaration or DATA
statement.
.ME
$
$ Warning : 1681
$msg  1681 Option -[no-]intrinsic=%s found a single intrinsic, not a family of intrinsics
$nexp 1681
Warning : Option -[no-]intrinsic=%s found a single intrinsic, not a family of intrinsics
.PP
The option -[no-]intrinsic=x normally applies to a family of intrinsics when
'x' is in upper case. In this case, there was no family with the name supplied,
but there was an individual intrinsic with that name, so the option was applied
to that individual intrinsic.
.ME
$
$ Ansi : 1682
$msg  1682 Statement functions are an obsolescent feature
$nexp 1682
Ansi :  Statement functions are an obsolescent feature
.PP
This feature was declared obsolescent in the Fortran 95 standard. An
alternative is to create an internal procedure using the "contains" keyword.
.ME
$
$ Error : 1683
$msg  1683 Duplicate or conflicting IMPORT of %s
$nexp 1683
Error :  Duplicate or conflicting IMPORT of %s
.PP
The name has already appeared in an "import" statement in this interface body,
or there is already a declaration of the name which is local to the interface
body
.ME
$
$ Error : 1684
$msg  1684 %s cannot be imported from the host scoping unit
$nexp 1684
Error :  %s cannot be imported from the host scoping unit
.PP
The name is not accessible in the host scoping unit. Note that the declaration
of a name in the host must precede its use in an IMPORT statement.
.ME
$
$ Ansi : 1685
$msg  1685 Not standard prior to Fortran 2003 (%s)
$nexp 1685
Ansi :  Not standard prior to Fortran 2003 (%s)
.PP
Prior to the Fortran 2003 standard, this construct was not available, though
compilers may have allowed it as an extension.
.ME
$
$ Error : 1686
$msg  1686 Only the ENUMERATOR statement is allowed between ENUM and END ENUM statements
$nexp 1686
Error :  Only the ENUMERATOR statement is allowed between ENUM and END ENUM statements
.PP
Only the ENUMERATOR statement is allowed between ENUM and END ENUM statements
.ME
$
$ Warning : 1687
$msg  1687 %s appears in OpenMP THREADPRIVATE but is neither a module variable nor SAVEd.
$nexp 1687
Warning :   %s appears in OpenMP THREADPRIVATE but is neither a module variable nor SAVEd.
.PP
The OpenMP THREADPRIVATE directive requires either an entire common block, or
an individual variable which is either a module variable or a variable having
the SAVE attribute which is not in a common block.
.ME
$
$ Error : 1688
$msg  1688 Because dummy argument %s is volatile, this actual argument is not allowed
$nexp 1688
Error :   Because dummy argument %s is volatile, this actual argument is not allowed
.PP
If a dummy argument is volatile, then:
  1. The actual argument may not be an array section using a vector subscript
  2. If the actual argument is a pointer, the dummy argument must be a pointer
    or an assumed-shape array (Fortran 2003 constraint C1233)
  3. If the actual argument is an assumed-shape array or an array section
    not using a vector subscript, the dummy argument must be an assumed-shape
    array (Fortran 2003 constraint C1232)
.ME
$
$ Error : 1689
$msg  1689 BIND with NAME= cannot apply to more than one entity in statement
$nexp 1689
Error :   BIND with NAME= cannot apply to more than one entity in statement
.PP
Fortran 2003 constraints C533 and C551 forbid multiple entities in a single
statement if BIND specifies an explicit language binding label
.ME
$
$ Error : 1690
$msg  1690 NAME= specifier in BIND clause requires scalar character constant
$nexp 1690
Error :   NAME= specifier in BIND clause requires scalar character constant
.PP
Fortran 2003 constraint C540 requires that the NAME= specifier in a
language-binding-spec must provide a scalar character constant expression
.ME
$
$ Error : 1691
$msg  1691 For "%s", %s not allowed with BIND(C)
$nexp 1691
Error :   For "%s", "%s" not allowed with BIND(C)
.PP
Various Fortran 2003 constraints limit the use of the language binding spec
"BIND(C)":
.PP
  C530: Dummy argument must not have ALLOCATABLE, POINTER, or OPTIONAL
    attribute
  C532: Entity must be an interoperable variable or procedure
  C550: Variable must be interoperable and appear in module specification
    part
  C1237: Procedure must not be internal
  C1238: Procedure dummy argument must be nonoptional interoperable variable
    or procedure; function result must be interoperable variable
  C1242: Function must not be ELEMENTAL
  C1501: Derived type must not have SEQUENCE
  C1502: Derived type must not have type parameters
  C1503: Derived type must not have EXTENDS attribute
  C1504: Derived type must not have a type-bound procedure
  C1505: Each component of derived type must be interoperable, and must not
    have POINTER or ALLOCATABLE attribute
.PP
"Interoperable" means that an equivalent entity can be defined by means of C:
generally, its type must be one of the types provided by the intrinsic module
"ISO_C_BINDING", or a derived type which itself uses "BIND" and whose
components are interoperable. ALLOCATABLE and POINTER variables are never
interoperable. Only explicit-shape and assumed-size arrays can be
interoperable. CHARACTER types can be arrays, but must have LEN=1.
.ME
$
$ Error : 1692
$msg  1692 Argument of intrinsic C_LOC or C_FUNLOC doesn't satisfy Fortran 2003
$nexp 1692
Error :   Argument of intrinsic C_LOC or C_FUNLOC doesn't satisfy Fortran 2003
.PP
Fortran 2003 requires that the argument of ISO_C_BINDING module procedure C_LOC
either have interoperable type and type parameters, or be a nonpolymorphic
scalar with no length type parameters.
.PP
If it has an interoperable type, it must satisfy one of these requirements:
  1. It must be a variable with the TARGET attribute but without ALLOCATABLE
    and POINTER, or
  2. It must be a variable with ALLOCATABLE and TARGET attributes which
    is allocated and is not a zero-size array, or
  3. It must be a scalar with the POINTER attribute which is associated
.PP
Otherwise, it must either have the TARGET attribute or it must be a POINTER;
if it is ALLOCATABLE, it must be allocated.
.PP
Fortran 2003 requires that the argument of C_FUNLOC be a procedure with the
BIND attribute, or a procedure pointer associated with an interoperable target.
.ME
$
$ Error : 1693
$msg  1693 For "%s", type "%s" lacks the BIND attribute
$nexp 1693
Error :   For "%s", type "%s" lacks the BIND attribute
.PP
To be interoperable with C, a structure must use a type which has the BIND
attribute.
.ME
$
$ Error : 1694
$msg  1694 Cannot use BIND on "%s": not in specification part of module
$nexp 1694
Error :   Cannot use BIND on "%s": not in specification part of module
.PP
Fortran 2003 constraint C550 prohibits the BIND attribute on a variable
declaration outside the specification part of a module.
.ME
$
$ Error : 1695
$msg  1695 For "%s", BIND requires CHARACTER type to have LEN=1
$nexp 1695
Error :   For "%s", BIND requires CHARACTER type to have LEN=1
.PP
The Fortran standard requires that
a CHARACTER type used with BIND must have LEN=1, "*1", or default
LEN in order to be interoperable with C. An array of CHARACTER(LEN=1) is
allowed.
.ME
$
$ Error : 1696
$msg  1696 Applied BIND more than once to "%s" (identifier first appeared at line %d)
$nexp 1696
Error :   Applied BIND more than once to "%s" (identifier first appeared at line %d)
.PP
The BIND attribute has been applied to the variable or common block more than
once
.ME
$
$ Ansi : 1697
$msg  1697 Fortran 2003 feature: "%s" is both %s and %s (identifier first appeared at line %d)
$nexp 1697
Ansi :   Fortran 2003 feature: "%s" is both %s and %s (identifier first appeared at line %d)
.PP
A dummy argument could not have both POINTER and "INTENT" attributes prior to Fortran 2003.
.ME
$
$ Error : 1698
$msg  1698 Error in argument SHAPE of intrinsic C_F_POINTER
$nexp 1698
Error :   Error in argument SHAPE of intrinsic C_F_POINTER
.PP
For intrinsic C_F_POINTER, if argument FPTR is not a pointer, then the optional
argument SHAPE must not appear. Otherwise, SHAPE must be an array of rank 1
whose size is equal to the rank of FPTR.
.ME
$
$ Error : 1699
$msg  1699 Dummy procedure %s needs BIND attribute to make %s interoperable
$nexp 1699
Error :   Dummy procedure %s needs BIND attribute to make %s interoperable
.PP
If a procedure has the BIND attribute, and one of its dummy arguments is a
dummy procedure, then the dummy procedure must also have the BIND attribute.
.ME
$
$ Error : 1700
$msg  1700 For "%s", binding label does not match the one ("%s") defined at line %s
$nexp 1700
Error :   For "%s", binding label does not match the one ("%s") defined at line %s
.PP
The binding label specified (explicitly or implicitly) by the "BIND" attribute
should be consistent.
.ME
$
$ Warning : 1701
$msg  1701 "%s" and "%s" have same external linker symbol "%s": see line %s
$nexp 1701
Warning :   "%s" and "%s" have same external linker symbol "%s": see line %s
.PP
The same external linker symbol is being used for two different procedures or common blocks, probably due to an error in a BIND clause.
.ME
$
$ Error : 1702
$msg  1702 Cannot change constant or PROTECTED entity "%s"
$nexp 1702
Error :   Cannot change constant or PROTECTED entity "%s"
.PP
The value of a constant entity cannot be redefined.
.PP
The value of an entity with the PROTECTED attribute can be used but not defined
outside the module which declares the entity. If the entity has the POINTER or
ALLOCATABLE attribute, it cannot be allocated, deallocated, or nullified outside
the module either.
.ME
$ LAST NUMBER USED : 1702
	
